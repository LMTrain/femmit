(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('prop-types'), require('classnames'), require('react-dom')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'prop-types', 'classnames', 'react-dom'], factory) :
  (factory((global.gestalt = {}),global.React,global.PropTypes,global.classnames,global.ReactDOM));
}(this, (function (exports,React,PropTypes,classnames,reactDom) { 'use strict';

  PropTypes = PropTypes && PropTypes.hasOwnProperty('default') ? PropTypes['default'] : PropTypes;
  classnames = classnames && classnames.hasOwnProperty('default') ? classnames['default'] : classnames;

  var styles = { "box": "_h _xt _4q", "xsDisplayNone": "_i", "xsDisplayFlex": "_j", "xsDisplayBlock": "_k", "xsDisplayInlineBlock": "_l", "xsDisplayVisuallyHidden": "_m", "smDisplayNone": "_n", "smDisplayFlex": "_o", "smDisplayBlock": "_p", "smDisplayInlineBlock": "_q", "smDisplayVisuallyHidden": "_r", "mdDisplayNone": "_s", "mdDisplayFlex": "_t", "mdDisplayBlock": "_u", "mdDisplayInlineBlock": "_v", "mdDisplayVisuallyHidden": "_w", "lgDisplayNone": "_x", "lgDisplayFlex": "_y", "lgDisplayBlock": "_z", "lgDisplayInlineBlock": "_10", "lgDisplayVisuallyHidden": "_11", "xsDirectionRow": "_12", "xsDirectionColumn": "_13", "smDirectionRow": "_14", "smDirectionColumn": "_15", "mdDirectionRow": "_16", "mdDirectionColumn": "_17", "lgDirectionRow": "_18", "lgDirectionColumn": "_19", "xsCol0": "_1a", "xsCol1": "_1b _xw", "xsCol2": "_1c _xx", "xsCol3": "_1d _xy", "xsCol4": "_1e _xz", "xsCol5": "_1f _y0", "xsCol6": "_1g _y1", "xsCol7": "_1h _y2", "xsCol8": "_1i _y3", "xsCol9": "_1j _y4", "xsCol10": "_1k _y5", "xsCol11": "_1l _y6", "xsCol12": "_1m _y7", "smCol0": "_1n", "smCol1": "_1o _y8", "smCol2": "_1p _y9", "smCol3": "_1q _ya", "smCol4": "_1r _yb", "smCol5": "_1s _yc", "smCol6": "_1t _yd", "smCol7": "_1u _ye", "smCol8": "_1v _yf", "smCol9": "_1w _yg", "smCol10": "_1x _yh", "smCol11": "_1y _yi", "smCol12": "_1z _yj", "mdCol0": "_20", "mdCol1": "_21 _yk", "mdCol2": "_22 _yl", "mdCol3": "_23 _ym", "mdCol4": "_24 _yn", "mdCol5": "_25 _yo", "mdCol6": "_26 _yp", "mdCol7": "_27 _yq", "mdCol8": "_28 _yr", "mdCol9": "_29 _ys", "mdCol10": "_2a _yt", "mdCol11": "_2b _yu", "mdCol12": "_2c _yv", "lgCol0": "_2d", "lgCol1": "_2e _yw", "lgCol2": "_2f _yx", "lgCol3": "_2g _yy", "lgCol4": "_2h _yz", "lgCol5": "_2i _z0", "lgCol6": "_2j _z1", "lgCol7": "_2k _z2", "lgCol8": "_2l _z3", "lgCol9": "_2m _z4", "lgCol10": "_2n _z5", "lgCol11": "_2o _z6", "lgCol12": "_2p _z7" };

  var borders = { "border": "_2q", "borderTop": "_2r", "borderRight": "_2s", "borderBottom": "_2t", "borderLeft": "_2u", "square": "_2v", "circle": "_2w", "pill": "_2x", "rounded": "_2y", "roundedTop": "_2z", "roundedRight": "_30", "roundedBottom": "_31", "roundedLeft": "_32", "noBorder": "_33" };

  var colors = { "red": "_34", "redBg": "_35", "white": "_36", "whiteBg": "_37", "lightGray": "_38", "lightGrayBg": "_39", "gray": "_3a", "grayBg": "_3b", "darkGray": "_3c", "darkGrayBg": "_3d", "green": "_3e", "greenBg": "_3f", "pine": "_3g", "pineBg": "_3h", "olive": "_3i", "oliveBg": "_3j", "blue": "_3k", "blueBg": "_3l", "navy": "_3m", "navyBg": "_3n", "midnight": "_3o", "midnightBg": "_3p", "purple": "_3q", "purpleBg": "_3r", "orchid": "_3s", "orchidBg": "_3t", "eggplant": "_3u", "eggplantBg": "_3v", "maroon": "_3w", "maroonBg": "_3x", "watermelon": "_3y", "watermelonBg": "_3z", "orange": "_40", "orangeBg": "_41", "transparentBg": "_42", "lightWashBg": "_43", "darkWashBg": "_44" };

  var layout = { "block": "_45", "inline": "_46", "inlineBlock": "_47", "table": "_48", "overflowHidden": "_49", "overflowScroll": "_4a", "overflowScrollX": "_4b", "overflowScrollY": "_4c", "overflowAuto": "_4d", "fit": "_4e", "relative": "_4f", "fixed": "_4g", "absolute": "_4h", "sticky": "_4i", "top0": "_4j", "right0": "_4k", "bottom0": "_4l", "left0": "_4m", "small": "_4n", "medium": "_4o", "large": "_4p", "borderBox": "_4q", "contentBox": "_4r", "-webkit-box-flex": "_4s", "-webkit-flex": "_4s", "-ms-flex": "_4s", "flex": "_4s", "smFlex": "_4t", "mdFlex": "_4u", "lgFlex": "_4v", "flexColumn": "_4w", "flexWrap": "_4x", "itemsStart": "_4y", "itemsEnd": "_4z", "itemsCenter": "_50", "itemsBaseline": "_51", "itemsStretch": "_52", "selfStart": "_53", "selfEnd": "_54", "selfCenter": "_55", "selfBaseline": "_56", "selfStretch": "_57", "justifyStart": "_58", "justifyEnd": "_59", "justifyCenter": "_5a", "justifyBetween": "_5b", "justifyAround": "_5c", "contentStart": "_5d", "contentEnd": "_5e", "contentCenter": "_5f", "contentBetween": "_5g", "contentAround": "_5h", "contentStretch": "_5i", "flexGrow": "_5j", "flexNone": "_5k", "orderFirst": "_5l", "orderLast": "_5m" };

  var whitespace = { "marginStart1": "_5n", "marginEnd1": "_5o", "marginStartN1": "_5p", "marginEndN1": "_5q", "marginTop1": "_5r", "marginRight1": "_5s", "marginBottom1": "_5t", "marginLeft1": "_5u", "marginTopN1": "_5v", "marginRightN1": "_5w", "marginBottomN1": "_5x", "marginLeftN1": "_5y", "paddingY1": "_5z", "paddingX1": "_60", "marginStart2": "_61", "marginEnd2": "_62", "marginStartN2": "_63", "marginEndN2": "_64", "marginTop2": "_65", "marginRight2": "_66", "marginBottom2": "_67", "marginLeft2": "_68", "marginTopN2": "_69", "marginRightN2": "_6a", "marginBottomN2": "_6b", "marginLeftN2": "_6c", "paddingY2": "_6d", "paddingX2": "_6e", "marginStart3": "_6f", "marginEnd3": "_6g", "marginStartN3": "_6h", "marginEndN3": "_6i", "marginTop3": "_6j", "marginRight3": "_6k", "marginBottom3": "_6l", "marginLeft3": "_6m", "marginTopN3": "_6n", "marginRightN3": "_6o", "marginBottomN3": "_6p", "marginLeftN3": "_6q", "paddingY3": "_6r", "paddingX3": "_6s", "marginStart4": "_6t", "marginEnd4": "_6u", "marginStartN4": "_6v", "marginEndN4": "_6w", "marginTop4": "_6x", "marginRight4": "_6y", "marginBottom4": "_6z", "marginLeft4": "_70", "marginTopN4": "_71", "marginRightN4": "_72", "marginBottomN4": "_73", "marginLeftN4": "_74", "paddingY4": "_75", "paddingX4": "_76", "marginStart5": "_77", "marginEnd5": "_78", "marginStartN5": "_79", "marginEndN5": "_7a", "marginTop5": "_7b", "marginRight5": "_7c", "marginBottom5": "_7d", "marginLeft5": "_7e", "marginTopN5": "_7f", "marginRightN5": "_7g", "marginBottomN5": "_7h", "marginLeftN5": "_7i", "paddingY5": "_7j", "paddingX5": "_7k", "marginStart6": "_7l", "marginEnd6": "_7m", "marginStartN6": "_7n", "marginEndN6": "_7o", "marginTop6": "_7p", "marginRight6": "_7q", "marginBottom6": "_7r", "marginLeft6": "_7s", "marginTopN6": "_7t", "marginRightN6": "_7u", "marginBottomN6": "_7v", "marginLeftN6": "_7w", "paddingY6": "_7x", "paddingX6": "_7y", "marginStart7": "_7z", "marginEnd7": "_80", "marginStartN7": "_81", "marginEndN7": "_82", "marginTop7": "_83", "marginRight7": "_84", "marginBottom7": "_85", "marginLeft7": "_86", "marginTopN7": "_87", "marginRightN7": "_88", "marginBottomN7": "_89", "marginLeftN7": "_8a", "paddingY7": "_8b", "paddingX7": "_8c", "marginStart8": "_8d", "marginEnd8": "_8e", "marginStartN8": "_8f", "marginEndN8": "_8g", "marginTop8": "_8h", "marginRight8": "_8i", "marginBottom8": "_8j", "marginLeft8": "_8k", "marginTopN8": "_8l", "marginRightN8": "_8m", "marginBottomN8": "_8n", "marginLeftN8": "_8o", "paddingY8": "_8p", "paddingX8": "_8q", "marginStart9": "_8r", "marginEnd9": "_8s", "marginStartN9": "_8t", "marginEndN9": "_8u", "marginTop9": "_8v", "marginRight9": "_8w", "marginBottom9": "_8x", "marginLeft9": "_8y", "marginTopN9": "_8z", "marginRightN9": "_90", "marginBottomN9": "_91", "marginLeftN9": "_92", "paddingY9": "_93", "paddingX9": "_94", "marginStart10": "_95", "marginEnd10": "_96", "marginStartN10": "_97", "marginEndN10": "_98", "marginTop10": "_99", "marginRight10": "_9a", "marginBottom10": "_9b", "marginLeft10": "_9c", "marginTopN10": "_9d", "marginRightN10": "_9e", "marginBottomN10": "_9f", "marginLeftN10": "_9g", "paddingY10": "_9h", "paddingX10": "_9i", "marginStart11": "_9j", "marginEnd11": "_9k", "marginStartN11": "_9l", "marginEndN11": "_9m", "marginTop11": "_9n", "marginRight11": "_9o", "marginBottom11": "_9p", "marginLeft11": "_9q", "marginTopN11": "_9r", "marginRightN11": "_9s", "marginBottomN11": "_9t", "marginLeftN11": "_9u", "paddingY11": "_9v", "paddingX11": "_9w", "marginStart12": "_9x", "marginEnd12": "_9y", "marginStartN12": "_9z", "marginEndN12": "_a0", "marginTop12": "_a1", "marginRight12": "_a2", "marginBottom12": "_a3", "marginLeft12": "_a4", "marginTopN12": "_a5", "marginRightN12": "_a6", "marginBottomN12": "_a7", "marginLeftN12": "_a8", "paddingY12": "_a9", "paddingX12": "_aa", "smMarginStart1": "_ab", "smMarginEnd1": "_ac", "smMarginStartN1": "_ad", "smMarginEndN1": "_ae", "smMarginTop1": "_af", "smMarginRight1": "_ag", "smMarginBottom1": "_ah", "smMarginLeft1": "_ai", "smMarginTopN1": "_aj", "smMarginRightN1": "_ak", "smMarginBottomN1": "_al", "smMarginLeftN1": "_am", "smPaddingY1": "_an", "smPaddingX1": "_ao", "smMarginStart2": "_ap", "smMarginEnd2": "_aq", "smMarginStartN2": "_ar", "smMarginEndN2": "_as", "smMarginTop2": "_at", "smMarginRight2": "_au", "smMarginBottom2": "_av", "smMarginLeft2": "_aw", "smMarginTopN2": "_ax", "smMarginRightN2": "_ay", "smMarginBottomN2": "_az", "smMarginLeftN2": "_b0", "smPaddingY2": "_b1", "smPaddingX2": "_b2", "smMarginStart3": "_b3", "smMarginEnd3": "_b4", "smMarginStartN3": "_b5", "smMarginEndN3": "_b6", "smMarginTop3": "_b7", "smMarginRight3": "_b8", "smMarginBottom3": "_b9", "smMarginLeft3": "_ba", "smMarginTopN3": "_bb", "smMarginRightN3": "_bc", "smMarginBottomN3": "_bd", "smMarginLeftN3": "_be", "smPaddingY3": "_bf", "smPaddingX3": "_bg", "smMarginStart4": "_bh", "smMarginEnd4": "_bi", "smMarginStartN4": "_bj", "smMarginEndN4": "_bk", "smMarginTop4": "_bl", "smMarginRight4": "_bm", "smMarginBottom4": "_bn", "smMarginLeft4": "_bo", "smMarginTopN4": "_bp", "smMarginRightN4": "_bq", "smMarginBottomN4": "_br", "smMarginLeftN4": "_bs", "smPaddingY4": "_bt", "smPaddingX4": "_bu", "smMarginStart5": "_bv", "smMarginEnd5": "_bw", "smMarginStartN5": "_bx", "smMarginEndN5": "_by", "smMarginTop5": "_bz", "smMarginRight5": "_c0", "smMarginBottom5": "_c1", "smMarginLeft5": "_c2", "smMarginTopN5": "_c3", "smMarginRightN5": "_c4", "smMarginBottomN5": "_c5", "smMarginLeftN5": "_c6", "smPaddingY5": "_c7", "smPaddingX5": "_c8", "smMarginStart6": "_c9", "smMarginEnd6": "_ca", "smMarginStartN6": "_cb", "smMarginEndN6": "_cc", "smMarginTop6": "_cd", "smMarginRight6": "_ce", "smMarginBottom6": "_cf", "smMarginLeft6": "_cg", "smMarginTopN6": "_ch", "smMarginRightN6": "_ci", "smMarginBottomN6": "_cj", "smMarginLeftN6": "_ck", "smPaddingY6": "_cl", "smPaddingX6": "_cm", "smMarginStart7": "_cn", "smMarginEnd7": "_co", "smMarginStartN7": "_cp", "smMarginEndN7": "_cq", "smMarginTop7": "_cr", "smMarginRight7": "_cs", "smMarginBottom7": "_ct", "smMarginLeft7": "_cu", "smMarginTopN7": "_cv", "smMarginRightN7": "_cw", "smMarginBottomN7": "_cx", "smMarginLeftN7": "_cy", "smPaddingY7": "_cz", "smPaddingX7": "_d0", "smMarginStart8": "_d1", "smMarginEnd8": "_d2", "smMarginStartN8": "_d3", "smMarginEndN8": "_d4", "smMarginTop8": "_d5", "smMarginRight8": "_d6", "smMarginBottom8": "_d7", "smMarginLeft8": "_d8", "smMarginTopN8": "_d9", "smMarginRightN8": "_da", "smMarginBottomN8": "_db", "smMarginLeftN8": "_dc", "smPaddingY8": "_dd", "smPaddingX8": "_de", "smMarginStart9": "_df", "smMarginEnd9": "_dg", "smMarginStartN9": "_dh", "smMarginEndN9": "_di", "smMarginTop9": "_dj", "smMarginRight9": "_dk", "smMarginBottom9": "_dl", "smMarginLeft9": "_dm", "smMarginTopN9": "_dn", "smMarginRightN9": "_do", "smMarginBottomN9": "_dp", "smMarginLeftN9": "_dq", "smPaddingY9": "_dr", "smPaddingX9": "_ds", "smMarginStart10": "_dt", "smMarginEnd10": "_du", "smMarginStartN10": "_dv", "smMarginEndN10": "_dw", "smMarginTop10": "_dx", "smMarginRight10": "_dy", "smMarginBottom10": "_dz", "smMarginLeft10": "_e0", "smMarginTopN10": "_e1", "smMarginRightN10": "_e2", "smMarginBottomN10": "_e3", "smMarginLeftN10": "_e4", "smPaddingY10": "_e5", "smPaddingX10": "_e6", "smMarginStart11": "_e7", "smMarginEnd11": "_e8", "smMarginStartN11": "_e9", "smMarginEndN11": "_ea", "smMarginTop11": "_eb", "smMarginRight11": "_ec", "smMarginBottom11": "_ed", "smMarginLeft11": "_ee", "smMarginTopN11": "_ef", "smMarginRightN11": "_eg", "smMarginBottomN11": "_eh", "smMarginLeftN11": "_ei", "smPaddingY11": "_ej", "smPaddingX11": "_ek", "smMarginStart12": "_el", "smMarginEnd12": "_em", "smMarginStartN12": "_en", "smMarginEndN12": "_eo", "smMarginTop12": "_ep", "smMarginRight12": "_eq", "smMarginBottom12": "_er", "smMarginLeft12": "_es", "smMarginTopN12": "_et", "smMarginRightN12": "_eu", "smMarginBottomN12": "_ev", "smMarginLeftN12": "_ew", "smPaddingY12": "_ex", "smPaddingX12": "_ey", "mdMarginStart1": "_ez", "mdMarginEnd1": "_f0", "mdMarginStartN1": "_f1", "mdMarginEndN1": "_f2", "mdMarginTop1": "_f3", "mdMarginRight1": "_f4", "mdMarginBottom1": "_f5", "mdMarginLeft1": "_f6", "mdMarginTopN1": "_f7", "mdMarginRightN1": "_f8", "mdMarginBottomN1": "_f9", "mdMarginLeftN1": "_fa", "mdPaddingY1": "_fb", "mdPaddingX1": "_fc", "mdMarginStart2": "_fd", "mdMarginEnd2": "_fe", "mdMarginStartN2": "_ff", "mdMarginEndN2": "_fg", "mdMarginTop2": "_fh", "mdMarginRight2": "_fi", "mdMarginBottom2": "_fj", "mdMarginLeft2": "_fk", "mdMarginTopN2": "_fl", "mdMarginRightN2": "_fm", "mdMarginBottomN2": "_fn", "mdMarginLeftN2": "_fo", "mdPaddingY2": "_fp", "mdPaddingX2": "_fq", "mdMarginStart3": "_fr", "mdMarginEnd3": "_fs", "mdMarginStartN3": "_ft", "mdMarginEndN3": "_fu", "mdMarginTop3": "_fv", "mdMarginRight3": "_fw", "mdMarginBottom3": "_fx", "mdMarginLeft3": "_fy", "mdMarginTopN3": "_fz", "mdMarginRightN3": "_g0", "mdMarginBottomN3": "_g1", "mdMarginLeftN3": "_g2", "mdPaddingY3": "_g3", "mdPaddingX3": "_g4", "mdMarginStart4": "_g5", "mdMarginEnd4": "_g6", "mdMarginStartN4": "_g7", "mdMarginEndN4": "_g8", "mdMarginTop4": "_g9", "mdMarginRight4": "_ga", "mdMarginBottom4": "_gb", "mdMarginLeft4": "_gc", "mdMarginTopN4": "_gd", "mdMarginRightN4": "_ge", "mdMarginBottomN4": "_gf", "mdMarginLeftN4": "_gg", "mdPaddingY4": "_gh", "mdPaddingX4": "_gi", "mdMarginStart5": "_gj", "mdMarginEnd5": "_gk", "mdMarginStartN5": "_gl", "mdMarginEndN5": "_gm", "mdMarginTop5": "_gn", "mdMarginRight5": "_go", "mdMarginBottom5": "_gp", "mdMarginLeft5": "_gq", "mdMarginTopN5": "_gr", "mdMarginRightN5": "_gs", "mdMarginBottomN5": "_gt", "mdMarginLeftN5": "_gu", "mdPaddingY5": "_gv", "mdPaddingX5": "_gw", "mdMarginStart6": "_gx", "mdMarginEnd6": "_gy", "mdMarginStartN6": "_gz", "mdMarginEndN6": "_h0", "mdMarginTop6": "_h1", "mdMarginRight6": "_h2", "mdMarginBottom6": "_h3", "mdMarginLeft6": "_h4", "mdMarginTopN6": "_h5", "mdMarginRightN6": "_h6", "mdMarginBottomN6": "_h7", "mdMarginLeftN6": "_h8", "mdPaddingY6": "_h9", "mdPaddingX6": "_ha", "mdMarginStart7": "_hb", "mdMarginEnd7": "_hc", "mdMarginStartN7": "_hd", "mdMarginEndN7": "_he", "mdMarginTop7": "_hf", "mdMarginRight7": "_hg", "mdMarginBottom7": "_hh", "mdMarginLeft7": "_hi", "mdMarginTopN7": "_hj", "mdMarginRightN7": "_hk", "mdMarginBottomN7": "_hl", "mdMarginLeftN7": "_hm", "mdPaddingY7": "_hn", "mdPaddingX7": "_ho", "mdMarginStart8": "_hp", "mdMarginEnd8": "_hq", "mdMarginStartN8": "_hr", "mdMarginEndN8": "_hs", "mdMarginTop8": "_ht", "mdMarginRight8": "_hu", "mdMarginBottom8": "_hv", "mdMarginLeft8": "_hw", "mdMarginTopN8": "_hx", "mdMarginRightN8": "_hy", "mdMarginBottomN8": "_hz", "mdMarginLeftN8": "_i0", "mdPaddingY8": "_i1", "mdPaddingX8": "_i2", "mdMarginStart9": "_i3", "mdMarginEnd9": "_i4", "mdMarginStartN9": "_i5", "mdMarginEndN9": "_i6", "mdMarginTop9": "_i7", "mdMarginRight9": "_i8", "mdMarginBottom9": "_i9", "mdMarginLeft9": "_ia", "mdMarginTopN9": "_ib", "mdMarginRightN9": "_ic", "mdMarginBottomN9": "_id", "mdMarginLeftN9": "_ie", "mdPaddingY9": "_if", "mdPaddingX9": "_ig", "mdMarginStart10": "_ih", "mdMarginEnd10": "_ii", "mdMarginStartN10": "_ij", "mdMarginEndN10": "_ik", "mdMarginTop10": "_il", "mdMarginRight10": "_im", "mdMarginBottom10": "_in", "mdMarginLeft10": "_io", "mdMarginTopN10": "_ip", "mdMarginRightN10": "_iq", "mdMarginBottomN10": "_ir", "mdMarginLeftN10": "_is", "mdPaddingY10": "_it", "mdPaddingX10": "_iu", "mdMarginStart11": "_iv", "mdMarginEnd11": "_iw", "mdMarginStartN11": "_ix", "mdMarginEndN11": "_iy", "mdMarginTop11": "_iz", "mdMarginRight11": "_j0", "mdMarginBottom11": "_j1", "mdMarginLeft11": "_j2", "mdMarginTopN11": "_j3", "mdMarginRightN11": "_j4", "mdMarginBottomN11": "_j5", "mdMarginLeftN11": "_j6", "mdPaddingY11": "_j7", "mdPaddingX11": "_j8", "mdMarginStart12": "_j9", "mdMarginEnd12": "_ja", "mdMarginStartN12": "_jb", "mdMarginEndN12": "_jc", "mdMarginTop12": "_jd", "mdMarginRight12": "_je", "mdMarginBottom12": "_jf", "mdMarginLeft12": "_jg", "mdMarginTopN12": "_jh", "mdMarginRightN12": "_ji", "mdMarginBottomN12": "_jj", "mdMarginLeftN12": "_jk", "mdPaddingY12": "_jl", "mdPaddingX12": "_jm", "lgMarginStart1": "_jn", "lgMarginEnd1": "_jo", "lgMarginStartN1": "_jp", "lgMarginEndN1": "_jq", "lgMarginTop1": "_jr", "lgMarginRight1": "_js", "lgMarginBottom1": "_jt", "lgMarginLeft1": "_ju", "lgMarginTopN1": "_jv", "lgMarginRightN1": "_jw", "lgMarginBottomN1": "_jx", "lgMarginLeftN1": "_jy", "lgPaddingY1": "_jz", "lgPaddingX1": "_k0", "lgMarginStart2": "_k1", "lgMarginEnd2": "_k2", "lgMarginStartN2": "_k3", "lgMarginEndN2": "_k4", "lgMarginTop2": "_k5", "lgMarginRight2": "_k6", "lgMarginBottom2": "_k7", "lgMarginLeft2": "_k8", "lgMarginTopN2": "_k9", "lgMarginRightN2": "_ka", "lgMarginBottomN2": "_kb", "lgMarginLeftN2": "_kc", "lgPaddingY2": "_kd", "lgPaddingX2": "_ke", "lgMarginStart3": "_kf", "lgMarginEnd3": "_kg", "lgMarginStartN3": "_kh", "lgMarginEndN3": "_ki", "lgMarginTop3": "_kj", "lgMarginRight3": "_kk", "lgMarginBottom3": "_kl", "lgMarginLeft3": "_km", "lgMarginTopN3": "_kn", "lgMarginRightN3": "_ko", "lgMarginBottomN3": "_kp", "lgMarginLeftN3": "_kq", "lgPaddingY3": "_kr", "lgPaddingX3": "_ks", "lgMarginStart4": "_kt", "lgMarginEnd4": "_ku", "lgMarginStartN4": "_kv", "lgMarginEndN4": "_kw", "lgMarginTop4": "_kx", "lgMarginRight4": "_ky", "lgMarginBottom4": "_kz", "lgMarginLeft4": "_l0", "lgMarginTopN4": "_l1", "lgMarginRightN4": "_l2", "lgMarginBottomN4": "_l3", "lgMarginLeftN4": "_l4", "lgPaddingY4": "_l5", "lgPaddingX4": "_l6", "lgMarginStart5": "_l7", "lgMarginEnd5": "_l8", "lgMarginStartN5": "_l9", "lgMarginEndN5": "_la", "lgMarginTop5": "_lb", "lgMarginRight5": "_lc", "lgMarginBottom5": "_ld", "lgMarginLeft5": "_le", "lgMarginTopN5": "_lf", "lgMarginRightN5": "_lg", "lgMarginBottomN5": "_lh", "lgMarginLeftN5": "_li", "lgPaddingY5": "_lj", "lgPaddingX5": "_lk", "lgMarginStart6": "_ll", "lgMarginEnd6": "_lm", "lgMarginStartN6": "_ln", "lgMarginEndN6": "_lo", "lgMarginTop6": "_lp", "lgMarginRight6": "_lq", "lgMarginBottom6": "_lr", "lgMarginLeft6": "_ls", "lgMarginTopN6": "_lt", "lgMarginRightN6": "_lu", "lgMarginBottomN6": "_lv", "lgMarginLeftN6": "_lw", "lgPaddingY6": "_lx", "lgPaddingX6": "_ly", "lgMarginStart7": "_lz", "lgMarginEnd7": "_m0", "lgMarginStartN7": "_m1", "lgMarginEndN7": "_m2", "lgMarginTop7": "_m3", "lgMarginRight7": "_m4", "lgMarginBottom7": "_m5", "lgMarginLeft7": "_m6", "lgMarginTopN7": "_m7", "lgMarginRightN7": "_m8", "lgMarginBottomN7": "_m9", "lgMarginLeftN7": "_ma", "lgPaddingY7": "_mb", "lgPaddingX7": "_mc", "lgMarginStart8": "_md", "lgMarginEnd8": "_me", "lgMarginStartN8": "_mf", "lgMarginEndN8": "_mg", "lgMarginTop8": "_mh", "lgMarginRight8": "_mi", "lgMarginBottom8": "_mj", "lgMarginLeft8": "_mk", "lgMarginTopN8": "_ml", "lgMarginRightN8": "_mm", "lgMarginBottomN8": "_mn", "lgMarginLeftN8": "_mo", "lgPaddingY8": "_mp", "lgPaddingX8": "_mq", "lgMarginStart9": "_mr", "lgMarginEnd9": "_ms", "lgMarginStartN9": "_mt", "lgMarginEndN9": "_mu", "lgMarginTop9": "_mv", "lgMarginRight9": "_mw", "lgMarginBottom9": "_mx", "lgMarginLeft9": "_my", "lgMarginTopN9": "_mz", "lgMarginRightN9": "_n0", "lgMarginBottomN9": "_n1", "lgMarginLeftN9": "_n2", "lgPaddingY9": "_n3", "lgPaddingX9": "_n4", "lgMarginStart10": "_n5", "lgMarginEnd10": "_n6", "lgMarginStartN10": "_n7", "lgMarginEndN10": "_n8", "lgMarginTop10": "_n9", "lgMarginRight10": "_na", "lgMarginBottom10": "_nb", "lgMarginLeft10": "_nc", "lgMarginTopN10": "_nd", "lgMarginRightN10": "_ne", "lgMarginBottomN10": "_nf", "lgMarginLeftN10": "_ng", "lgPaddingY10": "_nh", "lgPaddingX10": "_ni", "lgMarginStart11": "_nj", "lgMarginEnd11": "_nk", "lgMarginStartN11": "_nl", "lgMarginEndN11": "_nm", "lgMarginTop11": "_nn", "lgMarginRight11": "_no", "lgMarginBottom11": "_np", "lgMarginLeft11": "_nq", "lgMarginTopN11": "_nr", "lgMarginRightN11": "_ns", "lgMarginBottomN11": "_nt", "lgMarginLeftN11": "_nu", "lgPaddingY11": "_nv", "lgPaddingX11": "_nw", "lgMarginStart12": "_nx", "lgMarginEnd12": "_ny", "lgMarginStartN12": "_nz", "lgMarginEndN12": "_o0", "lgMarginTop12": "_o1", "lgMarginRight12": "_o2", "lgMarginBottom12": "_o3", "lgMarginLeft12": "_o4", "lgMarginTopN12": "_o5", "lgMarginRightN12": "_o6", "lgMarginBottomN12": "_o7", "lgMarginLeftN12": "_o8", "lgPaddingY12": "_o9", "lgPaddingX12": "_oa" };

  var whitespaceLegacy = { "mlAuto": "_ob", "mrAuto": "_oc", "m0": "_od", "mt0": "_oe", "mr0": "_of", "mb0": "_og", "ml0": "_oh", "p0": "_oi", "px0": "_oj", "py0": "_ok", "m1": "_ol", "mt1": "_om", "mr1": "_on", "mb1": "_oo", "ml1": "_op", "mn1": "_oq", "mtn1": "_or", "mbn1": "_os", "mln1": "_ot", "mrn1": "_ou", "mxn1": "_ov", "myn1": "_ow", "p1": "_ox", "px1": "_oy", "py1": "_oz", "m2": "_p0", "mt2": "_p1", "mr2": "_p2", "mb2": "_p3", "ml2": "_p4", "mn2": "_p5", "mtn2": "_p6", "mbn2": "_p7", "mln2": "_p8", "mrn2": "_p9", "mxn2": "_pa", "myn2": "_pb", "p2": "_pc", "px2": "_pd", "py2": "_pe", "m3": "_pf", "mt3": "_pg", "mr3": "_ph", "mb3": "_pi", "ml3": "_pj", "mn3": "_pk", "mtn3": "_pl", "mbn3": "_pm", "mln3": "_pn", "mrn3": "_po", "mxn3": "_pp", "myn3": "_pq", "p3": "_pr", "px3": "_ps", "py3": "_pt", "m4": "_pu", "mt4": "_pv", "mr4": "_pw", "mb4": "_px", "ml4": "_py", "mn4": "_pz", "mtn4": "_q0", "mbn4": "_q1", "mln4": "_q2", "mrn4": "_q3", "mxn4": "_q4", "myn4": "_q5", "p4": "_q6", "px4": "_q7", "py4": "_q8", "m5": "_q9", "mt5": "_qa", "mr5": "_qb", "mb5": "_qc", "ml5": "_qd", "mn5": "_qe", "mtn5": "_qf", "mbn5": "_qg", "mln5": "_qh", "mrn5": "_qi", "mxn5": "_qj", "myn5": "_qk", "p5": "_ql", "px5": "_qm", "py5": "_qn", "m6": "_qo", "mt6": "_qp", "mr6": "_qq", "mb6": "_qr", "ml6": "_qs", "mn6": "_qt", "mtn6": "_qu", "mbn6": "_qv", "mln6": "_qw", "mrn6": "_qx", "mxn6": "_qy", "myn6": "_qz", "p6": "_r0", "px6": "_r1", "py6": "_r2" };

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var objectWithoutProperties = function (obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  /*

  Style is a monoid that capture the "to-be-applied" styles (inline and classes)
  for a Box. It's basically set that is closed under an associative binary
  operation and has an identity element such that for all HA HA HA. Yes, it's a
  monoid, which sounds scary but it's not really and actually super useful. All
  that means is that basically you can do two things with it:

      1. concat(concat(a, b), c) === concat(a, concat(b, c));
      2. concat(identity(), a) === concat(a, identity()) === a;

  What that means is that it's really easy to compose styles together and the
  order in which you do so doesn't really matter.

  */

  var identity = function identity() {
    return {
      className: new Set(),
      inlineStyle: {}
    };
  };

  // TODO: This type should be opaque, however the Babel parser doesn't support
  //       the opaque syntax yet.


  var fromClassName = function fromClassName() {
    for (var _len = arguments.length, classNames = Array(_len), _key = 0; _key < _len; _key++) {
      classNames[_key] = arguments[_key];
    }

    return {
      className: new Set(classNames),
      inlineStyle: {}
    };
  };

  var fromInlineStyle = function fromInlineStyle(inlineStyle) {
    return {
      className: new Set(),
      inlineStyle: inlineStyle
    };
  };

  var concat = function concat(styles) {
    return styles.reduce(function (_ref, _ref2) {
      var classNameA = _ref.className,
          inlineStyleA = _ref.inlineStyle;
      var classNameB = _ref2.className,
          inlineStyleB = _ref2.inlineStyle;
      return {
        className: new Set([].concat(toConsumableArray(classNameA), toConsumableArray(classNameB))),
        inlineStyle: _extends({}, inlineStyleA, inlineStyleB)
      };
    }, identity());
  };

  var mapClassName = function mapClassName(fn) {
    return function (_ref3) {
      var className = _ref3.className,
          inlineStyle = _ref3.inlineStyle;
      return {
        className: new Set(Array.from(className).map(fn)),
        inlineStyle: inlineStyle
      };
    };
  };

  var toProps = function toProps(_ref4) {
    var className = _ref4.className,
        inlineStyle = _ref4.inlineStyle;

    var props = {};

    if (className.size > 0) {
      // Sorting here ensures that classNames are always stable, reducing diff
      // churn. Box usually has a small number of properties so it's not a perf
      // concern.
      props.className = Array.from(className).sort().join(' ');
    }

    if (Object.keys(inlineStyle).length > 0) {
      props.style = inlineStyle;
    }

    return props;
  };

  /*

  Transforms

  These are a collection of a few functors that take values and returns Style's. OMG, I used the word functor - it's really just a fancy word for function.

  */

  // Adds a classname when a property is present.
  //
  //     <Box top />
  //
  var toggle = function toggle() {
    for (var _len = arguments.length, classNames = Array(_len), _key = 0; _key < _len; _key++) {
      classNames[_key] = arguments[_key];
    }

    return function (val) {
      return val ? fromClassName.apply(undefined, classNames) : identity();
    };
  };

  // Maps string values to classes
  //
  //     <Box alignItems="center" />
  //
  var mapping = function mapping(map) {
    return function (val) {
      return Object.prototype.hasOwnProperty.call(map, val) ? fromClassName(map[val]) : identity();
    };
  };

  // Maps a range of integers to a range of classnames
  //
  //     <Box padding={1} />
  //
  var range = function range(scale) {
    return function (n) {
      return fromClassName('' + scale + (n < 0 ? 'N' + Math.abs(n) : n));
    };
  };

  // Like `range`, maps a range of integers to a range of classnames, excluding
  // zero values.
  //
  //     <Box padding={0} />
  var rangeWithoutZero = function rangeWithoutZero(scale) {
    return function (n) {
      return n === 0 ? identity() : range(scale)(n);
    };
  };

  // Binds a string classname to the value in an object. Useful when interacting
  // with ranges that need to come dynamically from a style object. This is
  // similar to the NPM package 'classnames/bind'.
  var bind = function bind(fn, scope) {
    return function (val) {
      return mapClassName(function (name) {
        return scope[name];
      })(fn(val));
    };
  };

  // This takes a series of the previously defined functors, runs them all
  // against a value and returns the set of their classnames.
  var union = function union() {
    for (var _len2 = arguments.length, fns = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      fns[_key2] = arguments[_key2];
    }

    return function (val) {
      return concat(fns.map(function (fn) {
        return fn(val);
      }));
    };
  };

  /*

  # ProTypes

  Box's type definition is exhaustive. With the exception of `dangerouslySetInlineStyle`, values shouldn't be ambigious. That means that we have to type out things like boints, but that's also where Box's magic lies. Also, by putting in extra effort around type definitions here, we can skip extra runtime typechecks in the transformers for performance.

  */

  // --

  /*

  # Transformers

  This is where the meat and the bones of Box's transforms are. You can read more about the DSL in `./transforms.js`, but basically they are a small declarative way of specifying how a property (i.e. `marginTop={4}`) gets turned into a CSS class (`marginTop4`).

  There's a little preamble here, but it culminates in a big object mapping the actual property names to the transformer values.

  */

  var marginStart = bind(rangeWithoutZero('marginStart'), whitespace);
  var marginEnd = bind(rangeWithoutZero('marginEnd'), whitespace);
  var marginTop = bind(rangeWithoutZero('marginTop'), whitespace);
  var marginRight = bind(rangeWithoutZero('marginRight'), whitespace);
  var marginBottom = bind(rangeWithoutZero('marginBottom'), whitespace);
  var marginLeft = bind(rangeWithoutZero('marginLeft'), whitespace);
  var margin = union(marginTop, marginBottom, marginLeft, marginRight);

  var smMarginTop = bind(rangeWithoutZero('smMarginTop'), whitespace);
  var smMarginRight = bind(rangeWithoutZero('smMarginRight'), whitespace);
  var smMarginBottom = bind(rangeWithoutZero('smMarginBottom'), whitespace);
  var smMarginLeft = bind(rangeWithoutZero('smMarginLeft'), whitespace);
  var smMargin = union(smMarginTop, smMarginBottom, smMarginLeft, smMarginRight);

  var mdMarginTop = bind(rangeWithoutZero('mdMarginTop'), whitespace);
  var mdMarginRight = bind(rangeWithoutZero('mdMarginRight'), whitespace);
  var mdMarginBottom = bind(rangeWithoutZero('mdMarginBottom'), whitespace);
  var mdMarginLeft = bind(rangeWithoutZero('mdMarginLeft'), whitespace);
  var mdMargin = union(mdMarginTop, mdMarginBottom, mdMarginLeft, mdMarginRight);

  var lgMarginTop = bind(rangeWithoutZero('lgMarginTop'), whitespace);
  var lgMarginRight = bind(rangeWithoutZero('lgMarginRight'), whitespace);
  var lgMarginBottom = bind(rangeWithoutZero('lgMarginBottom'), whitespace);
  var lgMarginLeft = bind(rangeWithoutZero('lgMarginLeft'), whitespace);
  var lgMargin = union(lgMarginTop, lgMarginBottom, lgMarginLeft, lgMarginRight);

  var paddingX = bind(rangeWithoutZero('paddingX'), whitespace);
  var paddingY = bind(rangeWithoutZero('paddingY'), whitespace);
  var padding = union(paddingX, paddingY);

  var smPaddingX = bind(rangeWithoutZero('smPaddingX'), whitespace);
  var smPaddingY = bind(rangeWithoutZero('smPaddingY'), whitespace);
  var smPadding = union(smPaddingX, smPaddingY);

  var mdPaddingX = bind(rangeWithoutZero('mdPaddingX'), whitespace);
  var mdPaddingY = bind(rangeWithoutZero('mdPaddingY'), whitespace);
  var mdPadding = union(mdPaddingX, mdPaddingY);

  var lgPaddingX = bind(rangeWithoutZero('lgPaddingX'), whitespace);
  var lgPaddingY = bind(rangeWithoutZero('lgPaddingY'), whitespace);
  var lgPadding = union(lgPaddingX, lgPaddingY);

  /*

  These functions are legacy. I'd like to get rid of most of this file's dependency on importing `./style.js` directly once these are removed.

  */

  var prefix = function prefix(pre) {
    return mapClassName(function (name) {
      return '' + pre + name;
    });
  };
  var display = function display(value) {
    switch (value) {
      case 'flex':
        return fromClassName('DisplayFlex', 'DirectionRow');
      case 'flexColumn':
        return fromClassName('DisplayFlex', 'DirectionColumn');
      case 'inlineBlock':
        return fromClassName('DisplayInlineBlock');
      case 'visuallyHidden':
        return fromClassName('DisplayVisuallyHidden');
      case false:
        return fromClassName('DisplayNone');
      default:
        /* block */
        return fromClassName('DisplayBlock');
    }
  };
  var column = range('Col');

  var formatIntBoint = function formatIntBoint(x) {
    return x < 0 ? 'n' + Math.abs(x) : x.toString();
  };

  /*

  It's preferable to put new properties into that object directly just so it's easier to read.

  */

  var propToFn = {
    xs: function xs(value) {
      if (!value) {
        return identity();
      }
      return mapClassName(function (c) {
        return styles[c];
      })(prefix('xs')(concat([value.column ? column(value.column) : identity(), typeof value.display !== 'undefined' ? display(value.display) : identity()])));
    },
    sm: function sm(value) {
      if (!value) {
        return identity();
      }
      return mapClassName(function (c) {
        return styles[c];
      })(prefix('sm')(concat([value.column ? column(value.column) : identity(), typeof value.display !== 'undefined' ? display(value.display) : identity()])));
    },
    md: function md(value) {
      if (!value) {
        return identity();
      }
      return mapClassName(function (c) {
        return styles[c];
      })(prefix('md')(concat([value.column ? column(value.column) : identity(), typeof value.display !== 'undefined' ? display(value.display) : identity()])));
    },
    lg: function lg(value) {
      if (!value) {
        return identity();
      }
      return mapClassName(function (c) {
        return styles[c];
      })(prefix('lg')(concat([value.column ? column(value.column) : identity(), typeof value.display !== 'undefined' ? display(value.display) : identity()])));
    },

    display: mapping({
      none: styles.xsDisplayNone,
      flex: styles.xsDisplayFlex,
      block: styles.xsDisplayBlock,
      inlineBlock: styles.xsDisplayInlineBlock,
      visuallyHidden: styles.xsDisplayVisuallyHidden
    }),
    column: bind(range('xsCol'), styles),
    direction: mapping({
      row: styles.xsDirectionRow,
      column: styles.xsDirectionColumn
    }),

    smDisplay: mapping({
      none: styles.smDisplayNone,
      flex: styles.smDisplayFlex,
      block: styles.smDisplayBlock,
      inlineBlock: styles.smDisplayInlineBlock,
      visuallyHidden: styles.smDisplayVisuallyHidden
    }),
    smColumn: bind(range('smCol'), styles),
    smDirection: mapping({
      row: styles.smDirectionRow,
      column: styles.smDirectionColumn
    }),

    mdDisplay: mapping({
      none: styles.mdDisplayNone,
      flex: styles.mdDisplayFlex,
      block: styles.mdDisplayBlock,
      inlineBlock: styles.mdDisplayInlineBlock,
      visuallyHidden: styles.mdDisplayVisuallyHidden
    }),
    mdColumn: bind(range('mdCol'), styles),
    mdDirection: mapping({
      row: styles.mdDirectionRow,
      column: styles.mdDirectionColumn
    }),

    lgDisplay: mapping({
      none: styles.lgDisplayNone,
      flex: styles.lgDisplayFlex,
      block: styles.lgDisplayBlock,
      inlineBlock: styles.lgDisplayInlineBlock,
      visuallyHidden: styles.lgDisplayVisuallyHidden
    }),
    lgColumn: bind(range('lgCol'), styles),
    lgDirection: mapping({
      row: styles.lgDirectionRow,
      column: styles.lgDirectionColumn
    }),

    alignContent: mapping({
      start: layout.contentStart,
      end: layout.contentEnd,
      center: layout.contentCenter,
      between: layout.contentBetween,
      around: layout.contentAround
      // default: stretch
    }),
    alignItems: mapping({
      start: layout.itemsStart,
      end: layout.itemsEnd,
      center: layout.itemsCenter,
      baseline: layout.itemsBaseline
      // default: stretch
    }),
    alignSelf: mapping({
      start: layout.selfStart,
      end: layout.selfEnd,
      center: layout.selfCenter,
      baseline: layout.selfBaseline,
      stretch: layout.selfStretch
      // default: auto
    }),
    bottom: toggle(layout.bottom0),
    color: mapping({
      blue: colors.blueBg,
      darkGray: colors.darkGrayBg,
      pine: colors.pineBg,
      gray: colors.grayBg,
      red: colors.redBg,
      olive: colors.oliveBg,
      lightGray: colors.lightGrayBg,
      white: colors.whiteBg,
      orange: colors.orangeBg,
      green: colors.greenBg,
      navy: colors.navyBg,
      midnight: colors.midnightBg,
      purple: colors.purpleBg,
      orchid: colors.orchidBg,
      eggplant: colors.eggplantBg,
      maroon: colors.maroonBg,
      watermelon: colors.watermelonBg,
      lightWash: colors.lightWashBg,
      darkWash: colors.darkWashBg
      // default: transparent
    }),
    fit: toggle(layout.fit),
    flex: mapping({
      grow: layout.flexGrow,
      none: layout.flexNone
      // default: shrink
    }),
    height: function (_height) {
      function height(_x) {
        return _height.apply(this, arguments);
      }

      height.toString = function () {
        return _height.toString();
      };

      return height;
    }(function (height) {
      return fromInlineStyle({ height: height });
    }),
    justifyContent: mapping({
      end: layout.justifyEnd,
      center: layout.justifyCenter,
      between: layout.justifyBetween,
      around: layout.justifyAround
      // default: start
    }),
    left: toggle(layout.left0),
    deprecatedMargin: function deprecatedMargin(value) {
      var mt = identity();
      var mb = identity();
      var ml = identity();
      var mr = identity();
      switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
        case 'number':
          return fromClassName(whitespaceLegacy['m' + formatIntBoint(value)]);
        case 'object':
          if (value.top) {
            mt = fromClassName(whitespaceLegacy['mt' + formatIntBoint(value.top)]);
          }

          if (value.bottom) {
            mb = fromClassName(whitespaceLegacy['mb' + formatIntBoint(value.bottom)]);
          }

          if (value.left) {
            ml = fromClassName(value.left === 'auto' ? whitespaceLegacy.mlAuto : whitespaceLegacy['ml' + formatIntBoint(value.left)]);
          }

          if (value.right) {
            mr = fromClassName(value.right === 'auto' ? whitespaceLegacy.mrAuto : whitespaceLegacy['mr' + formatIntBoint(value.right)]);
          }
          return concat([mt, mb, ml, mr]);
        default:
          return identity();
      }
    },
    marginStart: marginStart,
    marginEnd: marginEnd,
    margin: margin,
    marginTop: marginTop,
    marginRight: marginRight,
    marginBottom: marginBottom,
    marginLeft: marginLeft,
    smMargin: smMargin,
    smMarginTop: smMarginTop,
    smMarginRight: smMarginRight,
    smMarginBottom: smMarginBottom,
    smMarginLeft: smMarginLeft,
    mdMargin: mdMargin,
    mdMarginTop: mdMarginTop,
    mdMarginRight: mdMarginRight,
    mdMarginBottom: mdMarginBottom,
    mdMarginLeft: mdMarginLeft,
    lgMargin: lgMargin,
    lgMarginTop: lgMarginTop,
    lgMarginRight: lgMarginRight,
    lgMarginBottom: lgMarginBottom,
    lgMarginLeft: lgMarginLeft,
    maxHeight: function (_maxHeight) {
      function maxHeight(_x2) {
        return _maxHeight.apply(this, arguments);
      }

      maxHeight.toString = function () {
        return _maxHeight.toString();
      };

      return maxHeight;
    }(function (maxHeight) {
      return fromInlineStyle({ maxHeight: maxHeight });
    }),
    maxWidth: function (_maxWidth) {
      function maxWidth(_x3) {
        return _maxWidth.apply(this, arguments);
      }

      maxWidth.toString = function () {
        return _maxWidth.toString();
      };

      return maxWidth;
    }(function (maxWidth) {
      return fromInlineStyle({ maxWidth: maxWidth });
    }),
    minHeight: function (_minHeight) {
      function minHeight(_x4) {
        return _minHeight.apply(this, arguments);
      }

      minHeight.toString = function () {
        return _minHeight.toString();
      };

      return minHeight;
    }(function (minHeight) {
      return fromInlineStyle({ minHeight: minHeight });
    }),
    minWidth: function (_minWidth) {
      function minWidth(_x5) {
        return _minWidth.apply(this, arguments);
      }

      minWidth.toString = function () {
        return _minWidth.toString();
      };

      return minWidth;
    }(function (minWidth) {
      return fromInlineStyle({ minWidth: minWidth });
    }),
    overflow: mapping({
      hidden: layout.overflowHidden,
      scroll: layout.overflowScroll,
      auto: layout.overflowAuto,
      scrollX: layout.overflowScrollX,
      scrollY: layout.overflowScrollY
      // default: visible
    }),
    deprecatedPadding: function deprecatedPadding(value) {
      switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
        case 'number':
          return fromClassName(whitespaceLegacy['p' + value]);
        case 'object':
          return concat([value.x ? fromClassName(whitespaceLegacy['px' + value.x]) : identity(), value.y ? fromClassName(whitespaceLegacy['py' + value.y]) : identity()]);
        default:
          return identity();
      }
    },
    padding: padding,
    paddingX: paddingX,
    paddingY: paddingY,
    smPadding: smPadding,
    smPaddingX: smPaddingX,
    smPaddingY: smPaddingY,
    mdPadding: mdPadding,
    mdPaddingX: mdPaddingX,
    mdPaddingY: mdPaddingY,
    lgPadding: lgPadding,
    lgPaddingX: lgPaddingX,
    lgPaddingY: lgPaddingY,
    position: mapping({
      absolute: layout.absolute,
      relative: layout.relative,
      fixed: layout.fixed
      // default: static
    }),
    right: toggle(layout.right0),
    shape: mapping({
      circle: borders.circle,
      pill: borders.pill,
      rounded: borders.rounded,
      roundedBottom: borders.roundedBottom,
      roundedLeft: borders.roundedLeft,
      roundedRight: borders.roundedRight,
      roundedTop: borders.roundedTop
      // default: square
    }),
    top: toggle(layout.top0),
    width: function (_width) {
      function width(_x6) {
        return _width.apply(this, arguments);
      }

      width.toString = function () {
        return _width.toString();
      };

      return width;
    }(function (width) {
      return fromInlineStyle({ width: width });
    }),
    wrap: toggle(layout.flexWrap),
    dangerouslySetInlineStyle: function dangerouslySetInlineStyle(value) {
      return (
        /* eslint-disable-next-line no-underscore-dangle */
        value && value.__style ? fromInlineStyle(value.__style) : identity()
      );
    }
  };

  /*

  # The Component

  */

  var contains = function contains(key, arr) {
    return arr.indexOf(key) >= 0;
  };
  var omit = function omit(keys, obj) {
    return Object.keys(obj).reduce(function (acc, k) {
      if (contains(k, keys)) {
        return acc;
      }
      return _extends({}, acc, defineProperty({}, k, obj[k]));
    }, {});
  };

  function Box(_ref) {
    var children = _ref.children,
        props = objectWithoutProperties(_ref, ['children']);

    // Flow can't reason about the constant nature of Object.keys so we can't use
    // a functional (reduce) style here.

    // Box is a "pass-through" component, meaning that if you pass properties to
    // it that it doesn't know about (`aria-label` for instance) it passes
    // directly back to the underlying `<div/>`. That's generally useful, but
    // we'd also like to strip out a few naughty properties that break style
    // encapsulation (className, style) or accessibility (onClick).
    var blacklist = ['onClick', 'className', 'style'];

    // All Box's are box-sized by default, so we start off building up the styles
    // to be applied with a Box base class.
    var s = fromClassName(styles.box);

    // This loops through each property and if it exists in the previously
    // defined transform map, concatentes the resulting styles to the base
    // styles. If there's a match, we also don't pass through that property. This
    // means Box's runtime is only dependent on the number of properties passed
    // to it (which is typically small) instead of the total number of possible
    // properties (~30 or so). While it may ~feel~ like Box is innefficient, its
    // biggest performance impact is on startup time because there's so much code
    // here.

    // eslint-disable-next-line no-restricted-syntax
    for (var prop in props) {
      if (Object.prototype.hasOwnProperty.call(propToFn, prop)) {
        var fn = propToFn[prop];
        var value = props[prop];
        blacklist = blacklist.concat(prop);
        s = concat([s, fn(value)]);
      }
    }

    // And... magic!
    return React.createElement(
      'div',
      _extends({}, omit(blacklist, props), toProps(s)),
      children
    );
  }

  /*

  # PropTypes

  And we're done here :)

  */

  var ColumnPropType = PropTypes.oneOf([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);

  var MarginPropType = PropTypes.oneOf([-12, -11, -10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);

  var PaddingPropType = PropTypes.oneOf([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);

  Box.propTypes = {
    children: PropTypes.node,
    dangerouslySetInlineStyle: PropTypes.exact({
      __style: PropTypes.object
    }),

    xs: PropTypes.exact({
      display: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['flex', 'flexColumn', 'inlineBlock'])]),
      column: PropTypes.number
    }),
    sm: PropTypes.exact({
      display: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['flex', 'flexColumn', 'inlineBlock'])]),
      column: PropTypes.number
    }),
    md: PropTypes.exact({
      display: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['flex', 'flexColumn', 'inlineBlock'])]),
      column: PropTypes.number
    }),
    lg: PropTypes.exact({
      display: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['flex', 'flexColumn', 'inlineBlock'])]),
      column: PropTypes.number
    }),
    deprecatedMargin: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
      top: PropTypes.number,
      bottom: PropTypes.number,
      left: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['auto'])]),
      right: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['auto'])])
    })]),
    deprecatedPadding: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
      x: PropTypes.number,
      y: PropTypes.number
    })]),

    display: PropTypes.oneOf(['none', 'flex', 'block', 'inlineBlock', 'visuallyHidden']),
    direction: PropTypes.oneOf(['row', 'column']),
    column: ColumnPropType,

    smDisplay: PropTypes.oneOf(['none', 'flex', 'block', 'inlineBlock', 'visuallyHidden']),
    smDirection: PropTypes.oneOf(['row', 'column']),
    smColumn: ColumnPropType,

    mdDisplay: PropTypes.oneOf(['none', 'flex', 'block', 'inlineBlock', 'visuallyHidden']),
    mdDirection: PropTypes.oneOf(['row', 'column']),
    mdColumn: ColumnPropType,

    lgDisplay: PropTypes.oneOf(['none', 'flex', 'block', 'inlineBlock', 'visuallyHidden']),
    lgDirection: PropTypes.oneOf(['row', 'column']),
    lgColumn: ColumnPropType,

    alignContent: PropTypes.oneOf(['start', 'end', 'center', 'between', 'around', 'stretch']),
    alignItems: PropTypes.oneOf(['start', 'end', 'center', 'baseline', 'stretch']),
    alignSelf: PropTypes.oneOf(['auto', 'start', 'end', 'center', 'baseline', 'stretch']),
    bottom: PropTypes.bool,
    color: PropTypes.oneOf(['blue', 'darkGray', 'darkWash', 'eggplant', 'gray', 'green', 'lightGray', 'lightWash', 'maroon', 'midnight', 'navy', 'olive', 'orange', 'orchid', 'pine', 'purple', 'red', 'transparent', 'watermelon', 'white']),
    fit: PropTypes.bool,
    flex: PropTypes.oneOf(['grow', 'shrink', 'none']),
    grow: PropTypes.bool,
    height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    justifyContent: PropTypes.oneOf(['start', 'end', 'center', 'between', 'around']),
    left: PropTypes.bool,

    marginStart: MarginPropType,
    marginEnd: MarginPropType,

    margin: MarginPropType,
    marginTop: MarginPropType,
    marginRight: MarginPropType,
    marginBottom: MarginPropType,
    marginLeft: MarginPropType,

    smMargin: MarginPropType,
    smMarginTop: MarginPropType,
    smMarginRight: MarginPropType,
    smMarginBottom: MarginPropType,
    smMarginLeft: MarginPropType,

    mdMargin: MarginPropType,
    mdMarginTop: MarginPropType,
    mdMarginRight: MarginPropType,
    mdMarginBottom: MarginPropType,
    mdMarginLeft: MarginPropType,

    lgMargin: MarginPropType,
    lgMarginTop: MarginPropType,
    lgMarginRight: MarginPropType,
    lgMarginBottom: MarginPropType,
    lgMarginLeft: MarginPropType,

    maxHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    maxWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    minHeight: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    minWidth: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),

    overflow: PropTypes.oneOf(['visible', 'hidden', 'scroll', 'scrollX', 'scrollY', 'auto']),

    padding: PaddingPropType,
    paddingX: PaddingPropType,
    paddingY: PaddingPropType,

    smPadding: PaddingPropType,
    smPaddingX: PaddingPropType,
    smPaddingY: PaddingPropType,

    mdPadding: PaddingPropType,
    mdPaddingX: PaddingPropType,
    mdPaddingY: PaddingPropType,

    lgPadding: PaddingPropType,
    lgPaddingX: PaddingPropType,
    lgPaddingY: PaddingPropType,

    position: PropTypes.oneOf(['static', 'absolute', 'relative', 'fixed']),
    right: PropTypes.bool,
    shape: PropTypes.oneOf(['square', 'rounded', 'pill', 'circle', 'roundedTop', 'roundedBottom', 'roundedLeft', 'roundedRight']),
    top: PropTypes.bool,
    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    wrap: PropTypes.bool
  };

  var styles$1 = { "icon": "_u0", "iconBlock": "_u1 _45" };

  var add = 'M22 10h-8V2a2 2 0 0 0-4 0v8H2a2 2 0 0 0 0 4h8v8a2 2 0 0 0 4 0v-8h8a2 2 0 0 0 0-4';

  var addCircle = 'M17.75 13.25h-4.5v4.5a1.25 1.25 0 0 1-2.5 0v-4.5h-4.5a1.25 1.25 0 0 1 0-2.5h4.5v-4.5a1.25 1.25 0 0 1 2.5 0v4.5h4.5a1.25 1.25 0 0 1 0 2.5M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

  var addPin = 'M21.5 8.69c1.49.87 2.5 2.46 2.5 4.31h-4v7.96L19 23l-1-2.04V13h-4c0-1.85 1.01-3.44 2.5-4.31V2.93c-.86-.22-1.5-1-1.5-1.93h8c0 .93-.64 1.71-1.5 1.93v5.76zm-11.25.81a1.25 1.25 0 0 1 0 2.5H7v3.25a1.25 1.25 0 0 1-2.5 0V12H1.25a1.25 1.25 0 0 1 0-2.5H4.5V6.25a1.25 1.25 0 0 1 2.5 0V9.5h3.25z';

  var angledPin = 'M13.988,19.153 C15.485,17.656 15.985,15.446 15.481,13.537 L19.740,9.074 L22.662,8.807 L22.645,8.789 C22.739,8.804 22.837,8.780 22.909,8.708 C23.030,8.587 23.031,8.391 22.910,8.271 L15.730,1.090 C15.609,0.970 15.413,0.970 15.292,1.091 C15.220,1.163 15.197,1.262 15.211,1.356 L15.194,1.338 L14.927,4.261 L10.463,8.520 C8.554,8.015 6.344,8.516 4.847,10.012 L8.656,13.821 L3.324,19.153 C2.562,19.915 0.711,22.108 1.039,22.962 C1.892,23.290 4.086,21.438 4.847,20.676 C5.609,19.915 10.179,15.344 10.179,15.344 L13.988,19.153 Z';

  var arrowBack = 'M17.28 24c-.57 0-1.14-.22-1.58-.66L4.5 12 15.7.66a2.21 2.21 0 0 1 3.15 0c.87.88.87 2.3 0 3.18L10.79 12l8.06 8.16c.87.88.87 2.3 0 3.18-.44.44-1 .66-1.57.66';

  var arrowCircleForward = 'M12.94 16.07c-.49.48-1.28.48-1.77 0a1.25 1.25 0 0 1 0-1.77l1.06-1.07H8.25a1.25 1.25 0 0 1 0-2.5h3.95L11.17 9.7a1.25 1.25 0 0 1 0-1.77c.49-.48 1.28-.48 1.77 0L17 12l-4.06 4.07zM12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0z';

  var arrowCircleDown = 'M0 12c0 6.63 5.37 12 12 12s12-5.37 12-12S18.63 0 12 0 0 5.37 0 12zm10.77-3.75a1.25 1.25 0 0 1 2.5 0v3.95l1.03-1.03a1.25 1.25 0 0 1 1.77 0c.48.49.48 1.28 0 1.77L12 17l-4.07-4.06c-.48-.49-.48-1.28 0-1.77a1.25 1.25 0 0 1 1.77 0l1.07 1.06V8.25z';

  var arrowDown = 'M12 19.5L.66 8.29c-.88-.86-.88-2.27 0-3.14.88-.87 2.3-.87 3.18 0L12 13.21l8.16-8.06c.88-.87 2.3-.87 3.18 0 .88.87.88 2.28 0 3.14L12 19.5z';

  var arrowForward = 'M6.72 24c.57 0 1.14-.22 1.57-.66L19.5 12 8.29.66c-.86-.88-2.27-.88-3.14 0-.87.88-.87 2.3 0 3.18L13.21 12l-8.06 8.16c-.87.88-.87 2.3 0 3.18.43.44 1 .66 1.57.66';

  var arrowUp = 'M21.75 19.5c-.58 0-1.15-.22-1.59-.65L12 10.79l-8.16 8.06c-.88.87-2.3.87-3.18 0a2.21 2.21 0 0 1 0-3.15L12 4.5l11.34 11.2c.88.87.88 2.28 0 3.15-.44.43-1.01.65-1.59.65';

  var arrowUpRight = 'M4.9283,1 C3.6273,1 2.5713,2.054 2.5713,3.357 C2.5713,4.66 3.6273,5.714 4.9283,5.714 L14.9523,5.714 L1.6893,18.976 C0.7703,19.896 0.7703,21.389 1.6893,22.31 C2.1503,22.771 2.7533,23 3.3573,23 C3.9603,23 4.5633,22.771 5.0243,22.31 L18.2853,9.047 L18.2853,19.071 C18.2853,20.374 19.3413,21.429 20.6433,21.429 C21.9443,21.429 23.0003,20.374 23.0003,19.071 L23.0003,1 L4.9283,1 Z';

  var bell = 'M12 24c-1.66 0-3-1.34-3-3h6c0 1.66-1.34 3-3 3zm7-10.83c1.58 1.52 2.67 3.55 3 5.83H2c.33-2.28 1.42-4.31 3-5.83V7c0-3.87 3.13-7 7-7s7 3.13 7 7v6.17z';

  var camera = 'M6.36 4.99L8.56 2h6.88l2.2 2.99h3.09c1.8 0 3.27 1.49 3.27 3.33v10.35c0 1.84-1.47 3.33-3.27 3.33H3.27C1.47 22 0 20.51 0 18.67V8.32c0-1.84 1.47-3.33 3.27-3.33h3.09zM12 7.22a5.74 5.74 0 1 0 0 11.48 5.74 5.74 0 0 0 0-11.48m0 2.73c1.66 0 3.01 1.35 3.01 3.01 0 1.66-1.35 3.01-3.01 3.01-1.66 0-3.01-1.35-3.01-3.01 0-1.66 1.35-3.01 3.01-3.01';

  var cameraRoll = 'M8 10c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2M6.25 3.5h11.5c1.52 0 2.75 1.23 2.75 2.75v8.25L17 11l-6 6-3.5-3.5-4 4V6.25c0-1.52 1.23-2.75 2.75-2.75M17.75 1H6.25A5.25 5.25 0 0 0 1 6.25v11.5C1 20.64 3.35 23 6.25 23h11.5c2.89 0 5.25-2.36 5.25-5.25V6.25C23 3.35 20.64 1 17.75 1';

  var cancel = 'M15.18 12l7.16-7.16c.88-.88.88-2.3 0-3.18-.88-.88-2.3-.88-3.18 0L12 8.82 4.84 1.66c-.88-.88-2.3-.88-3.18 0-.88.88-.88 2.3 0 3.18L8.82 12l-7.16 7.16c-.88.88-.88 2.3 0 3.18.44.44 1.01.66 1.59.66.58 0 1.15-.22 1.59-.66L12 15.18l7.16 7.16c.44.44 1.01.66 1.59.66.58 0 1.15-.22 1.59-.66.88-.88.88-2.3 0-3.18L15.18 12z';

  var check = 'M9.17 21.75L.73 12.79c-.97-1.04-.97-2.71 0-3.75a2.403 2.403 0 0 1 3.53 0l4.91 5.22L19.74 3.03c.98-1.04 2.55-1.04 3.53 0 .97 1.03.97 2.71 0 3.74L9.17 21.75z';

  var checkCircle = 'M18.88 9.88l-8.66 8.67-5.12-5.13a1.25 1.25 0 0 1 0-1.77c.48-.49 1.28-.49 1.76 0l3.36 3.36 6.9-6.89c.49-.49 1.28-.49 1.76 0 .49.49.49 1.28 0 1.76M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

  var circleOutline = 'M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.6 0 12 0zm0 22.2C6.45 22.2 1.8 17.7 1.8 12 1.8 6.3 6.3 1.8 12 1.8c5.7 0 10.2 4.5 10.2 10.2 0 5.7-4.65 10.2-10.2 10.2z';

  var clear = 'M15.18 16.95L12 13.77l-3.18 3.18c-.49.49-1.28.49-1.77 0a1.25 1.25 0 0 1 0-1.77L10.23 12 7.05 8.82a1.25 1.25 0 0 1 0-1.77 1.25 1.25 0 0 1 1.77 0L12 10.23l3.18-3.18a1.25 1.25 0 0 1 1.77 0c.49.49.49 1.28 0 1.77L13.77 12l3.18 3.18c.49.49.49 1.28 0 1.77s-1.28.49-1.77 0M24 12c0-6.63-5.37-12-12-12S0 5.37 0 12s5.37 12 12 12 12-5.37 12-12';

  var clock = 'M17.83 17.83c-.37.36-.85.55-1.33.55-.48 0-.96-.19-1.33-.55l-5.04-5.05V6c0-1.04.83-1.87 1.87-1.87s1.88.83 1.88 1.87v5.22l3.95 3.95c.73.74.73 1.92 0 2.66M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

  var cog = 'M6.25 2L.5 12l5.75 10h11.5l5.75-10-5.75-10H6.25zm1.703 10a4 4 0 1 1 8 0 4 4 0 0 1-8 0z';

  var compass = 'M12.868 12.9A1.25 1.25 0 1 0 11.1 11.13a1.25 1.25 0 0 0 1.77 1.768m2.268 1.134c-.207.517-.62.924-1.139 1.124L5.62 18.38l3.223-8.377c.2-.52.607-.933 1.124-1.139l8.617-3.447-3.447 8.617zm5.348-10.519c-4.686-4.686-12.284-4.686-16.97 0-4.687 4.687-4.687 12.285 0 16.971 4.686 4.686 12.284 4.686 16.97 0 4.686-4.686 4.686-12.284 0-16.97z';

  var dash = 'M20 16H4c-2.2 0-4-1.8-4-4s1.8-4 4-4h16c2.2 0 4 1.8 4 4s-1.8 4-4 4';

  var edit = 'M13.386 6.018l4.596 4.596L7.097 21.499 1 22.999l1.501-6.096L13.386 6.018zm8.662-4.066a3.248 3.248 0 0 1 0 4.596L19.75 8.848 15.154 4.25l2.298-2.299a3.248 3.248 0 0 1 4.596 0z';

  var ellipsis = 'M12 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3M3 9c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm18 0c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3z';

  var ellipsisCircleOutline = 'M12 10.5c.9 0 1.5.6 1.5 1.5s-.6 1.5-1.5 1.5-1.5-.6-1.5-1.5.6-1.5 1.5-1.5zm-4.5 0c.9 0 1.5.6 1.5 1.5s-.6 1.5-1.5 1.5S6 12.9 6 12s.6-1.5 1.5-1.5zm9 0c.9 0 1.5.6 1.5 1.5s-.6 1.5-1.5 1.5S15 12.9 15 12s.6-1.5 1.5-1.5zM12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.6 0 12 0zm0 22.2C6.45 22.2 1.8 17.7 1.8 12 1.8 6.3 6.3 1.8 12 1.8c5.7 0 10.2 4.5 10.2 10.2 0 5.7-4.65 10.2-10.2 10.2z';

  var envelope = 'M21.53 7.508l-7.586 7.452c-.536.526-1.24.79-1.944.79a2.77 2.77 0 0 1-1.945-.79L2.47 7.508a.728.728 0 0 1 0-1.043.76.76 0 0 1 1.061 0l7.586 7.452c.487.48 1.28.48 1.768 0l7.585-7.452a.76.76 0 0 1 1.061 0 .728.728 0 0 1 0 1.043zM1 19h22V5H1v14z';

  var eye = 'M10,12 C10,13.105 10.895,14 12,14 C13.105,14 14,13.105 14,12 C14,10.895 13.105,10 12,10 C10.895,10 10,10.895 10,12 Z M12,17 C9.239,17 7,14.761 7,12 C7,9.239 9.239,7 12,7 C14.761,7 17,9.239 17,12 C17,14.761 14.761,17 12,17 M12,3.5 C6.455,3.5 1.751,7.051 0,12 C1.751,16.949 6.455,20.5 12,20.5 C17.545,20.5 22.249,16.949 24,12 C22.249,7.051 17.545,3.5 12,3.5';

  var facebook = 'M17.75 3.984l-2.312.001c-1.811 0-2.163.842-2.163 2.077v2.724h4.323l-.563 4.267h-3.76V24H8.769V13.053H5V8.786h3.769V5.64C8.769 1.988 11.05 0 14.383 0c1.596 0 2.967.116 3.367.168v3.816z';

  var faceHappy = 'M12.023 20.713c-2.944 0-5.378-1.96-5.356-4.906.017-2.117 1.728-.536 5.33-.545 3.6-.01 5.322-1.645 5.327.548.007 2.946-2.356 4.903-5.3 4.903m4.439-9.83a1.675 1.675 0 1 1 0-3.351 1.675 1.675 0 0 1 0 3.35M6.093 9.207a1.675 1.675 0 1 1 3.35 0 1.675 1.675 0 0 1-3.35 0m17.906 2.782C23.994 5.367 18.623 0 12 0 5.373 0 0 5.373 0 12c0 6.628 5.373 12 12 12C18.624 24 23.995 18.633 24 12.01L24 12l-.001-.01';

  var faceSad = 'M17.088 17.841a1.2 1.2 0 0 1-1.593.58 4.517 4.517 0 0 0-.744-.217c-.738-.168-1.653-.27-2.75-.271-1.098 0-2.012.103-2.752.27-.411.094-.657.18-.741.217a1.199 1.199 0 1 1-1.014-2.174c.237-.11.643-.251 1.223-.383.915-.207 2.008-.33 3.284-.33 1.276.001 2.369.123 3.281.33.582.132.988.273 1.226.384.601.279.86.992.58 1.594zm-.624-6.959a1.675 1.675 0 1 1 0-3.35 1.675 1.675 0 0 1 0 3.35zM6.093 9.207a1.675 1.675 0 1 1 3.35 0 1.675 1.675 0 0 1-3.35 0zM24 11.989C23.995 5.367 18.624 0 12.002 0 5.373 0 0 5.373 0 12c0 6.628 5.373 12 12.002 12C18.623 24 23.995 18.633 24 12.01v-.02z';

  var faceSmiley = 'M16.5 11a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3m.449 5.95A6.947 6.947 0 0 1 12 19a6.96 6.96 0 0 1-4.948-2.048.999.999 0 0 1 0-1.414.999.999 0 0 1 1.414-.001A4.968 4.968 0 0 0 12 17c1.336 0 2.592-.52 3.535-1.464a1 1 0 0 1 1.414 1.414M6 9.5a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0';

  var filter = 'M24 3.5c0-1.1-.9-2-2-2H2c-1.1 0-2 .9-2 2 0 .55.22 1.05.58 1.41L9 13.46v9.04l6-2v-7.05l8.37-8.5c.39-.36.63-.88.63-1.45';

  var flag = 'M17 7.5L22 0H2v22c0 1.1.9 2 2 2s2-.9 2-2v-7h16l-5-7.5z';

  var flashlight = 'M6 7.08V10H1V7.08A6.086 6.086 0 0 1 7.079 1H10v5H6v1.08zM6 18h4v5H7.079A6.086 6.086 0 0 1 1 16.921V14h5v4zM16.92 1A6.086 6.086 0 0 1 23 7.079V10h-5V6h-4V1h2.92zM18 16.92V14h5v2.92A6.086 6.086 0 0 1 16.921 23H14v-5h4v-1.08z';

  var gif = 'M19.5 3h-15C2.02 3 0 5.03 0 7.5v9C0 18.98 2.02 21 4.5 21h15c2.47 0 4.5-2.02 4.5-4.5v-9C24 5.03 21.97 3 19.5 3zm-7.41 12.88v-7.8h1.59v7.8h-1.59zm3.45-7.8h5.58v1.34h-4v1.88h3.39v1.35h-3.39v3.23h-1.58v-7.8zm-11.4 6.83c-.33-.37-.58-.79-.76-1.28-.17-.49-.26-1.03-.26-1.62 0-.66.11-1.26.33-1.8.22-.55.53-1.01.95-1.39.32-.29.68-.51 1.1-.66.41-.15.88-.23 1.4-.23.49 0 .93.06 1.32.19s.72.31 1 .54c.27.23.5.51.67.83.17.32.29.67.35 1.04H8.69a1.67 1.67 0 0 0-.56-.93c-.29-.24-.69-.36-1.19-.36-.37 0-.7.07-.97.21-.27.14-.5.34-.69.59-.18.25-.32.54-.41.88-.09.34-.13.7-.13 1.09 0 .4.05.77.15 1.1.1.34.25.63.43.88.19.24.42.43.69.57.27.14.57.21.9.21.31 0 .59-.05.83-.16.25-.1.46-.23.64-.4.17-.17.31-.36.4-.57.1-.21.14-.42.14-.64v-.04H7.05v-1.22h3.28v4.14H9.14l-.05-1.05h-.03c-.27.45-.58.77-.94.94a2.8 2.8 0 0 1-1.25.27c-.59 0-1.11-.1-1.56-.3-.46-.2-.85-.48-1.17-.83z';

  var globe = 'M15.49 20.83c.87-2.01 1.37-4.75 1.48-7.58h4.44a9.53 9.53 0 0 1-5.92 7.58zm-12.9-7.58h4.44c.11 2.83.61 5.57 1.49 7.58-3.15-1.25-5.47-4.12-5.93-7.58zM8.52 3.17c-.88 2.01-1.38 4.75-1.49 7.58H2.59c.46-3.46 2.78-6.33 5.93-7.58zm1.01 7.58C9.76 5.43 11.4 2.54 12 2.5h.01c.67.06 2.24 3.01 2.46 8.25H9.53zm2.48 10.75H12c-.6-.04-2.24-2.93-2.47-8.25h4.94c-.22 5.24-1.79 8.19-2.46 8.25zm9.4-10.75h-4.44c-.11-2.83-.61-5.57-1.48-7.58a9.53 9.53 0 0 1 5.92 7.58zM24 12C24 5.39 18.62.01 12.01 0H12C5.38 0 0 5.38 0 12s5.38 12 12 12h.01C18.62 24 24 18.61 24 12z';

  var globeChecked = 'M6.8 9.8H3.1C3.5 7 5.4 4.6 8 3.6c-.7 1.7-1.1 3.9-1.2 6.2m-3.7 2.1h3.7c.1 2.3.5 4.6 1.2 6.2-2.6-1-4.5-3.3-4.9-6.2m7.8-8.8c.5 0 1.8 2.4 2 6.7H8.8c.2-4.3 1.6-6.7 2.1-6.7M9.5 16.3c-.3-1.1-.6-2.6-.7-4.4h2.7c.9-1 2.1-1.7 3.5-2.1-.1-2.3-.5-4.5-1.3-6.2 2.6 1 4.4 3.3 4.9 6.1.7.1 1.5.4 2.1.8-.2-5.3-4.5-9.5-9.8-9.5C5.4 1 1 5.4 1 10.9c0 5.3 4.2 9.6 9.5 9.8-.6-1.1-1-2.3-1-3.7v-.7m10.8-.5L16.2 20l-2.5-2.5c-.3-.3-.3-.8 0-1.1.3-.3.8-.3 1 0l1.5 1.5 3.1-3.2c.2-.3.7-.3 1 0 .3.3.3.8 0 1.1M17 11c-3.3 0-6 2.7-6 6s2.7 6 6 6 6-2.7 6-6-2.7-6-6-6';

  var gmail = 'M3.173 4L12 10.194 20.556 4H3.173zM12 13.29L1 5.806V20h22V5.548L12 13.29z';

  var googlePlus = 'M7 11v2.4h3.97c-.16 1.029-1.2 3.02-3.97 3.02-2.39 0-4.34-1.979-4.34-4.42 0-2.44 1.95-4.42 4.34-4.42 1.36 0 2.27.58 2.79 1.08l1.9-1.83C10.47 5.69 8.89 5 7 5c-3.87 0-7 3.13-7 7s3.13 7 7 7c4.04 0 6.721-2.84 6.721-6.84 0-.46-.051-.81-.111-1.16H7zm17 0v2h-3v3h-2v-3h-3v-2h3V8h2v3h3z';

  var graphBar = 'M1 23V10h5v13H1zm8.5 0V1h5v22h-5zm8.5 0V7h4.999v16H18z';

  var knoop = 'M15 10.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5m0 6c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5m-6-6c-.83 0-1.5-.67-1.5-1.5S8.17 7.5 9 7.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5m0 6c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

  var lightbulb = 'M20 8c0 2.23-.91 4.24-2.39 5.7h.02c-.99.97-1.6 2.31-1.63 3.8V19H8v-1.5c-.03-1.5-.65-2.85-1.64-3.83A7.955 7.955 0 0 1 4 8c0-4.42 3.58-8 8-8s8 3.58 8 8zM8 22.5V21h8v1.5c0 .83-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z';

  var handle = 'M3 15h18a1 1 0 0 1 0 2H3a1 1 0 0 1 0-2zm0-4h18a1 1 0 0 1 0 2H3a1 1 0 0 1 0-2zm0-4h18a1 1 0 0 1 0 2H3a1 1 0 1 1 0-2z';

  var handPointing = 'M17.776,22.390 C13.775,23.978 9.246,22.359 7.219,18.770 C7.040,18.503 6.860,18.218 6.688,17.910 C5.132,15.163 3.028,13.782 2.588,13.581 C2.149,13.378 0.595,12.613 1.100,11.692 C1.381,11.180 2.163,10.801 2.878,10.726 C4.000,10.481 5.897,11.034 7.772,12.222 L4.054,3.419 C3.741,2.677 3.989,1.850 4.609,1.379 C4.612,1.376 4.616,1.373 4.621,1.369 C4.676,1.327 4.734,1.289 4.796,1.253 C4.810,1.247 4.821,1.239 4.835,1.231 C4.901,1.195 4.970,1.160 5.042,1.132 C5.044,1.131 5.044,1.131 5.045,1.131 C5.045,1.131 5.045,1.131 5.047,1.129 C5.119,1.101 5.193,1.079 5.267,1.060 C5.281,1.057 5.295,1.054 5.309,1.049 C5.380,1.035 5.449,1.021 5.518,1.013 C5.525,1.013 5.529,1.011 5.534,1.011 C6.317,0.928 7.093,1.347 7.406,2.088 L9.592,7.261 C9.643,6.623 10.055,6.035 10.709,5.776 C11.633,5.410 12.689,5.839 13.069,6.734 C13.071,6.742 13.074,6.752 13.077,6.759 C13.143,6.136 13.552,5.565 14.191,5.312 C15.117,4.946 16.173,5.373 16.551,6.271 C16.567,6.305 16.578,6.341 16.591,6.379 C16.680,5.784 17.079,5.249 17.695,5.006 C18.619,4.640 19.619,4.970 19.999,5.867 L20.001,5.872 C20.001,5.872 21.115,8.039 22.366,11.651 C22.413,11.791 22.457,11.931 22.495,12.072 C24.027,16.161 21.967,20.728 17.776,22.390';

  var heart = 'M11.98 22.25L1.82 11.95C-.28 9.83-.65 6.4 1.18 4.03a5.763 5.763 0 0 1 8.7-.56l2.1 2.14 1.95-1.98c2.1-2.13 5.48-2.5 7.82-.65 2.8 2.23 2.99 6.35.55 8.82L11.98 22.25z';

  var heartBroken = 'M11.98 22.25L1.82 11.95C-.28 9.83-.65 6.4 1.18 4.03a5.763 5.763 0 0 1 8.7-.56l2.1 2.14 1.95-1.98c2.1-2.13 5.48-2.5 7.82-.65 2.8 2.23 2.99 6.35.55 8.82L11.98 22.25zM15.3 9.54c.4-.4.4-1.06 0-1.46-.4-.4-1.05-.4-1.45 0L12 9.94l-1.85-1.86c-.4-.4-1.05-.4-1.45 0-.4.4-.4 1.06 0 1.46l1.85 1.86-1.85 1.86c-.4.4-.4 1.05 0 1.45.4.4 1.05.41 1.45 0L12 12.85l1.85 1.86c.4.41 1.05.41 1.45 0 .4-.4.4-1.05 0-1.45l-1.85-1.86 1.85-1.86z';

  var link = 'M21 15.05c1.1 0 2 .9 2 2V21c0 1.1-.9 2-2 2H3c-1.1 0-2-.9-2-2V3c0-1.1.9-2 2-2h4a2 2 0 1 1 0 4H5v14h14v-1.95c0-1.1.9-2 2-2zM12 14c-.51 0-1.02-.2-1.41-.59-.79-.78-.79-2.04 0-2.82L16.16 5 14 5.01c-1.1 0-2-.9-2-2 0-1.11.89-2 2-2L20.99 1h2v2l.01 7a2 2 0 1 1-4 0V7.83l-5.59 5.58c-.39.39-.9.59-1.41.59z';

  var location = 'M12 4.5c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3m7.5 3C19.5 3.36 16.14 0 12 0 7.86 0 4.5 3.36 4.5 7.5c0 1.3.36 2.5.94 3.56H5.4L12 24l6.6-12.94h-.04c.58-1.06.94-2.26.94-3.56';

  var lock = 'M8 10V7c0-2.206 1.794-4 4-4s4 1.794 4 4v3H8zm11 .017V7c0-3.86-3.141-7-7-7S5 3.14 5 7v3.017a8.698 8.698 0 0 0-1.75 5.233 8.75 8.75 0 1 0 17.5 0A8.698 8.698 0 0 0 19 10.017z';

  var maximize = 'M11 2.25c0 .69-.56 1.25-1.25 1.25H5.268l5.366 5.366a1.25 1.25 0 0 1-1.768 1.768L3.5 5.268V9.75a1.25 1.25 0 0 1-2.5 0V1h8.75c.69 0 1.25.56 1.25 1.25zM21.75 13c.69 0 1.25.56 1.25 1.25V23h-8.75a1.25 1.25 0 0 1 0-2.5h4.482l-5.366-5.366a1.25 1.25 0 0 1 1.768-1.768l5.366 5.366V14.25c0-.69.56-1.25 1.25-1.25z';

  var megaphone = 'M14 17.5c0 1.378-1.122 2.5-2.5 2.5A2.503 2.503 0 0 1 9 17.5V17h5v.5zm8.947-1.87L18.701 2.712a1.022 1.022 0 0 0-1.566-.521l-15.7 11.24c-.37.264-.525.744-.382 1.179l.551 1.678c.14.425.532.712.974.712H7v.5a4.5 4.5 0 0 0 9 0V17h5.973c.7 0 1.195-.696.974-1.37z';

  var menu = 'M21.5 9.5c1.38 0 2.5 1.13 2.5 2.5a2.5 2.5 0 0 1-2.5 2.5h-19C1.13 14.5 0 13.38 0 12c0-1.37 1.13-2.5 2.5-2.5h19zm-19-3C1.13 6.5 0 5.38 0 4c0-1.37 1.13-2.5 2.5-2.5h19C22.88 1.5 24 2.63 24 4a2.5 2.5 0 0 1-2.5 2.5h-19zm19 11c1.38 0 2.5 1.13 2.5 2.5a2.5 2.5 0 0 1-2.5 2.5h-19C1.13 22.5 0 21.38 0 20c0-1.37 1.13-2.5 2.5-2.5h19z';

  var minimize = 'M1 9.75c0-.69.56-1.25 1.25-1.25h4.482L1.366 3.134a1.25 1.25 0 0 1 1.768-1.768L8.5 6.732V2.25a1.25 1.25 0 0 1 2.5 0V11H2.25C1.56 11 1 10.44 1 9.75zM14.25 23c-.69 0-1.25-.56-1.25-1.25V13h8.75a1.25 1.25 0 0 1 0 2.5h-4.482l5.366 5.366a1.25 1.25 0 0 1-1.768 1.768L15.5 17.268v4.482c0 .69-.56 1.25-1.25 1.25z';

  var move = 'M14.3 18.17a1.25 1.25 0 0 1 1.77 0c.49.49.49 1.28 0 1.76L12 24l-4.07-4.07c-.48-.48-.48-1.27 0-1.76a1.25 1.25 0 0 1 1.77 0l1.05 1.04v-3.96a1.25 1.25 0 0 1 2.5 0v3.96l1.05-1.04zm-9.51-4.92l1.04 1.05c.49.49.49 1.28 0 1.77-.48.48-1.28.48-1.76 0L0 12l4.07-4.07c.48-.48 1.28-.48 1.76 0 .49.49.49 1.28 0 1.77l-1.04 1.05h3.96a1.25 1.25 0 0 1 0 2.5H4.79zm15.14-5.32L24 12l-4.07 4.07c-.48.48-1.27.48-1.76 0a1.25 1.25 0 0 1 0-1.77l1.04-1.05h-3.96a1.25 1.25 0 0 1 0-2.5h3.96L18.17 9.7a1.25 1.25 0 0 1 0-1.77c.49-.48 1.28-.48 1.76 0zM9.7 5.83c-.49.49-1.28.49-1.77 0-.48-.49-.48-1.28 0-1.76L12 0l4.07 4.07c.49.48.49 1.27 0 1.76s-1.28.49-1.77 0l-1.05-1.04v3.96a1.25 1.25 0 0 1-2.5 0V4.79L9.7 5.83z';

  var mute = 'M5.00,7.94 L5.00,7.96 L12.00,1.00 L12.00,23.00 L5.00,16.91 L5.00,16.94 L2.00,16.94 C0.90,16.94 0.00,16.04 0.00,14.94 L0.00,9.94 C0.00,8.83 0.90,7.94 2.00,7.94 L5.00,7.94 Z M23.63,14.12 C24.12,14.60 24.12,15.39 23.63,15.88 C23.15,16.37 22.35,16.37 21.87,15.88 L19.75,13.77 L17.63,15.88 C17.15,16.37 16.35,16.37 15.87,15.88 C15.38,15.39 15.38,14.60 15.87,14.12 L17.98,12.00 L15.87,9.88 C15.38,9.39 15.38,8.60 15.87,8.12 C16.35,7.63 17.15,7.63 17.63,8.12 L19.75,10.23 L21.86,8.12 C22.35,7.63 23.15,7.63 23.63,8.12 C24.12,8.60 24.12,9.40 23.63,9.88 L21.52,12.00 L23.63,14.12 Z';

  var pause = 'M7 0c1.65 0 3 1.35 3 3v18c0 1.65-1.35 3-3 3s-3-1.35-3-3V3c0-1.65 1.35-3 3-3zm10 0c1.65 0 3 1.35 3 3v18c0 1.65-1.35 3-3 3s-3-1.35-3-3V3c0-1.65 1.35-3 3-3z';

  var people = 'M8 11a4.5 4.5 0 1 1 0-9 4.5 4.5 0 0 1 0 9zm10 3c3.314 0 6 2.713 6 6.061V22H0v-1.919C0 15.618 3.582 12 8 12c2.614 0 4.927 1.272 6.387 3.23A5.927 5.927 0 0 1 18 14zm0-1a3.25 3.25 0 1 1 0-6.5 3.25 3.25 0 0 1 0 6.5z';

  var person = 'M12 12c5.523 0 10 4.477 10 10v2H2v-2c0-5.523 4.477-10 10-10zm0-1a5.5 5.5 0 1 1 0-11 5.5 5.5 0 1 1 0 11z';

  var personAdd = 'M16.5 12a7.5 7.5 0 0 1 7.5 7.5V21H9v-1.5a7.5 7.5 0 0 1 7.5-7.5zm0-1a4 4 0 1 1 0-8 4 4 0 0 1 0 8zm-7.25 1H6.5v2.75a1.25 1.25 0 0 1-2.5 0V12H1.25a1.25 1.25 0 0 1 0-2.5H4V6.75a1.25 1.25 0 0 1 2.5 0V9.5h2.75a1.25 1.25 0 0 1 0 2.5z';

  var pin = 'M18 13.5c0-2.22-1.21-4.15-3-5.19V2.45A2.5 2.5 0 0 0 17 0H7a2.5 2.5 0 0 0 2 2.45v5.86c-1.79 1.04-3 2.97-3 5.19h5v8.46L12 24l1-2.04V13.5h5z';

  var pinHide = 'M9.13 6.37c.49.48.49 1.27 0 1.76l-2.61 2.62 2.61 2.62c.49.48.49 1.27 0 1.76-.48.49-1.27.49-1.76 0l-2.62-2.61-2.62 2.61c-.48.49-1.28.49-1.76 0-.49-.49-.49-1.28 0-1.76l2.61-2.62L.37 8.13c-.49-.49-.49-1.28 0-1.76.48-.49 1.28-.49 1.76 0l2.62 2.61 2.62-2.61c.49-.49 1.28-.49 1.76 0zM20.5 8.69c1.49.87 2.5 2.46 2.5 4.31h-4v7.96L18 23l-1-2.04V13h-4c0-1.85 1.01-3.44 2.5-4.31V2.93c-.86-.22-1.5-1-1.5-1.93h8c0 .93-.64 1.71-1.5 1.93v5.76z';

  var pinterest = 'M0 12c0 5.123 3.211 9.497 7.73 11.218-.11-.937-.227-2.482.025-3.566.217-.932 1.401-5.938 1.401-5.938s-.357-.715-.357-1.774c0-1.66.962-2.9 2.161-2.9 1.02 0 1.512.765 1.512 1.682 0 1.025-.653 2.557-.99 3.978-.281 1.189.597 2.159 1.769 2.159 2.123 0 3.756-2.239 3.756-5.471 0-2.861-2.056-4.86-4.991-4.86-3.398 0-5.393 2.549-5.393 5.184 0 1.027.395 2.127.889 2.726a.36.36 0 0 1 .083.343c-.091.378-.293 1.189-.332 1.355-.053.218-.173.265-.4.159-1.492-.694-2.424-2.875-2.424-4.627 0-3.769 2.737-7.229 7.892-7.229 4.144 0 7.365 2.953 7.365 6.899 0 4.117-2.595 7.431-6.199 7.431-1.211 0-2.348-.63-2.738-1.373 0 0-.599 2.282-.744 2.84-.282 1.084-1.064 2.456-1.549 3.235C9.584 23.815 10.77 24 12 24c6.627 0 12-5.373 12-12S18.627 0 12 0 0 5.373 0 12';

  var play = 'M20.62 9.48L6.63.48C4.63-.8 2 .63 2 3v18c0 2.37 2.63 3.8 4.63 2.52l13.99-9c1.84-1.18 1.84-3.86 0-5.04';

  var questionMark = 'M14.34 21.2c0 1.57-1.19 2.8-2.78 2.8-1.58 0-2.77-1.23-2.77-2.8 0-1.57 1.19-2.8 2.77-2.8 1.59 0 2.78 1.23 2.78 2.8m-2.53-10.88c1.41-1.23 3.3-2.05 3.3-3.87 0-1.45-1.24-2.36-2.95-2.36-2.12 0-3.52 1.48-3.55 3.43H3.75C3.88 3.3 6.96 0 12.34 0c4.86 0 7.91 2.52 7.91 6.32 0 2.36-1.09 3.81-2.3 4.78-1.68 1.33-2.84 1.89-3.49 2.61-.5.57-.62 1.04-.65 1.95H9.45c0-2.64.65-3.9 2.36-5.34';

  var remove = 'M17.75 13.25H6.25a1.25 1.25 0 0 1 0-2.5h11.5a1.25 1.25 0 0 1 0 2.5M12 0C5.37 0 0 5.37 0 12s5.37 12 12 12 12-5.37 12-12S18.63 0 12 0';

  var report = 'M7.91 18.89A8.013 8.013 0 0 0 18.89 7.91L7.91 18.89zm-2.82-2.83L16.06 5.09A8.015 8.015 0 0 0 5.09 16.06zM12 24C5.37 24 0 18.63 0 12S5.37 0 12 0s12 5.37 12 12-5.37 12-12 12z';

  var search = 'M10 16c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6m13.12 2.88l-4.26-4.26A9.842 9.842 0 0 0 20 10c0-5.52-4.48-10-10-10S0 4.48 0 10s4.48 10 10 10c1.67 0 3.24-.41 4.62-1.14l4.26 4.26a3 3 0 0 0 4.24 0 3 3 0 0 0 0-4.24';

  var send = 'M6 6l-6 6 7.67 2.56L21 3 9.44 16.34 12 24l6-6 6-18';

  var share = 'M21 14c1.1 0 2 .9 2 2v6c0 1.1-.9 2-2 2H3c-1.1 0-2-.9-2-2v-6c0-1.1.9-2 2-2s2 .9 2 2v4h14v-4c0-1.1.9-2 2-2zM8.82 8.84c-.78.78-2.05.79-2.83 0-.78-.78-.79-2.04-.01-2.82L11.99 0l6.02 6.01c.78.78.79 2.05.01 2.83-.78.78-2.05.79-2.83 0l-1.2-1.19v6.18a2 2 0 1 1-4 0V7.66L8.82 8.84z';

  var shoppingBag = 'M9.5 5a2.5 2.5 0 0 1 5 0v2h-5V5zM17 7V5c0-2.76-2.24-5-5-5S7 2.24 7 5v2H2v15c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7h-5z';

  var smiley = 'M12.03 19.29h-.06c-3.48-.03-4.92-2.31-4.98-2.41a.896.896 0 0 1 .27-1.22.82.82 0 0 1 1.17.26c.06.08 1.06 1.58 3.57 1.59 2.51-.01 3.52-1.6 3.56-1.67.25-.41.78-.54 1.18-.28.39.26.52.8.28 1.21-.06.1-1.5 2.49-4.99 2.52zM18 9.43c0 .95-.77 1.71-1.71 1.71-.95 0-1.72-.76-1.72-1.71s.77-1.72 1.72-1.72c.94 0 1.71.77 1.71 1.72zm-12 0c0-.95.77-1.72 1.71-1.72.95 0 1.72.77 1.72 1.72s-.77 1.71-1.72 1.71c-.94 0-1.71-.76-1.71-1.71z';

  var smileyOutline = 'M12.03 19.29h-.06c-3.48-.03-4.92-2.31-4.98-2.41a.896.896 0 0 1 .27-1.22.82.82 0 0 1 1.17.26c.06.08 1.06 1.58 3.57 1.59 2.51-.01 3.52-1.6 3.56-1.67.25-.41.78-.54 1.18-.28.39.26.52.8.28 1.21-.06.1-1.5 2.49-4.99 2.52zM18 9.43c0 .95-.77 1.71-1.71 1.71-.95 0-1.72-.76-1.72-1.71s.77-1.72 1.72-1.72c.94 0 1.71.77 1.71 1.72zm-12 0c0-.95.77-1.72 1.71-1.72.95 0 1.72.77 1.72 1.72s-.77 1.71-1.72 1.71c-.94 0-1.71-.76-1.71-1.71zM12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.6 0 12 0zm0 22.2C6.45 22.2 1.8 17.7 1.8 12 1.8 6.3 6.3 1.8 12 1.8c5.7 0 10.2 4.5 10.2 10.2 0 5.7-4.65 10.2-10.2 10.2z';

  var sound = 'M20.48 3.51A11.92 11.92 0 0 1 24 12c0 3.2-1.25 6.22-3.51 8.48-.25.25-.57.37-.89.37-.32 0-.64-.12-.88-.37-.49-.48-.49-1.27 0-1.76A9.465 9.465 0 0 0 21.5 12c0-2.54-.99-4.93-2.79-6.72-.48-.49-.48-1.28 0-1.77a1.25 1.25 0 0 1 1.77 0zM5 7.94v.02L12 1v22l-7-6.09v.03H2c-1.1 0-2-.9-2-2v-5a2 2 0 0 1 2-2h3zm11.95-.89A6.96 6.96 0 0 1 19 12c0 1.87-.73 3.63-2.05 4.95-.24.24-.56.36-.88.36-.32 0-.64-.12-.89-.36a1.25 1.25 0 0 1 0-1.77c.85-.85 1.32-1.98 1.32-3.18 0-1.2-.47-2.33-1.32-3.18a1.25 1.25 0 0 1 0-1.77 1.25 1.25 0 0 1 1.77 0z';

  var speech = 'M12 0C5.85 0 .75 4.94.75 11.08c0 2.7.9 5.24 2.7 7.19L2.1 23.51c-.15.3.3.6.6.45l5.25-2.55c1.35.45 2.7.75 4.05.75 6.15 0 11.25-4.94 11.25-11.08S18.15 0 12 0';

  var speechEllipsis = 'M18 12.5a1.5 1.5 0 1 1 .001-3.001A1.5 1.5 0 0 1 18 12.5m-6 0a1.5 1.5 0 1 1 .001-3.001A1.5 1.5 0 0 1 12 12.5m-6 0a1.5 1.5 0 1 1 .001-3.001A1.5 1.5 0 0 1 6 12.5M12 0C5.925 0 1 4.925 1 11c0 2.653.94 5.086 2.504 6.986L2 24l5.336-3.049A10.93 10.93 0 0 0 12 22c6.075 0 11-4.925 11-11S18.075 0 12 0';

  var tag = 'M6 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m7.36-6.2l8.84 8.84a2.71 2.71 0 0 1 0 3.85l-7.71 7.71a2.71 2.71 0 0 1-3.85 0L1.8 13.36c-.51-.51-.8-1.2-.8-1.92V3.73C1 2.22 2.22 1 3.73 1h7.71c.72 0 1.41.29 1.92.8';

  var twitter = 'M7.548 21.5c9.056 0 14.01-7.31 14.01-13.65 0-.208 0-.414-.015-.62A9.88 9.88 0 0 0 24 4.747c-.899.388-1.852.642-2.828.754a4.838 4.838 0 0 0 2.165-2.653c-.967.559-2.024.953-3.127 1.164-1.526-1.58-3.952-1.968-5.916-.944-1.964 1.025-2.98 3.205-2.475 5.32C7.859 8.194 4.17 6.372 1.67 3.375.363 5.567 1.031 8.372 3.195 9.78a4.986 4.986 0 0 1-2.235-.6v.06c0 2.284 1.653 4.25 3.95 4.703a5.042 5.042 0 0 1-2.223.082c.645 1.954 2.494 3.293 4.6 3.332A10.048 10.048 0 0 1 0 19.345a14.21 14.21 0 0 0 7.548 2.151';

  var viewTypeDefault = 'M13.5 24V13.5H24V24H13.5zM0 10.5V0h10.5v10.5H0zm13.5 0V0H24v10.5H13.5zM0 24V13.5h10.5V24H0z';

  var viewTypeDense = 'M17.999 24H24v-6h-6.001v6zm-9-17.999V0h6v6.001H9zM0 6.001V0h6v6.001H0zm17.999 0V0H24v6.001h-6.001zM0 15.001V9h6v6H0zm9 0V9h6v6H9zm8.999 0V9H24v6h-6.001zM0 24v-6h6v6H0zm9 0v-6h6v6H9z';

  var viewTypeList = 'M0 13.502v-3h24v3H0zm0-7.5V3h24v3.002H0zm0 15v-3h24v3H0z';

  var icons = {
    add: add,
    'add-circle': addCircle,
    'add-pin': addPin,
    'angled-pin': angledPin,
    'arrow-back': arrowBack,
    'arrow-circle-down': arrowCircleDown,
    'arrow-circle-forward': arrowCircleForward,
    'arrow-down': arrowDown,
    'arrow-forward': arrowForward,
    'arrow-up': arrowUp,
    'arrow-up-right': arrowUpRight,
    bell: bell,
    camera: camera,
    'camera-roll': cameraRoll,
    cancel: cancel,
    check: check,
    'check-circle': checkCircle,
    'circle-outline': circleOutline,
    clear: clear,
    clock: clock,
    cog: cog,
    compass: compass,
    dash: dash,
    edit: edit,
    ellipsis: ellipsis,
    'ellipsis-circle-outline': ellipsisCircleOutline,
    envelope: envelope,
    eye: eye,
    facebook: facebook,
    'face-happy': faceHappy,
    'face-sad': faceSad,
    'face-smiley': faceSmiley,
    filter: filter,
    flag: flag,
    flashlight: flashlight,
    gif: gif,
    globe: globe,
    'globe-checked': globeChecked,
    gmail: gmail,
    'google-plus': googlePlus,
    'graph-bar': graphBar,
    handle: handle,
    'hand-pointing': handPointing,
    heart: heart,
    'heart-broken': heartBroken,
    knoop: knoop,
    lightbulb: lightbulb,
    link: link,
    location: location,
    lock: lock,
    maximize: maximize,
    megaphone: megaphone,
    menu: menu,
    minimize: minimize,
    move: move,
    mute: mute,
    pause: pause,
    people: people,
    person: person,
    'person-add': personAdd,
    pin: pin,
    'pin-hide': pinHide,
    pinterest: pinterest,
    play: play,
    'question-mark': questionMark,
    remove: remove,
    report: report,
    search: search,
    'shopping-bag': shoppingBag,
    smiley: smiley,
    'smiley-outline': smileyOutline,
    send: send,
    share: share,
    sound: sound,
    speech: speech,
    'speech-ellipsis': speechEllipsis,
    tag: tag,
    twitter: twitter,
    'view-type-default': viewTypeDefault,
    'view-type-dense': viewTypeDense,
    'view-type-list': viewTypeList
  };

  var IconNames = Object.keys(icons);

  function Icon(props) {
    var accessibilityLabel = props.accessibilityLabel,
        _props$color = props.color,
        color = _props$color === undefined ? 'gray' : _props$color,
        icon = props.icon,
        inline = props.inline,
        _props$size = props.size,
        size = _props$size === undefined ? 16 : _props$size,
        dangerouslySetSvgPath = props.dangerouslySetSvgPath;


    var cs = classnames(styles$1.icon, colors[color], defineProperty({}, styles$1.iconBlock, !inline));

    var path = icon && icons[icon] ||
    /* eslint-disable-next-line no-underscore-dangle */
    dangerouslySetSvgPath && dangerouslySetSvgPath.__path || undefined;

    var ariaHidden = accessibilityLabel === '' ? true : null;

    return React.createElement(
      'svg',
      {
        className: cs,
        height: size,
        width: size,
        viewBox: '0 0 24 24',
        'aria-hidden': ariaHidden,
        'aria-label': accessibilityLabel,
        role: 'img'
      },
      React.createElement(
        'title',
        null,
        accessibilityLabel
      ),
      React.createElement('path', { d: path })
    );
  }

  Icon.icons = IconNames;

  Icon.propTypes = {
    accessibilityLabel: PropTypes.string.isRequired,
    color: PropTypes.oneOf(['blue', 'darkGray', 'eggplant', 'gray', 'green', 'lightGray', 'maroon', 'midnight', 'navy', 'olive', 'orange', 'orchid', 'pine', 'purple', 'red', 'watermelon', 'white']),
    dangerouslySetSvgPath: PropTypes.shape({
      __path: PropTypes.string
    }),
    icon: PropTypes.oneOf(IconNames),
    inline: PropTypes.bool,
    size: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
  };

  var styles$2 = { "img": "_u3 _45 _y7 _4h", "scaled-img": "_u4 _4f", "contain": "_u5 _u4 _4f", "cover": "_u6 _u4 _4f" };

  var shouldScaleImage = function shouldScaleImage(fit) {
    return fit === 'cover' || fit === 'contain';
  };

  var Image = function (_React$PureComponent) {
    inherits(Image, _React$PureComponent);

    function Image() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Image);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Image.__proto__ || Object.getPrototypeOf(Image)).call.apply(_ref, [this].concat(args))), _this), _this.handleLoad = function () {
        if (_this.props.onLoad) {
          _this.props.onLoad();
        }
      }, _this.handleError = function () {
        if (_this.props.onError) {
          _this.props.onError();
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Image, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        if (shouldScaleImage(this.props.fit)) {
          this.loadImage();
        }
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps) {
        var _props = this.props,
            fit = _props.fit,
            src = _props.src;

        if (shouldScaleImage(fit) && prevProps.src !== src) {
          this.loadImage();
        }
      }
    }, {
      key: 'loadImage',
      value: function loadImage() {
        if (typeof window !== 'undefined') {
          var image = new window.Image();
          image.onload = this.handleLoad;
          image.onerror = this.handleError;
          image.src = this.props.src;
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var _props2 = this.props,
            alt = _props2.alt,
            color = _props2.color,
            children = _props2.children,
            fit = _props2.fit,
            naturalHeight = _props2.naturalHeight,
            naturalWidth = _props2.naturalWidth,
            sizes = _props2.sizes,
            src = _props2.src,
            srcSet = _props2.srcSet;


        var isScaledImage = shouldScaleImage(fit);
        var childContent = children ? React.createElement(
          Box,
          { position: 'absolute', top: true, left: true, bottom: true, right: true, overflow: 'hidden' },
          children
        ) : null;

        return isScaledImage ? React.createElement(
          'div',
          {
            'aria-label': alt,
            className: styles$2[fit],
            style: {
              backgroundColor: color,
              backgroundImage: 'url(\'' + src + '\')'
            },
            role: 'img'
          },
          childContent
        ) : React.createElement(
          Box,
          {
            position: 'relative',
            dangerouslySetInlineStyle: {
              __style: {
                backgroundColor: color,
                paddingBottom: naturalHeight / naturalWidth * 100 + '%'
              }
            }
          },
          React.createElement('img', {
            alt: alt,
            className: styles$2.img,
            onError: this.handleError,
            onLoad: this.handleLoad,
            sizes: sizes,
            src: src,
            srcSet: srcSet
          }),
          childContent
        );
      }
    }]);
    return Image;
  }(React.PureComponent);

  Image.propTypes = {
    alt: PropTypes.string.isRequired,
    children: PropTypes.node,
    color: PropTypes.string,
    fit: PropTypes.oneOf(['contain', 'cover', 'none']),
    naturalHeight: PropTypes.number.isRequired,
    naturalWidth: PropTypes.number.isRequired,
    onError: PropTypes.func,
    onLoad: PropTypes.func,
    sizes: PropTypes.string,
    src: PropTypes.string.isRequired,
    srcSet: PropTypes.string
  };
  Image.defaultProps = {
    color: 'transparent',
    fit: 'none'
  };

  var styles$3 = { "Mask": "_ub _49 _4f", "square": "_uc _2v", "rounded": "_ud _2y", "circle": "_ue _2w", "wash": "_uf _4h _4l _4m _4k _4j" };

  function Mask(props) {
    var children = props.children,
        _props$shape = props.shape,
        shape = _props$shape === undefined ? 'square' : _props$shape,
        width = props.width,
        height = props.height,
        _props$wash = props.wash,
        wash = _props$wash === undefined ? false : _props$wash;

    return React.createElement(
      'div',
      { className: classnames(styles$3.Mask, styles$3[shape]), style: { width: width, height: height } },
      children,
      wash && React.createElement('div', { className: styles$3.wash })
    );
  }

  Mask.propTypes = {
    children: PropTypes.node,
    height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    shape: PropTypes.oneOf(['circle', 'rounded', 'square']),
    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    wash: PropTypes.bool
  };

  var typography = { "antialiased": "_0", "sansSerif": "_1", "letterSpacing": "_2", "leadingShort": "_3", "leadingTall": "_4", "fontWeightNormal": "_5", "fontWeightBold": "_6", "fontStyleRegular": "_7", "fontStyleItalic": "_8", "underline": "_9", "noUnderline": "_a", "breakWord": "_b", "truncate": "_c", "alignLeft": "_d", "alignRight": "_e", "alignCenter": "_f", "textJustify": "_g" };

  var Square = function Square(props) {
    return React.createElement(
      Box,
      _extends({}, props, { position: 'relative' }),
      React.createElement(Box, {
        dangerouslySetInlineStyle: { __style: { paddingBottom: '100%' } },
        position: 'relative'
      }),
      React.createElement(
        Box,
        { position: 'absolute', top: true, left: true, bottom: true, right: true },
        props.children
      )
    );
  };

  var DefaultAvatar = function DefaultAvatar(_ref) {
    var name = _ref.name;

    var firstInitial = name ? [].concat(toConsumableArray(name))[0].toUpperCase() : '';
    return React.createElement(
      Square,
      { color: 'gray', shape: 'circle' },
      firstInitial && React.createElement(
        'svg',
        {
          width: '100%',
          viewBox: '-50 -50 100 100',
          version: '1.1',
          preserveAspectRatio: 'xMidYMid meet',
          xmlns: 'http://www.w3.org/2000/svg'
        },
        React.createElement(
          'title',
          null,
          name
        ),
        React.createElement(
          'text',
          {
            fontSize: '50px',
            fill: '#fff',
            dominantBaseline: 'central',
            textAnchor: 'middle',
            className: [typography.antialiased, typography.sansSerif, typography.leadingSmall, typography.fontWeightBold].join(' ')
          },
          firstInitial
        )
      )
    );
  };

  var sizes = {
    sm: 24,
    md: 40,
    lg: 72
  };

  var Avatar = function (_React$PureComponent) {
    inherits(Avatar, _React$PureComponent);

    function Avatar() {
      var _ref2;

      var _temp, _this, _ret;

      classCallCheck(this, Avatar);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref2 = Avatar.__proto__ || Object.getPrototypeOf(Avatar)).call.apply(_ref2, [this].concat(args))), _this), _this.state = {
        isImageLoaded: true
      }, _this.handleImageError = function () {
        return _this.setState({ isImageLoaded: false });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Avatar, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            name = _props.name,
            outline = _props.outline,
            size = _props.size,
            src = _props.src,
            verified = _props.verified;
        var isImageLoaded = this.state.isImageLoaded;

        var width = size ? sizes[size] : '100%';
        var height = size ? sizes[size] : '';
        return React.createElement(
          Box,
          _extends({
            color: 'white'
          }, outline ? {
            dangerouslySetInlineStyle: {
              __style: {
                boxShadow: '0 0 0 2px #fff'
              }
            }
          } : {}, {
            width: width,
            height: height,
            position: 'relative',
            shape: 'circle'
          }),
          src && isImageLoaded ? React.createElement(
            Mask,
            { shape: 'circle', wash: true },
            React.createElement(Image, {
              alt: name,
              color: '#EFEFEF',
              naturalHeight: 1,
              naturalWidth: 1,
              src: src,
              onError: this.handleImageError
            })
          ) : React.createElement(DefaultAvatar, { name: name }),
          verified && React.createElement(
            Box,
            {
              position: 'absolute',
              width: '20%',
              height: '20%',
              minWidth: 8,
              minHeight: 8,
              dangerouslySetInlineStyle: {
                __style: {
                  bottom: '4%',
                  right: '4%'
                }
              }
            },
            React.createElement(
              Box,
              {
                color: 'white',
                width: '100%',
                height: '100%',
                shape: 'circle',
                dangerouslySetInlineStyle: {
                  __style: {
                    boxShadow: '0 0 0 2px #fff'
                  }
                }
              },
              React.createElement(Icon, {
                color: 'red',
                icon: 'check-circle',
                accessibilityLabel: '',
                size: '100%'
              })
            )
          )
        );
      }
    }]);
    return Avatar;
  }(React.PureComponent);

  Avatar.propTypes = {
    name: PropTypes.string.isRequired,
    outline: PropTypes.bool,
    src: PropTypes.string,
    size: PropTypes.oneOf(['sm', 'md', 'lg']),
    verified: PropTypes.bool
  };

  var styles$4 = { "button": "_r3 _4q", "solid": "_r4 _33", "enabled": "_r5 _xt _z8", "sm": "_r6 _4n", "md": "_r7 _4o", "lg": "_r8 _4p", "block": "_r9 _y7 _45", "inline": "_ra _47", "disabled": "_rb _39", "gray": "_rc _39", "red": "_rd _35", "blue": "_re _3l", "transparent": "_rf _42", "white": "_rg _37" };

  var styles$5 = { "Text": "_w6 _0 _1 _2", "fontSize1": "_w7", "fontSize2": "_w8", "fontSize3": "_w9", "fontSize4": "_wa", "fontSize5": "_wb", "smFontSize1": "_wc", "smFontSize2": "_wd", "smFontSize3": "_we", "smFontSize4": "_wf", "smFontSize5": "_wg", "mdFontSize1": "_wh", "mdFontSize2": "_wi", "mdFontSize3": "_wj", "mdFontSize4": "_wk", "mdFontSize5": "_wl", "lgFontSize1": "_wm", "lgFontSize2": "_wn", "lgFontSize3": "_wo", "lgFontSize4": "_wp", "lgFontSize5": "_wq" };

  var SIZE_SCALE = {
    xs: 1,
    sm: 2,
    md: 3,
    lg: 4,
    xl: 5
  };

  function Text(_ref) {
    var _ref$align = _ref.align,
        align = _ref$align === undefined ? 'left' : _ref$align,
        _ref$bold = _ref.bold,
        bold = _ref$bold === undefined ? false : _ref$bold,
        children = _ref.children,
        _ref$color = _ref.color,
        color = _ref$color === undefined ? 'darkGray' : _ref$color,
        _ref$inline = _ref.inline,
        inline = _ref$inline === undefined ? false : _ref$inline,
        _ref$italic = _ref.italic,
        italic = _ref$italic === undefined ? false : _ref$italic,
        _ref$overflow = _ref.overflow,
        overflow = _ref$overflow === undefined ? 'breakWord' : _ref$overflow,
        _ref$size = _ref.size,
        size = _ref$size === undefined ? 'md' : _ref$size,
        smSize = _ref.smSize,
        mdSize = _ref.mdSize,
        lgSize = _ref.lgSize,
        _ref$leading = _ref.leading,
        leading = _ref$leading === undefined ? 'short' : _ref$leading,
        _ref$truncate = _ref.truncate,
        truncate = _ref$truncate === undefined ? false : _ref$truncate,
        _ref$__dangerouslyInc = _ref.__dangerouslyIncreaseLineHeight,
        __dangerouslyIncreaseLineHeight = _ref$__dangerouslyInc === undefined ? false : _ref$__dangerouslyInc;

    var scale = SIZE_SCALE[size];
    var smScale = SIZE_SCALE[smSize];
    var mdScale = SIZE_SCALE[mdSize];
    var lgScale = SIZE_SCALE[lgSize];

    var cs = classnames(styles$5.Text, styles$5['fontSize' + scale], lgSize && styles$5['lgFontSize' + lgScale], mdSize && styles$5['mdFontSize' + mdScale], smSize && styles$5['smFontSize' + smScale], color === 'blue' && colors.blue, color === 'darkGray' && colors.darkGray, color === 'eggplant' && colors.eggplant, color === 'gray' && colors.gray, color === 'green' && colors.green, color === 'lightGray' && colors.lightGray, color === 'maroon' && colors.maroon, color === 'midnight' && colors.midnight, color === 'navy' && colors.navy, color === 'olive' && colors.olive, color === 'orange' && colors.orange, color === 'orchid' && colors.orchid, color === 'pine' && colors.pine, color === 'purple' && colors.purple, color === 'red' && colors.red, color === 'watermelon' && colors.watermelon, color === 'white' && colors.white, leading === 'short' && typography.leadingShort, (leading === 'tall' || __dangerouslyIncreaseLineHeight) && typography.leadingTall, align === 'center' && typography.alignCenter, align === 'justify' && typography.alignJustify, align === 'left' && typography.alignLeft, align === 'right' && typography.alignRight, overflow === 'breakWord' && typography.breakWord, italic && typography.fontStyleItalic, !italic && typography.fontStyleNormal, bold && typography.fontWeightBold, !bold && typography.fontWeightNormal, truncate && typography.truncate);
    var Tag = inline ? 'span' : 'div';

    return React.createElement(
      Tag,
      _extends({
        className: cs
      }, truncate && typeof children === 'string' ? { title: children } : null),
      children
    );
  }

  Text.propTypes = {
    __dangerouslyIncreaseLineHeight: PropTypes.bool,
    align: PropTypes.oneOf(['left', 'right', 'center', 'justify']),
    bold: PropTypes.bool,
    children: PropTypes.node,
    color: PropTypes.oneOf(['green', 'pine', 'olive', 'blue', 'navy', 'midnight', 'purple', 'orchid', 'eggplant', 'maroon', 'watermelon', 'orange', 'darkGray', 'gray', 'lightGray', 'red', 'white']),
    inline: PropTypes.bool,
    italic: PropTypes.bool,
    leading: PropTypes.oneOf(['tall', 'short']),
    lgSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
    mdSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
    overflow: PropTypes.oneOf(['normal', 'breakWord']),
    size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
    smSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
    truncate: PropTypes.bool
  };

  function Button(props) {
    var _classnames;

    var accessibilityExpanded = props.accessibilityExpanded,
        accessibilityHaspopup = props.accessibilityHaspopup,
        accessibilityLabel = props.accessibilityLabel,
        _props$color = props.color,
        color = _props$color === undefined ? 'gray' : _props$color,
        _props$disabled = props.disabled,
        disabled = _props$disabled === undefined ? false : _props$disabled,
        _props$inline = props.inline,
        inline = _props$inline === undefined ? false : _props$inline,
        name = props.name,
        onClick = props.onClick,
        _props$size = props.size,
        size = _props$size === undefined ? 'md' : _props$size,
        text = props.text,
        _props$type = props.type,
        type = _props$type === undefined ? 'button' : _props$type;


    var textColor = {
      blue: 'white',
      gray: 'darkGray',
      red: 'white',
      transparent: 'white',
      white: 'darkGray'
    };

    var classes = classnames(styles$4.button, (_classnames = {}, defineProperty(_classnames, styles$4.sm, size === 'sm'), defineProperty(_classnames, styles$4.md, size === 'md'), defineProperty(_classnames, styles$4.lg, size === 'lg'), defineProperty(_classnames, styles$4.solid, color !== 'transparent'), defineProperty(_classnames, styles$4[color], !disabled), defineProperty(_classnames, styles$4.disabled, disabled), defineProperty(_classnames, styles$4.enabled, !disabled), defineProperty(_classnames, styles$4.inline, inline), defineProperty(_classnames, styles$4.block, !inline), _classnames));

    /* eslint-disable react/button-has-type */
    return React.createElement(
      'button',
      {
        'aria-expanded': accessibilityExpanded,
        'aria-haspopup': accessibilityHaspopup,
        'aria-label': accessibilityLabel,
        className: classes,
        disabled: disabled,
        name: name,
        onClick: function (_onClick) {
          function onClick(_x) {
            return _onClick.apply(this, arguments);
          }

          onClick.toString = function () {
            return _onClick.toString();
          };

          return onClick;
        }(function (event) {
          return onClick && onClick({ event: event });
        }),
        type: type
      },
      React.createElement(
        Text,
        {
          align: 'center',
          bold: true,
          color: disabled ? 'gray' : textColor[color],
          overflow: 'normal',
          size: size
        },
        text
      )
    );
    /* eslint-enable react/button-has-type */
  }

  Button.propTypes = {
    accessibilityExpanded: PropTypes.bool,
    accessibilityHaspopup: PropTypes.bool,
    accessibilityLabel: PropTypes.string,
    color: PropTypes.oneOf(['blue', 'gray', 'red', 'transparent', 'white']),
    disabled: PropTypes.bool,
    inline: PropTypes.bool,
    name: PropTypes.string,
    onClick: PropTypes.func,
    size: PropTypes.oneOf(['sm', 'md', 'lg']),
    text: PropTypes.string.isRequired,
    type: PropTypes.oneOf(['button', 'submit'])
  };

  var styles$6 = { "card": "_rh _4h _2y _4j _4k _4l _4m _4r", "hover": "_ri", "animateIn": "_rj" };

  var Card = function (_React$Component) {
    inherits(Card, _React$Component);

    function Card() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Card);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Card.__proto__ || Object.getPrototypeOf(Card)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        hovered: false
      }, _this.handleMouseEnter = function (event) {
        var onMouseEnter = _this.props.onMouseEnter;

        _this.setState({ hovered: true }, onMouseEnter && function () {
          return onMouseEnter({ event: event });
        });
      }, _this.handleMouseLeave = function (event) {
        var onMouseLeave = _this.props.onMouseLeave;

        _this.setState({ hovered: false }, onMouseLeave && function () {
          return onMouseLeave({ event: event });
        });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Card, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            active = _props.active,
            children = _props.children,
            image = _props.image;
        var hovered = this.state.hovered;


        var classes = classnames(styles$6.card, defineProperty({}, styles$6.hover, active || active == null && hovered));

        return React.createElement(
          Box,
          {
            onMouseEnter: this.handleMouseEnter,
            onMouseLeave: this.handleMouseLeave,
            position: 'relative'
          },
          image && React.createElement(
            Box,
            { marginBottom: 1 },
            image
          ),
          React.createElement(
            Box,
            null,
            children
          ),
          React.createElement('div', { className: classes })
        );
      }
    }]);
    return Card;
  }(React.Component);

  Card.propTypes = {
    active: PropTypes.bool,
    children: PropTypes.node,
    image: PropTypes.node,
    onMouseEnter: PropTypes.func,
    onMouseLeave: PropTypes.func
  };

  var styles$7 = { "border": "_rk", "borderError": "_rl", "borderDark": "_rm", "check": "_rn _45 _4q _4s _50 _5a", "checkEnabled": "_ro _z8", "checkFocused": "_rp _xu", "checkSm": "_rq", "checkMd": "_rr", "input": "_rs _4h _od", "inputEnabled": "_rt _z8", "inputSm": "_ru", "inputMd": "_rv" };

  var Checkbox = function (_React$Component) {
    inherits(Checkbox, _React$Component);

    function Checkbox() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Checkbox);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Checkbox.__proto__ || Object.getPrototypeOf(Checkbox)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        focused: false
      }, _this.handleChange = function (event) {
        var checked = event.target.checked;

        _this.props.onChange({ event: event, checked: checked });
      }, _this.handleBlur = function () {
        return _this.setState({ focused: false });
      }, _this.handleFocus = function () {
        return _this.setState({ focused: true });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Checkbox, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        if (this.props.indeterminate) {
          this.setIndeterminate(!!this.props.indeterminate);
        }
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(previousProps) {
        if (previousProps.indeterminate !== this.props.indeterminate) {
          this.setIndeterminate(!!this.props.indeterminate);
        }
      }
    }, {
      key: 'setIndeterminate',
      value: function setIndeterminate(indeterminate) {
        if (this.input) {
          this.input.indeterminate = indeterminate;
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var _classnames,
            _this2 = this,
            _classnames2;

        var _props = this.props,
            checked = _props.checked,
            disabled = _props.disabled,
            hasError = _props.hasError,
            id = _props.id,
            indeterminate = _props.indeterminate,
            name = _props.name,
            size = _props.size;


        var borderStyle = styles$7.border;
        if (!disabled && (checked || indeterminate)) {
          borderStyle = styles$7.borderDark;
        } else if (hasError) {
          borderStyle = styles$7.borderError;
        }

        return React.createElement(
          Box,
          { position: 'relative' },
          React.createElement('input', {
            checked: checked,
            className: classnames(styles$7.input, (_classnames = {}, defineProperty(_classnames, styles$7.inputEnabled, !disabled), defineProperty(_classnames, styles$7.indeterminate, indeterminate), defineProperty(_classnames, styles$7.inputSm, size === 'sm'), defineProperty(_classnames, styles$7.inputMd, size === 'md'), _classnames)),
            disabled: disabled,
            id: id,
            name: name,
            onBlur: this.handleBlur,
            onChange: this.handleChange,
            onFocus: this.handleFocus,
            ref: function ref(el) {
              _this2.input = el;
            },
            type: 'checkbox'
          }),
          React.createElement(
            'div',
            {
              className: classnames(borderStyle, styles$7.check,
              // eslint-disable-next-line no-nested-ternary
              disabled ? checked || indeterminate ? colors.grayBg : colors.lightGrayBg : checked || indeterminate ? colors.darkGrayBg : colors.whiteBg, (_classnames2 = {}, defineProperty(_classnames2, styles$7.checkEnabled, !disabled), defineProperty(_classnames2, styles$7.checkFocused, this.state.focused), defineProperty(_classnames2, styles$7.checkMd, size === 'md'), defineProperty(_classnames2, styles$7.checkSm, size === 'sm'), _classnames2))
            },
            (checked || indeterminate) && React.createElement(Icon, {
              accessibilityLabel: '',
              color: 'white',
              icon: indeterminate ? 'dash' : 'check',
              size: size === 'sm' ? 8 : 12
            })
          )
        );
      }
    }]);
    return Checkbox;
  }(React.Component);

  Checkbox.propTypes = {
    checked: PropTypes.bool,
    disabled: PropTypes.bool,
    hasError: PropTypes.bool,
    id: PropTypes.string.isRequired,
    indeterminate: PropTypes.bool,
    name: PropTypes.string,
    onChange: PropTypes.func.isRequired,
    size: PropTypes.oneOf(['sm', 'md'])
  };
  Checkbox.defaultProps = {
    checked: false,
    disabled: false,
    hasError: false,
    indeterminate: false,
    size: 'md'
  };

  var Collection = function (_React$PureComponent) {
    inherits(Collection, _React$PureComponent);

    function Collection() {
      classCallCheck(this, Collection);
      return possibleConstructorReturn(this, (Collection.__proto__ || Object.getPrototypeOf(Collection)).apply(this, arguments));
    }

    createClass(Collection, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            Item = _props.Item,
            layout$$1 = _props.layout,
            _props$viewportTop = _props.viewportTop,
            viewportTop = _props$viewportTop === undefined ? 0 : _props$viewportTop,
            _props$viewportLeft = _props.viewportLeft,
            viewportLeft = _props$viewportLeft === undefined ? 0 : _props$viewportLeft;

        // Calculate the full dimensions of the item layer

        var width = Math.max.apply(Math, toConsumableArray(layout$$1.map(function (item) {
          return item.left + item.width;
        })));
        var height = Math.max.apply(Math, toConsumableArray(layout$$1.map(function (item) {
          return item.top + item.height;
        })));

        // Default the viewport to being the full width of the content layer
        var _props2 = this.props,
            _props2$viewportWidth = _props2.viewportWidth,
            viewportWidth = _props2$viewportWidth === undefined ? width : _props2$viewportWidth,
            _props2$viewportHeigh = _props2.viewportHeight,
            viewportHeight = _props2$viewportHeigh === undefined ? height : _props2$viewportHeigh;

        // Calculates which items from the item layer to render in the viewport
        // layer.

        var items = layout$$1.reduce(function (acc, position, idx) {
          if (position.top + position.height > viewportTop && position.top < viewportHeight + viewportTop && position.left < viewportWidth + viewportLeft && position.left + position.width > viewportLeft) {
            acc.push(_extends({ idx: idx }, position));
          }
          return acc;
        }, []);

        return React.createElement(
          'div',
          { className: layout.relative, style: { width: width, height: height } },
          items.map(function (_ref) {
            var idx = _ref.idx,
                style = objectWithoutProperties(_ref, ['idx']);
            return React.createElement(
              'div',
              { key: idx, className: layout.absolute, style: style },
              React.createElement(Item, { idx: idx })
            );
          })
        );
      }
    }]);
    return Collection;
  }(React.PureComponent);

  Collection.propTypes = {
    // eslint-disable-next-line react/forbid-prop-types
    Item: PropTypes.any,
    layout: PropTypes.arrayOf(PropTypes.exact({
      top: PropTypes.number.isRequired,
      left: PropTypes.number.isRequired,
      width: PropTypes.number.isRequired,
      height: PropTypes.number.isRequired
    }).isRequired),
    viewportHeight: PropTypes.number,
    viewportLeft: PropTypes.number,
    viewportTop: PropTypes.number,
    viewportWidth: PropTypes.number
  };
  Collection.defaultProps = {
    layout: [],
    viewportLeft: 0,
    viewportTop: 0
  };

  /*

  This function just implements the design constraints for asymetrical columns in
  a very simple way. It's not perfect, but it's very predictible. If you do
  anything, improve it so that it takes these constraints and generates them
  for n > 4.

  1 + n columns:
    first column is 50/50
    can't have 3 columns in a row be 50/50

  */
  var UP = [0.75, 0.25];
  var DOWN = [0.25, 0.75];
  var MID = [0.5, 0.5];
  var columnLayout = function columnLayout(numOfColumns) {
    switch (numOfColumns) {
      case 1:
        return [[MID], [UP], [DOWN]];
      case 2:
        return [[UP, MID], [DOWN, MID], [MID, UP], [MID, DOWN]];
      case 4:
        return [[MID, UP, MID, MID], [MID, DOWN, MID, MID], [MID, MID, UP, MID], [MID, MID, DOWN, MID], [MID, UP, MID, DOWN], [MID, DOWN, MID, UP]];
      case 3:
      default:
        return [[MID, UP, MID], [MID, DOWN, MID], [MID, MID, UP], [MID, MID, DOWN]];
    }
  };

  var paddingAll = function paddingAll(gutter, positions) {
    return positions.map(function (_ref) {
      var top = _ref.top,
          left = _ref.left,
          width = _ref.width,
          height = _ref.height;
      return {
        top: top,
        left: left,
        width: width - gutter,
        height: height - gutter
      };
    });
  };

  var mindex = function mindex(arr) {
    return arr.reduce(function (minIndex, item, i) {
      return item < arr[minIndex] ? i : minIndex;
    }, 0);
  };

  var columnsForCollageWithCover = function columnsForCollageWithCover(numOfColumns) {
    return numOfColumns === 4 ? 2 : 1;
  };

  function getCollageLayout(_ref2) {
    var gutter = _ref2.gutter,
        cover = _ref2.cover,
        numCols = _ref2.columns,
        h = _ref2.height,
        w = _ref2.width,
        layoutKey = _ref2.layoutKey;

    var positions = [];
    var width = w + gutter;
    var height = h + gutter;

    // If there's a cover image, we'll add that later. It should be a little
    // less than half the width of the collage. We do this now (and not later
    // when we add the cover image) because of `columnLayout`'s constraints
    // needing the exact number of columns that are displayed.
    var gridCols = cover ? columnsForCollageWithCover(numCols) : numCols;

    // Selects the layout that we're going to use for the grid
    var columns = columnLayout(gridCols);
    var layoutIdx = layoutKey % columns.length;
    var layout = columns[layoutIdx];

    // This does a really simple version of our masonry layout. Why replicate
    // that here? a.) fewer dependencies and b.) we need the algorithm to
    // roughly preserve the order of the collages from when they were ordered
    // by Masonry.
    var colHeights = new Array(gridCols).fill(0);
    var colCounts = new Array(gridCols).fill(0);

    // We iterate over every position that we think we could _potentially_ have
    // so that we can fill them with empty sections if need be.
    for (var i = 0; i < 2 * gridCols; i += 1) {
      var col = mindex(colHeights);
      var colIdx = colCounts[col];
      var itemHeight = layout[col][colIdx] * height;

      positions.push({
        top: colHeights[col],
        left: col * (width / numCols),
        width: width / numCols,
        height: itemHeight
      });

      colHeights[col] += itemHeight;
      colCounts[col] += 1;
    }

    // If we have a cover image, figure out how big it is, then move all the
    // existing columns over.
    if (cover) {
      var coverImageWidth = Math.ceil(numCols / 2) * (width / numCols);
      positions = positions.map(function (position) {
        return _extends({}, position, {
          left: coverImageWidth + position.left
        });
      });
      positions.unshift({ top: 0, left: 0, width: coverImageWidth, height: height });
    }

    // This adds the space between any items that we have. It's nice to do
    // this as a separate pass after everything else, because the math earlier
    // becomes easier and it's less brittle to change.
    if (gutter) {
      positions = paddingAll(gutter, positions);
    }

    return positions;
  }

  function Collage(props) {
    var columns = props.columns,
        cover = props.cover,
        gutter = props.gutter,
        height = props.height,
        layoutKey = props.layoutKey,
        renderImage = props.renderImage,
        width = props.width;

    var positions = getCollageLayout({
      columns: columns,
      cover: !!cover,
      width: width,
      height: height,
      gutter: gutter || 0,
      layoutKey: layoutKey || 0
    });
    return React.createElement(Collection, {
      Item: function Item(_ref3) {
        var index = _ref3.idx;
        return renderImage({
          index: index,
          width: positions[index].width,
          height: positions[index].height
        });
      },
      layout: positions
    });
  }

  Collage.propTypes = {
    columns: PropTypes.oneOf([2, 3, 4]).isRequired,
    cover: PropTypes.bool,
    gutter: PropTypes.number,
    height: PropTypes.number.isRequired,
    layoutKey: PropTypes.number,
    renderImage: PropTypes.func.isRequired,
    width: PropTypes.number.isRequired
  };

  var styles$8 = { "deprecatedColumn": "_rw", "xsCol0": "_rx", "xsCol1": "_ry _xw", "xsCol2": "_rz _xx", "xsCol3": "_s0 _xy", "xsCol4": "_s1 _xz", "xsCol5": "_s2 _y0", "xsCol6": "_s3 _y1", "xsCol7": "_s4 _y2", "xsCol8": "_s5 _y3", "xsCol9": "_s6 _y4", "xsCol10": "_s7 _y5", "xsCol11": "_s8 _y6", "xsCol12": "_s9 _y7", "smCol0": "_sa", "smCol1": "_sb _y8", "smCol2": "_sc _y9", "smCol3": "_sd _ya", "smCol4": "_se _yb", "smCol5": "_sf _yc", "smCol6": "_sg _yd", "smCol7": "_sh _ye", "smCol8": "_si _yf", "smCol9": "_sj _yg", "smCol10": "_sk _yh", "smCol11": "_sl _yi", "smCol12": "_sm _yj", "mdCol0": "_sn", "mdCol1": "_so _yk", "mdCol2": "_sp _yl", "mdCol3": "_sq _ym", "mdCol4": "_sr _yn", "mdCol5": "_ss _yo", "mdCol6": "_st _yp", "mdCol7": "_su _yq", "mdCol8": "_sv _yr", "mdCol9": "_sw _ys", "mdCol10": "_sx _yt", "mdCol11": "_sy _yu", "mdCol12": "_sz _yv", "lgCol0": "_t0", "lgCol1": "_t1 _yw", "lgCol2": "_t2 _yx", "lgCol3": "_t3 _yy", "lgCol4": "_t4 _yz", "lgCol5": "_t5 _z0", "lgCol6": "_t6 _z1", "lgCol7": "_t7 _z2", "lgCol8": "_t8 _z3", "lgCol9": "_t9 _z4", "lgCol10": "_ta _z5", "lgCol11": "_tb _z6", "lgCol12": "_tc _z7" };

  function Column(props) {
    var children = props.children;

    var cs = classnames((props.xs !== undefined || props.sm !== undefined || props.md !== undefined || props.lg !== undefined) && styles$8.deprecatedColumn, props.xs && styles$8['xsCol' + props.xs], props.sm && styles$8['smCol' + props.sm], props.md && styles$8['mdCol' + props.md], props.lg && styles$8['lgCol' + props.lg], props.span != null && styles$8['xsCol' + props.span], props.smSpan != null && styles$8['smCol' + props.smSpan], props.mdSpan != null && styles$8['mdCol' + props.mdSpan], props.lgSpan != null && styles$8['lgCol' + props.lgSpan]);
    return React.createElement(
      'div',
      { className: cs },
      children
    );
  }

  Column.propTypes = {
    children: PropTypes.node,
    xs: PropTypes.number,
    sm: PropTypes.number,
    md: PropTypes.number,
    lg: PropTypes.number,
    span: PropTypes.number,
    smSpan: PropTypes.number,
    mdSpan: PropTypes.number,
    lgSpan: PropTypes.number
  };

  function Container(props) {
    var children = props.children;

    return React.createElement(
      Box,
      { justifyContent: 'center', display: 'flex' },
      React.createElement(
        Box,
        { maxWidth: 800, width: '100%' },
        children
      )
    );
  }

  Container.propTypes = {
    children: PropTypes.node
  };

  var styles$9 = { "divider": "_td _45 _2r _od" };

  function Divider() {
    return React.createElement('hr', { className: styles$9.divider });
  }

  function Caret(props) {
    var direction = props.direction;

    var path = void 0;
    switch (direction) {
      case 'up':
        path = 'M0 0 L12 12 L24 0';
        break;
      case 'right':
        path = 'M24 0 L12 12 L24 24';
        break;
      case 'down':
        path = 'M0 24 L12 12 L24 24';
        break;
      case 'left':
        path = 'M0 0 L12 12 L0 24';
        break;
      default:
    }

    return React.createElement(
      'svg',
      { width: '24', height: '24' },
      React.createElement('path', { d: path })
    );
  }

  Caret.propTypes = {
    direction: PropTypes.oneOf(['up', 'right', 'down', 'left'])
  };

  var styles$a = { "container": "_xo _4h", "contents": "_xp _4h _45 _4q _2y", "dimensions": "_xq", "innerContents": "_xr _4s _4d _2y", "caret": "_xs _4h" };

  /* Needed until this Flow issue is fixed: https://github.com/facebook/flow/issues/380 */
  /* eslint quote-props: 0 */
  var SPACES_INDEX_MAP = {
    '0': 'up',
    '1': 'right',
    '2': 'down',
    '3': 'left'
  };

  var DIR_INDEX_MAP = {
    up: 0,
    right: 1,
    down: 2,
    left: 3
  };

  var MARGIN = 24;
  var CARET_HEIGHT = 24;
  var CARET_OFFSET_FROM_SIDE = 24;
  var BORDER_RADIUS = 8;

  /**
   * Determines the main direction the flyout opens
   */
  function getMainDir(flyoutSize, idealDirection, triggerRect, windowSize) {
    // Calculates the available space if we were to place the flyout in the 4 main directions
    // to determine which 'quadrant' to position the flyout inside of
    var up = triggerRect.top - flyoutSize.height - CARET_HEIGHT;
    var right = windowSize.width - flyoutSize.width - CARET_HEIGHT - triggerRect.right;
    var down = windowSize.height - flyoutSize.height - CARET_HEIGHT - triggerRect.bottom;
    var left = triggerRect.left - flyoutSize.width - CARET_HEIGHT;

    // overrides available space when the trigger is close to the edge of the screen
    // trigger is too close to top/bottom of screen for left & right flyouts
    if (triggerRect.top < BORDER_RADIUS || windowSize.height - triggerRect.bottom < BORDER_RADIUS) {
      left = 0;
      right = 0;
    }

    // trigger is too close to the left/right of screen for up & down flyouts
    if (triggerRect.left < BORDER_RADIUS || windowSize.width - triggerRect.right < BORDER_RADIUS) {
      up = 0;
      down = 0;
    }

    var spaces = [up, right, down, left];

    // Identify best direction of available spaces
    var max = Math.max.apply(Math, spaces);

    // Chose the main direction for the flyout based on available spaces & user preference
    var mainDir = void 0;
    if (idealDirection && spaces[DIR_INDEX_MAP[idealDirection]] > 0) {
      // user pref
      mainDir = idealDirection;
    } else {
      // If no direction pref, chose the direction in which there is the most space available
      mainDir = SPACES_INDEX_MAP[spaces.indexOf(max)];
    }
    return mainDir;
  }

  /**
   * Determines the sub direction of how the flyout is positioned within the main dir
   */
  function getSubDir(flyoutSize, mainDir, triggerRect, windowSize) {
    // Now that we have the main direction, chose from 3 caret placements for that direction
    var offset = void 0;
    var triggerMid = void 0;
    var windowSpaceAvailable = void 0;

    if (mainDir === 'right' || mainDir === 'left') {
      offset = flyoutSize.height / 2;
      triggerMid = triggerRect.top + (triggerRect.bottom - triggerRect.top) / 2;
      windowSpaceAvailable = windowSize.height;
    } else {
      // (mainDir === 'up' || mainDir === 'down')
      offset = flyoutSize.width / 2;
      triggerMid = triggerRect.left + (triggerRect.right - triggerRect.left) / 2;
      windowSpaceAvailable = windowSize.width;
    }

    var aboveOrLeft = triggerMid - offset - MARGIN;
    var belowOrRight = windowSpaceAvailable - triggerMid - offset - MARGIN;
    var subDir = void 0;
    if (aboveOrLeft > 0 && belowOrRight > 0) {
      // caret should go in middle b/c it can
      subDir = 'middle';
    } else if (belowOrRight > 0) {
      // caret should go at top for left/right and left for up/down
      subDir = mainDir === 'left' || mainDir === 'right' ? 'up' : 'left';
    } else {
      // caret should go at bottom for left/right and right for up/down
      subDir = mainDir === 'left' || mainDir === 'right' ? 'down' : 'right';
    }
    return subDir;
  }

  /**
   * Calculates the amount the flyout & caret need to shift over to align with designs
   */
  function calcEdgeShifts(subDir, triggerRect, windowSize) {
    // Target values for flyout and caret shifts
    var flyoutVerticalShift = CARET_OFFSET_FROM_SIDE - (triggerRect.height - CARET_HEIGHT) / 2;
    var flyoutHorizontalShift = CARET_OFFSET_FROM_SIDE - (triggerRect.width - CARET_HEIGHT) / 2;
    var caretVerticalShift = CARET_HEIGHT;
    var caretHorizontalShift = CARET_HEIGHT;

    // Covers edge case where trigger is in a corner and we need to adjust the offset of the caret
    // to something smaller than normal in order
    var isCloseVertically = triggerRect.top - flyoutVerticalShift < 0 || triggerRect.bottom + flyoutVerticalShift > windowSize.height;
    var isCloseHorizontally = triggerRect.left - flyoutHorizontalShift < 0 || triggerRect.right + flyoutHorizontalShift > windowSize.width;
    if (isCloseVertically) {
      flyoutVerticalShift = BORDER_RADIUS - (triggerRect.height - CARET_HEIGHT) / 2;
      caretVerticalShift = BORDER_RADIUS;
    }
    if (isCloseHorizontally) {
      flyoutHorizontalShift = BORDER_RADIUS - (triggerRect.width - CARET_HEIGHT) / 2;
      caretHorizontalShift = BORDER_RADIUS;
    }

    return {
      flyout: {
        x: flyoutHorizontalShift,
        y: flyoutVerticalShift
      },
      caret: {
        x: caretHorizontalShift,
        y: caretVerticalShift
      }
    };
  }

  /**
   * Calculates flyout and caret offsets for styling
   */
  function adjustOffsets(base, edgeShift, flyoutSize, mainDir, subDir, triggerRect) {
    var flyoutLeft = base.left;
    var flyoutTop = base.top;

    var caretTop = mainDir === 'down' ? -CARET_HEIGHT : null;
    var caretRight = mainDir === 'left' ? -CARET_HEIGHT : null;
    var caretBottom = null;
    var caretLeft = mainDir === 'right' ? -CARET_HEIGHT : null;

    if (subDir === 'up') {
      flyoutTop = base.top - edgeShift.flyout.y;
      caretTop = edgeShift.caret.y;
    } else if (subDir === 'down') {
      flyoutTop = base.top - flyoutSize.height + triggerRect.height + edgeShift.flyout.y;
      caretBottom = edgeShift.caret.y;
    } else if (subDir === 'left') {
      flyoutLeft = base.left - edgeShift.flyout.x;
      caretLeft = edgeShift.caret.x;
    } else if (subDir === 'right') {
      flyoutLeft = base.left - flyoutSize.width + triggerRect.width + edgeShift.flyout.x;
      caretRight = edgeShift.caret.x;
    } else if (subDir === 'middle') {
      if (mainDir === 'left' || mainDir === 'right') {
        var triggerMid = flyoutTop + triggerRect.height / 2;
        flyoutTop = triggerMid - flyoutSize.height / 2;
        caretTop = (flyoutSize.height - CARET_HEIGHT) / 2;
      }
      if (mainDir === 'up' || mainDir === 'down') {
        var _triggerMid = flyoutLeft + triggerRect.width / 2;
        flyoutLeft = _triggerMid - flyoutSize.width / 2;
        caretLeft = (flyoutSize.width - CARET_HEIGHT) / 2;
      }
    }

    return {
      flyoutOffset: {
        top: flyoutTop,
        left: flyoutLeft
      },
      caretOffset: {
        top: caretTop,
        right: caretRight,
        bottom: caretBottom,
        left: caretLeft
      }
    };
  }

  /* Calculates baseline top and left offset for flyout */
  function baseOffsets(relativeOffset, flyoutSize, mainDir, triggerRect, windowSize) {
    var HALF_CARET = CARET_HEIGHT / 2;
    // TOP OFFSET
    var top = void 0;
    if (mainDir === 'down') {
      top = windowSize.scrollY + triggerRect.bottom + HALF_CARET;
    } else if (mainDir === 'up') {
      top = windowSize.scrollY + (triggerRect.top - flyoutSize.height - HALF_CARET);
    } else {
      // left and right
      top = windowSize.scrollY + triggerRect.top;
    }

    // LEFT OFFSET
    var left = void 0;
    if (mainDir === 'left') {
      left = windowSize.scrollX + (triggerRect.left - flyoutSize.width - HALF_CARET);
    } else if (mainDir === 'right') {
      left = windowSize.scrollX + triggerRect.right + HALF_CARET;
    } else {
      // down and up
      left = windowSize.scrollX + triggerRect.left;
    }

    // Adjusts for the relative parent container
    top -= relativeOffset.y;
    left -= relativeOffset.x;
    return { top: top, left: left };
  }

  var Contents = function (_React$Component) {
    inherits(Contents, _React$Component);

    function Contents() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Contents);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Contents.__proto__ || Object.getPrototypeOf(Contents)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        flyoutOffset: {
          top: undefined,
          right: undefined,
          bottom: undefined,
          left: undefined
        },
        caretOffset: {
          top: undefined,
          right: undefined,
          bottom: undefined,
          left: undefined
        },
        mainDir: null
      }, _this.setFlyoutPosition = function (props) {
        var relativeOffset = props.relativeOffset,
            idealDirection = props.idealDirection,
            positionRelativeToAnchor = props.positionRelativeToAnchor,
            triggerRect = props.triggerRect,
            width = props.width;

        // Scroll not needed for relative elements
        // We can't use window.scrollX / window.scrollY since it's not supported by IE11

        var scrollX = positionRelativeToAnchor ? 0 : window.pageXOffset || document.documentElement && document.documentElement.scrollLeft || 0;
        var scrollY = positionRelativeToAnchor ? 0 : window.pageYOffset || document.documentElement && document.documentElement.scrollTop || 0;

        var windowSize = {
          height: window.innerHeight,
          width: window.innerWidth,
          scrollX: scrollX,
          scrollY: scrollY
        };

        var flyoutSize = {
          height: _this.flyout ? _this.flyout.clientHeight : 0,
          width: width
        };

        // First choose one of 4 main direction
        var mainDir = getMainDir(flyoutSize, idealDirection, triggerRect, windowSize);

        // Now that we have the main direction, chose from 3 caret placements for that direction
        var subDir = getSubDir(flyoutSize, mainDir, triggerRect, windowSize);

        // Gets the base offset that positions the flyout based on the main direction only
        var base = baseOffsets(relativeOffset, flyoutSize, mainDir, triggerRect, windowSize);

        // Gets the edge shifts for the flyout
        var edgeShifts = calcEdgeShifts(subDir, triggerRect, windowSize);

        // Adjusts for the subdirection of the caret

        var _adjustOffsets = adjustOffsets(base, edgeShifts, flyoutSize, mainDir, subDir, triggerRect),
            flyoutOffset = _adjustOffsets.flyoutOffset,
            caretOffset = _adjustOffsets.caretOffset;

        _this.setState({
          caretOffset: caretOffset,
          flyoutOffset: flyoutOffset,
          mainDir: mainDir
        });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Contents, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var _this2 = this;

        this.setFlyoutPosition(this.props);
        setTimeout(function () {
          if (_this2.props.shouldFocus && _this2.flyout) {
            _this2.flyout.focus();
          }
        });
        window.addEventListener('resize', this.props.onResize);
        window.addEventListener('keydown', this.props.onKeyDown);
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        this.setFlyoutPosition(nextProps);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        window.removeEventListener('resize', this.props.onResize);
        window.removeEventListener('keydown', this.props.onKeyDown);
      }

      /**
       * Determines the main direciton, sub direction, and corresponding offsets needed
       * to correctly position the offset
       */

    }, {
      key: 'render',
      value: function render() {
        var _this3 = this;

        var _props = this.props,
            bgColor = _props.bgColor,
            children = _props.children,
            width = _props.width;

        // Needed to prevent UI thrashing

        var visibility = this.state.mainDir === null ? 'hidden' : 'visible';
        var background = bgColor + 'Bg';
        var stroke = bgColor === 'white' ? '#efefef' : null;
        var borderColor = bgColor === 'white' ? 'lightGray' : bgColor;

        return React.createElement(
          'div',
          {
            className: styles$a.container,
            style: _extends({ stroke: stroke, visibility: visibility }, this.state.flyoutOffset)
          },
          React.createElement(
            'div',
            {
              className: classnames(colors[background], colors[borderColor], styles$a.dimensions, styles$a.contents),
              ref: function ref(c) {
                _this3.flyout = c;
              },
              tabIndex: -1
            },
            React.createElement(
              'div',
              {
                className: classnames(styles$a.dimensions, styles$a.innerContents),
                style: { width: width }
              },
              children
            ),
            React.createElement(
              'div',
              {
                className: classnames(colors[bgColor], styles$a.caret),
                style: _extends({}, this.state.caretOffset)
              },
              React.createElement(Caret, { direction: this.state.mainDir })
            )
          )
        );
      }
    }]);
    return Contents;
  }(React.Component);
  Contents.propTypes = {
    bgColor: PropTypes.oneOf(['blue', 'darkGray', 'orange', 'white']),
    children: PropTypes.node,
    idealDirection: PropTypes.oneOf(['up', 'right', 'down', 'left']),
    onKeyDown: PropTypes.func.isRequired,
    onResize: PropTypes.func.isRequired,
    relativeOffset: PropTypes.exact({ x: PropTypes.number, y: PropTypes.number }),
    positionRelativeToAnchor: PropTypes.bool,
    shouldFocus: PropTypes.bool,
    triggerRect: PropTypes.exact({
      bottom: PropTypes.number,
      height: PropTypes.number,
      left: PropTypes.number,
      right: PropTypes.number,
      top: PropTypes.number,
      width: PropTypes.number
    }),
    width: PropTypes.number
  };

  var OutsideEventBehavior = function (_React$Component) {
    inherits(OutsideEventBehavior, _React$Component);

    function OutsideEventBehavior() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, OutsideEventBehavior);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = OutsideEventBehavior.__proto__ || Object.getPrototypeOf(OutsideEventBehavior)).call.apply(_ref, [this].concat(args))), _this), _this.handleClickEvent = function (event) {
        // eslint-disable-next-line react/no-find-dom-node
        var el = reactDom.findDOMNode(_this);
        if (!_this.props.onClick || !el || event.target instanceof Node && el.contains(event.target)) {
          return;
        }
        _this.props.onClick(event);
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(OutsideEventBehavior, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        document.addEventListener('click', this.handleClickEvent, {
          capture: true
        });
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        document.removeEventListener('click', this.handleClickEvent, {
          capture: true
        });
      }
    }, {
      key: 'render',
      value: function render() {
        return this.props.children;
      }
    }]);
    return OutsideEventBehavior;
  }(React.Component);

  var SIZE_WIDTH_MAP = {
    xs: 185,
    sm: 230,
    md: 284,
    lg: 320,
    xl: 375
  };

  var ESCAPE_KEY_CODE = 27;

  var Controller = function (_React$Component) {
    inherits(Controller, _React$Component);

    function Controller() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Controller);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Controller.__proto__ || Object.getPrototypeOf(Controller)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        relativeOffset: {
          x: 0,
          y: 0
        },
        triggerBoundingRect: {
          bottom: 0,
          height: 0,
          left: 0,
          right: 0,
          top: 0,
          width: 0
        }
      }, _this.handleKeyDown = function (event) {
        if (event.keyCode === ESCAPE_KEY_CODE) {
          _this.props.onDismiss();
        }
      }, _this.handlePageClick = function (event) {
        if (event.target instanceof Node && _this.props.anchor && !_this.props.anchor.contains(event.target)) {
          _this.props.onDismiss();
        }
      }, _this.handleResize = function () {
        _this.updateTriggerRect(_this.props);
      }, _this.updateTriggerRect = function (props) {
        var anchor = props.anchor,
            positionRelativeToAnchor = props.positionRelativeToAnchor;

        var triggerBoundingRect = void 0;
        var relativeOffset = void 0;
        if (anchor) {
          triggerBoundingRect = anchor.getBoundingClientRect();

          // Needed for correct positioning within Contents.js
          relativeOffset = {
            x: positionRelativeToAnchor ? triggerBoundingRect.left - anchor.offsetLeft : 0,
            y: positionRelativeToAnchor ? triggerBoundingRect.top - anchor.offsetTop : 0
          };
        }

        _this.setState({ relativeOffset: relativeOffset, triggerBoundingRect: triggerBoundingRect });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Controller, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        this.updateTriggerRect(this.props);
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        this.updateTriggerRect(nextProps);
      }
    }, {
      key: 'render',
      value: function render() {
        var _props = this.props,
            anchor = _props.anchor,
            bgColor = _props.bgColor,
            children = _props.children,
            idealDirection = _props.idealDirection,
            positionRelativeToAnchor = _props.positionRelativeToAnchor,
            shouldFocus = _props.shouldFocus;

        if (!anchor) {
          return null;
        }
        var size = this.props.size ? this.props.size : 'sm';
        var width = typeof size === 'string' ? SIZE_WIDTH_MAP[size] : size;
        return React.createElement(
          OutsideEventBehavior,
          { onClick: this.handlePageClick },
          React.createElement(
            Contents,
            {
              bgColor: bgColor,
              idealDirection: idealDirection,
              onKeyDown: this.handleKeyDown,
              onResize: this.handleResize,
              positionRelativeToAnchor: positionRelativeToAnchor,
              relativeOffset: this.state.relativeOffset,
              shouldFocus: shouldFocus,
              triggerRect: this.state.triggerBoundingRect,
              width: width
            },
            children
          )
        );
      }
    }]);
    return Controller;
  }(React.Component);


  Controller.propTypes = {
    anchor: PropTypes.shape({
      contains: PropTypes.func,
      getBoundingClientRect: PropTypes.func
    }),
    bgColor: PropTypes.oneOf(['blue', 'darkGray', 'orange', 'white']),
    children: PropTypes.node,
    idealDirection: PropTypes.oneOf(['up', 'right', 'down', 'left']),
    onDismiss: PropTypes.func.isRequired,
    positionRelativeToAnchor: PropTypes.bool,
    shouldFocus: PropTypes.bool,
    size: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl'])] // default: sm
    )
  };

  function Flyout(props) {
    var anchor = props.anchor,
        children = props.children,
        idealDirection = props.idealDirection,
        onDismiss = props.onDismiss,
        _props$positionRelati = props.positionRelativeToAnchor,
        positionRelativeToAnchor = _props$positionRelati === undefined ? true : _props$positionRelati,
        _props$color = props.color,
        color = _props$color === undefined ? 'white' : _props$color,
        _props$shouldFocus = props.shouldFocus,
        shouldFocus = _props$shouldFocus === undefined ? true : _props$shouldFocus,
        size = props.size;


    if (!anchor) {
      return null;
    }

    return React.createElement(
      Controller,
      {
        anchor: anchor,
        bgColor: color,
        idealDirection: idealDirection,
        onDismiss: onDismiss,
        positionRelativeToAnchor: positionRelativeToAnchor,
        shouldFocus: shouldFocus,
        size: size
      },
      children
    );
  }

  Flyout.propTypes = {
    anchor: PropTypes.shape({
      contains: PropTypes.func,
      getBoundingClientRect: PropTypes.func
    }),
    children: PropTypes.node,
    idealDirection: PropTypes.oneOf(['up', 'right', 'down', 'left']),
    onDismiss: PropTypes.func.isRequired,
    positionRelativeToAnchor: PropTypes.bool,
    color: PropTypes.oneOf(['blue', 'orange', 'white']),
    size: PropTypes.oneOfType([PropTypes.number, PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl'])] // default: sm
    )
  };

  var styles$b = { "wash": "_te _4h _4j _4m _4k _4l" };

  function zip(a, b) {
    return a.map(function (item, idx) {
      return [item, b[idx]];
    });
  }

  var BORDER_WIDTH = 2;

  var AVATAR_SIZES = {
    sm: 24,
    md: 40,
    lg: 72
  };

  var avatarLayout = function avatarLayout(n, size) {
    switch (n) {
      case 0:
      case 1:
        return [{ top: 0, left: 0, width: size, height: size, textLayout: 'center' }];
      case 2:
        return [{
          top: 0,
          left: 0,
          width: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
          height: size,
          textLayout: 'center'
        }, {
          top: 0,
          left: 'calc(50% + ' + BORDER_WIDTH / 2 + 'px)',
          width: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
          height: size,
          textLayout: 'center'
        }];
      default:
        return [{
          top: 0,
          left: 0,
          width: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
          height: size,
          textLayout: 'center'
        }, {
          top: 0,
          left: 'calc(50% + ' + BORDER_WIDTH / 2 + 'px)',
          width: 'calc(50%)',
          height: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
          textLayout: 'topLeft'
        }, {
          top: 'calc(50% + ' + BORDER_WIDTH / 2 + 'px)',
          left: 'calc(50% + ' + BORDER_WIDTH / 2 + 'px)',
          width: 'calc(50%)',
          height: 'calc(50% - ' + BORDER_WIDTH / 2 + 'px)',
          textLayout: 'bottomLeft'
        }];
    }
  };

  var degToRad = function degToRad(deg) {
    return deg * (Math.PI / 180);
  };

  var DefaultAvatar$1 = function DefaultAvatar(props) {
    var size = props.size,
        name = props.name,
        textLayout = props.textLayout;


    var quarterPadding = 'calc(' + Math.sin(degToRad(45)) + ' * (' + size + ') / 2)';

    var initial = React.createElement(
      'svg',
      {
        width: '100%',
        viewBox: '-50 -50 100 100',
        version: '1.1',
        preserveAspectRatio: 'xMidYMid meet',
        xmlns: 'http://www.w3.org/2000/svg'
      },
      React.createElement(
        'title',
        null,
        name
      ),
      React.createElement(
        'text',
        {
          fontSize: '50px',
          fill: '#fff',
          dominantBaseline: 'central',
          textAnchor: 'middle',
          className: [typography.antialiased, typography.sansSerif, typography.leadingSmall, typography.fontWeightBold].join(' ')
        },
        name ? [].concat(toConsumableArray(name))[0].toUpperCase() : ''
      )
    );
    switch (textLayout) {
      case 'bottomLeft':
        return React.createElement(
          Box,
          {
            'aria-label': name,
            color: 'gray',
            height: '100%',
            display: 'flex',
            alignItems: 'end',
            dangerouslySetInlineStyle: {
              __style: {
                paddingBottom: quarterPadding,
                paddingRight: quarterPadding
              }
            }
          },
          initial
        );
      case 'topLeft':
        return React.createElement(
          Box,
          {
            'aria-label': name,
            color: 'gray',
            height: '100%',
            display: 'flex',
            alignItems: 'start',
            dangerouslySetInlineStyle: {
              __style: {
                paddingTop: quarterPadding,
                paddingRight: quarterPadding
              }
            }
          },
          initial
        );
      default:
        return React.createElement(
          Box,
          {
            'aria-label': name,
            color: 'gray',
            height: '100%',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center'
          },
          initial
        );
    }
  };

  function GroupAvatar(props) {
    var collaborators = props.collaborators,
        outline = props.outline,
        size = props.size;

    var avatarWidth = size ? AVATAR_SIZES[size] : '100%';
    var avatarHeight = size ? AVATAR_SIZES[size] : '';
    var positions = avatarLayout(collaborators.length, avatarWidth);
    return React.createElement(
      Box,
      {
        color: 'white',
        overflow: 'hidden',
        shape: 'circle',
        width: avatarWidth,
        height: avatarHeight,
        position: 'relative',
        dangerouslySetInlineStyle: {
          __style: _extends({}, outline ? { boxShadow: '0 0 0 2px #fff' } : {}, {
            // willChange: transform fixes a strange behavior where the border of the children
            // are not properly trimmed even though overflow: hidden is set
            willChange: 'transform'
          })
        }
      },
      React.createElement(Box, { dangerouslySetInlineStyle: { __style: { paddingBottom: '100%' } } }),
      zip(positions, collaborators).map(function (_ref, idx) {
        var _ref2 = slicedToArray(_ref, 2),
            position = _ref2[0],
            _ref2$ = _ref2[1],
            collaborator = _ref2$ === undefined ? { name: '', src: undefined } : _ref2$;

        var width = position.width,
            height = position.height,
            top = position.top,
            left = position.left,
            textLayout = position.textLayout;
        var name = collaborator.name,
            src = collaborator.src;

        return React.createElement(
          Box,
          {
            key: idx,
            position: 'absolute',
            width: width,
            height: height,
            dangerouslySetInlineStyle: { __style: { top: top, left: left } }
          },
          src ? React.createElement(Image, {
            alt: name,
            color: '#EFEFEF',
            src: src,
            naturalWidth: 1,
            naturalHeight: 1,
            fit: 'cover'
          }) : React.createElement(DefaultAvatar$1, {
            name: name,
            textLayout: textLayout,
            size: height
          }),
          React.createElement('div', { className: styles$b.wash })
        );
      })
    );
  }

  GroupAvatar.propTypes = {
    collaborators: PropTypes.arrayOf(PropTypes.exact({
      name: PropTypes.string.isRequired,
      src: PropTypes.string
    })).isRequired,
    outline: PropTypes.bool,
    size: PropTypes.oneOf(['sm', 'md', 'lg'])
  };

  var styles$c = { "Heading": "_tf _0 _1 _2 _3", "fontSize1": "_tg", "fontSize2": "_th", "fontSize3": "_ti", "fontSize4": "_tj", "fontSize5": "_tk", "smFontSize1": "_tl", "smFontSize2": "_tm", "smFontSize3": "_tn", "smFontSize4": "_to", "smFontSize5": "_tp", "mdFontSize1": "_tq", "mdFontSize2": "_tr", "mdFontSize3": "_ts", "mdFontSize4": "_tt", "mdFontSize5": "_tu", "lgFontSize1": "_tv", "lgFontSize2": "_tw", "lgFontSize3": "_tx", "lgFontSize4": "_ty", "lgFontSize5": "_tz" };

  var defaultHeadingLevels = {
    xs: 5,
    sm: 4,
    md: 3,
    lg: 2,
    xl: 1
  };

  var SIZE_SCALE$1 = {
    xs: 1,
    sm: 2,
    md: 3,
    lg: 4,
    xl: 5
  };

  function Heading(props) {
    var accessibilityLevel = props.accessibilityLevel,
        children = props.children,
        _props$color = props.color,
        color = _props$color === undefined ? 'darkGray' : _props$color,
        _props$id = props.id,
        id = _props$id === undefined ? null : _props$id,
        lgSize = props.lgSize,
        mdSize = props.mdSize,
        _props$overflow = props.overflow,
        overflow = _props$overflow === undefined ? 'breakWord' : _props$overflow,
        _props$size = props.size,
        size = _props$size === undefined ? 'md' : _props$size,
        smSize = props.smSize,
        _props$truncate = props.truncate,
        truncate = _props$truncate === undefined ? false : _props$truncate;


    var cs = classnames(styles$c.Heading, styles$c['fontSize' + SIZE_SCALE$1[size]], smSize && styles$c['smFontSize' + SIZE_SCALE$1[smSize]], mdSize && styles$c['mdFontSize' + SIZE_SCALE$1[mdSize]], lgSize && styles$c['lgFontSize' + SIZE_SCALE$1[lgSize]], colors[color], overflow === 'breakWord' && typography.breakWord, truncate && typography.truncate);

    var headingLevel = accessibilityLevel || defaultHeadingLevels[size];
    return React.createElement('h' + headingLevel, _extends({
      className: cs,
      id: id
    }, truncate && typeof children === 'string' ? { title: children } : null), children);
  }

  Heading.propTypes = {
    accessibilityLevel: PropTypes.oneOf([1, 2, 3, 4, 5, 6]),
    children: PropTypes.node,
    color: PropTypes.oneOf(['blue', 'darkGray', 'eggplant', 'gray', 'green', 'lightGray', 'maroon', 'midnight', 'navy', 'olive', 'orange', 'orchid', 'pine', 'purple', 'red', 'watermelon', 'white']),
    id: PropTypes.string,
    overflow: PropTypes.oneOf(['normal', 'breakWord']),
    size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
    smSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
    mdSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
    lgSize: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),
    truncate: PropTypes.bool
  };

  var styles$d = { "button": "_u2 _45 _33 _oi _z8" };

  var styles$e = { "pog": "_um _2w _4s _50 _5a", "focused": "_un _xu", "transparent": "_uo _42", "hovered": "_up", "white": "_uq _37", "active": "_ur", "lightGray": "_us _39" };

  var SIZE_NAME_TO_PIXEL = {
    xs: 24,
    sm: 32,
    md: 40,
    lg: 48,
    xl: 56
  };

  var defaultIconButtonIconColors = {
    transparent: 'gray',
    lightGray: 'gray',
    white: 'gray'
  };

  function Pog(props) {
    var _classnames;

    var _props$active = props.active,
        active = _props$active === undefined ? false : _props$active,
        _props$bgColor = props.bgColor,
        bgColor = _props$bgColor === undefined ? 'transparent' : _props$bgColor,
        _props$focused = props.focused,
        focused = _props$focused === undefined ? false : _props$focused,
        _props$hovered = props.hovered,
        hovered = _props$hovered === undefined ? false : _props$hovered,
        _props$iconColor = props.iconColor,
        iconColor = _props$iconColor === undefined ? defaultIconButtonIconColors[bgColor] : _props$iconColor,
        icon = props.icon,
        _props$size = props.size,
        size = _props$size === undefined ? 'md' : _props$size;


    var iconSize = SIZE_NAME_TO_PIXEL[size] / 2;

    var inlineStyle = {
      height: SIZE_NAME_TO_PIXEL[size],
      width: SIZE_NAME_TO_PIXEL[size]
    };

    var classes = classnames(styles$e.pog, styles$e[bgColor], (_classnames = {}, defineProperty(_classnames, styles$e.active, active), defineProperty(_classnames, styles$e.focused, focused), defineProperty(_classnames, styles$e.hovered, hovered && !focused && !active), _classnames));

    return React.createElement(
      'div',
      { className: classes, style: inlineStyle },
      React.createElement(
        Box,
        { shape: 'circle' },
        React.createElement(Icon, {
          color: iconColor,
          icon: icon,
          size: iconSize,
          accessibilityLabel: ''
        })
      )
    );
  }

  Pog.propTypes = {
    active: PropTypes.bool,
    bgColor: PropTypes.oneOf(['transparent', 'lightGray', 'white']),
    focused: PropTypes.bool,
    hovered: PropTypes.bool,
    iconColor: PropTypes.oneOf(['gray', 'darkGray', 'red', 'blue', 'white']),
    icon: PropTypes.oneOf(Object.keys(icons)).isRequired,
    size: PropTypes.oneOf(Object.keys(SIZE_NAME_TO_PIXEL))
  };

  var IconButton = function (_React$Component) {
    inherits(IconButton, _React$Component);

    function IconButton() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, IconButton);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = IconButton.__proto__ || Object.getPrototypeOf(IconButton)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        active: false,
        focused: false,
        hovered: false
      }, _this.handleBlur = function () {
        return _this.setState({ focused: false });
      }, _this.handleFocus = function () {
        _this.setState({ focused: true });
      }, _this.handleMouseDown = function () {
        _this.setState({ active: true });
      }, _this.handleMouseEnter = function () {
        _this.setState({ hovered: true });
      }, _this.handleMouseLeave = function () {
        _this.setState({
          active: false,
          hovered: false
        });
      }, _this.handleMouseUp = function () {
        _this.setState({ active: false });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(IconButton, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            accessibilityExpanded = _props.accessibilityExpanded,
            accessibilityHaspopup = _props.accessibilityHaspopup,
            accessibilityLabel = _props.accessibilityLabel,
            bgColor = _props.bgColor,
            iconColor = _props.iconColor,
            icon = _props.icon,
            size = _props.size,
            onClick = _props.onClick;
        var _state = this.state,
            active = _state.active,
            focused = _state.focused,
            hovered = _state.hovered;


        return React.createElement(
          'button',
          {
            'aria-expanded': accessibilityExpanded,
            'aria-haspopup': accessibilityHaspopup,
            'aria-label': accessibilityLabel,
            className: styles$d.button,
            onBlur: this.handleBlur,
            onClick: function (_onClick) {
              function onClick(_x) {
                return _onClick.apply(this, arguments);
              }

              onClick.toString = function () {
                return _onClick.toString();
              };

              return onClick;
            }(function (event) {
              return onClick && onClick({ event: event });
            }),
            onFocus: this.handleFocus,
            onMouseDown: this.handleMouseDown,
            onMouseEnter: this.handleMouseEnter,
            onMouseLeave: this.handleMouseLeave,
            onMouseUp: this.handleMouseUp,
            type: 'button'
          },
          React.createElement(Pog, {
            active: active,
            bgColor: bgColor,
            focused: focused,
            hovered: hovered,
            iconColor: iconColor,
            icon: icon,
            size: size
          })
        );
      }
    }]);
    return IconButton;
  }(React.Component);

  IconButton.propTypes = {
    accessibilityExpanded: PropTypes.bool,
    accessibilityHaspopup: PropTypes.bool,
    accessibilityLabel: PropTypes.string.isRequired,
    bgColor: PropTypes.oneOf(['transparent', 'lightGray', 'white']),
    icon: PropTypes.oneOf(Object.keys(icons)).isRequired,
    iconColor: PropTypes.oneOf(['gray', 'darkGray', 'red', 'blue', 'white']),
    onClick: PropTypes.func,
    size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl'])
  };

  var styles$f = { "label": "_u7 _45 _z8" };

  function Label(props) {
    var children = props.children,
        htmlFor = props.htmlFor;


    return React.createElement(
      'label',
      { className: styles$f.label, htmlFor: htmlFor },
      children
    );
  }

  Label.propTypes = {
    children: PropTypes.node,
    htmlFor: PropTypes.string.isRequired
  };

  var Layer = function (_React$Component) {
    inherits(Layer, _React$Component);

    function Layer(props) {
      classCallCheck(this, Layer);

      var _this = possibleConstructorReturn(this, (Layer.__proto__ || Object.getPrototypeOf(Layer)).call(this, props));

      _this.el = document.createElement('div');
      return _this;
    }

    createClass(Layer, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        if (document.body) {
          document.body.appendChild(this.el);
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (document.body) {
          document.body.removeChild(this.el);
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var children = this.props.children;

        return reactDom.createPortal(children, this.el);
      }
    }]);
    return Layer;
  }(React.Component);

  /*
    Much of the math and understanding about this component comes from @vjeaux's
    excellent blog post on image resizing.

    http://blog.vjeux.com/2013/image/css-container-and-cover.html

    I highly recommend you read that first before continuing on reading.
  */

  var aspectRatio = function aspectRatio(width, height) {
    return width / height;
  };

  function Letterbox(_ref) {
    var children = _ref.children,
        contentAspectRatio = _ref.contentAspectRatio,
        height = _ref.height,
        width = _ref.width;

    var viewportAspectRatio = aspectRatio(width, height);

    var contentHeight = void 0;
    var contentWidth = void 0;

    if (contentAspectRatio < viewportAspectRatio) {
      contentWidth = width;
      contentHeight = width / contentAspectRatio;
    } else {
      contentWidth = height * contentAspectRatio;
      contentHeight = height;
    }

    var offsetTop = (contentHeight - height) / -2;
    var offsetLeft = (contentWidth - width) / -2;

    return React.createElement(
      Mask,
      { width: width, height: height },
      React.createElement(
        'div',
        { style: { marginTop: offsetTop, marginLeft: offsetLeft } },
        React.createElement(
          Mask,
          { width: contentWidth, height: contentHeight },
          children
        )
      )
    );
  }

  Letterbox.propTypes = {
    children: PropTypes.node,
    contentAspectRatio: PropTypes.number.isRequired,
    height: PropTypes.number.isRequired,
    width: PropTypes.number.isRequired
  };

  var styles$g = { "link": "_u8 _a", "accessibleFocusStyle": "_u9 _xt", "block": "_ua _45" };

  var TAB_KEY_CODE = 9;

  var Link = function (_React$Component) {
    inherits(Link, _React$Component);

    function Link() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Link);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Link.__proto__ || Object.getPrototypeOf(Link)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        enableFocusStyles: true
      }, _this.handleClick = function (event) {
        var _this$props = _this.props,
            href = _this$props.href,
            onClick = _this$props.onClick;

        if (onClick && href) {
          onClick({ event: event });
        }
      }, _this.handleMouseDown = function () {
        var _this$props2 = _this.props,
            href = _this$props2.href,
            target = _this$props2.target;

        if (target === 'blank' && href) {
          _this.setState({ enableFocusStyles: false });
        }
      }, _this.handleKeyUp = function (event) {
        var _this$props3 = _this.props,
            href = _this$props3.href,
            target = _this$props3.target;

        if (target === 'blank' && event.keyCode === TAB_KEY_CODE && href) {
          _this.setState({ enableFocusStyles: true });
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Link, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            children = _props.children,
            _props$inline = _props.inline,
            inline = _props$inline === undefined ? false : _props$inline,
            _props$target = _props.target,
            target = _props$target === undefined ? null : _props$target,
            href = _props.href;

        var rel = target === 'blank' ? 'noopener noreferrer' : null;
        var linkTarget = target ? '_' + target : null;

        return React.createElement(
          'a',
          {
            className: classnames(styles$g.link, this.state.enableFocusStyles ? styles$g.accessibleFocusStyle : '', inline ? '' : styles$g.block),
            href: href,
            onMouseDown: this.handleMouseDown,
            onKeyUp: this.handleKeyUp,
            onClick: this.handleClick,
            rel: rel,
            target: linkTarget
          },
          children
        );
      }
    }]);
    return Link;
  }(React.Component);

  Link.propTypes = {
    children: PropTypes.node.isRequired,
    href: PropTypes.string.isRequired,
    inline: PropTypes.bool,
    onClick: PropTypes.func,
    target: PropTypes.oneOf([null, 'self', 'blank'])
  };

  /**
   * debounce prevents a particular function from being called until after a given
   * cooldown period (default 100ms). Every time the function is called, it resets
   * the cooldown.
   */

  function debounce(fn) {
    var threshhold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;

    var deferTimer = null;

    var debounced = function debounced() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (deferTimer) {
        clearTimeout(deferTimer);
      }

      deferTimer = setTimeout(function () {
        deferTimer = null;
        fn.apply(undefined, toConsumableArray(args));
      }, threshhold);
    };

    debounced.clearTimeout = function () {
      if (deferTimer) {
        clearTimeout(deferTimer);
      }
    };

    return debounced;
  }

  /**
   * FetchItems is a logic component that renders no content itself. Its job
   * is to manage when the given fetchMore method should be called based on
   * the given scroll/size props.
   *
   * While no element is actually passed to FetchItems, it is intended to be used
   * in conjunction with a large scroll container that uses async fetching to
   * load and render additional data. Based on the height of this container and
   * its current scroll position, FetchItems is responsible for triggering future
   * fetch calls.
   */

  var FetchItems = function (_React$PureComponent) {
    inherits(FetchItems, _React$PureComponent);

    function FetchItems() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, FetchItems);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = FetchItems.__proto__ || Object.getPrototypeOf(FetchItems)).call.apply(_ref, [this].concat(args))), _this), _this.check = function () {
        var _this$props = _this.props,
            containerHeight = _this$props.containerHeight,
            isAtEnd = _this$props.isAtEnd,
            isFetching = _this$props.isFetching,
            fetchMore = _this$props.fetchMore,
            scrollHeight = _this$props.scrollHeight,
            scrollTop = _this$props.scrollTop;


        if (isAtEnd || isFetching || !fetchMore) {
          return;
        }
        var scrollBuffer = containerHeight * 3;

        if (scrollTop + scrollBuffer > scrollHeight) {
          fetchMore();
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(FetchItems, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        setTimeout(this.check);
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        this.check();
      }
    }, {
      key: 'render',
      value: function render() {
        return null;
      }
    }]);
    return FetchItems;
  }(React.PureComponent);

  FetchItems.propTypes = {
    containerHeight: PropTypes.number.isRequired,
    isAtEnd: PropTypes.bool,
    isFetching: PropTypes.bool.isRequired,
    fetchMore: PropTypes.func,
    scrollHeight: PropTypes.number.isRequired,
    scrollTop: PropTypes.number.isRequired
  };

  var styles$h = { "Masonry": "_ug _4f", "Masonry__Item": "_uh _4h", "Masonry__Item__Mounted": "_ui" };

  /**
   * ScrollContainer is a pass-through component that simply sets up an onScroll
   * handler on the given scrollContainer element (or the element that is
   * returned as result of calling the scrollContainer method). This allows for
   * the event listener subscription of the scrollContainer to be managed inside
   * the React lifecycle without adding bloat to Masonry or other onScroll
   * subscribers.
   *
   * Note that this Component renders its children without creating any
   * additional content. Also note that, while the component is built to manage
   * onScroll inside of the React lifecycle, it doesn't change onScroll events
   * or the API at all, so it could easily be adapted to other event types.
   */

  function getScrollContainer(scrollContainer) {
    return typeof scrollContainer === 'function' ? scrollContainer() : scrollContainer;
  }

  var ScrollContainer = function (_React$Component) {
    inherits(ScrollContainer, _React$Component);

    function ScrollContainer() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, ScrollContainer);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ScrollContainer.__proto__ || Object.getPrototypeOf(ScrollContainer)).call.apply(_ref, [this].concat(args))), _this), _this.getScrollContainerRef = function () {
        return _this.scrollContainer;
      }, _this.handleScroll = function (event) {
        _this.props.onScroll(event);
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(ScrollContainer, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var scrollContainer = getScrollContainer(this.props.scrollContainer);
        if (scrollContainer) {
          this.updateScrollContainer(scrollContainer);
        }
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        var nextScrollContainer = getScrollContainer(this.props.scrollContainer);
        if (nextScrollContainer && nextScrollContainer !== this.scrollContainer) {
          this.updateScrollContainer(nextScrollContainer);
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (this.scrollContainer) {
          this.scrollContainer.removeEventListener('scroll', this.handleScroll);
        }
      }
    }, {
      key: 'updateScrollContainer',
      value: function updateScrollContainer(scrollContainer) {
        if (this.scrollContainer) {
          // cleanup existing scroll container if it exists
          this.scrollContainer.removeEventListener('scroll', this.handleScroll);
        }
        this.scrollContainer = scrollContainer;
        this.scrollContainer.addEventListener('scroll', this.handleScroll);
      }
    }, {
      key: 'render',
      value: function render() {
        return React.Children.only(this.props.children);
      }
    }]);
    return ScrollContainer;
  }(React.Component);

  ScrollContainer.propTypes = {
    children: PropTypes.node.isRequired,
    onScroll: PropTypes.func.isRequired,
    scrollContainer: PropTypes.oneOfType([PropTypes.object, PropTypes.func]).isRequired
  };

  /**
   * throttle limits the number of times a function can be called to a
   * given threshhold (100ms by default). The function is always called
   * on the leading and trailing edge.
   */

  function throttle(fn) {
    var threshhold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;

    var last = void 0;
    var deferTimer = void 0;
    var throttled = function throttled() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var now = Date.now();
      if (last !== undefined && now - last < threshhold) {
        clearTimeout(deferTimer);
        deferTimer = setTimeout(function () {
          last = now;
          fn.apply(undefined, toConsumableArray(args));
        }, threshhold - (now - last));
      } else {
        last = now;
        fn.apply(undefined, toConsumableArray(args));
      }
    };

    throttled.clearTimeout = function () {
      if (deferTimer) {
        clearTimeout(deferTimer);
      }
    };

    return throttled;
  }

  var MeasurementStore = function () {
    function MeasurementStore() {
      classCallCheck(this, MeasurementStore);
      this.map = new WeakMap();
    }

    createClass(MeasurementStore, [{
      key: 'get',
      value: function get$$1(key) {
        return this.map.get(key);
      }
    }, {
      key: 'has',
      value: function has(key) {
        return this.map.has(key);
      }
    }, {
      key: 'set',
      value: function set$$1(key, value) {
        this.map.set(key, value);
      }
    }, {
      key: 'reset',
      value: function reset() {
        this.map = new WeakMap();
      }
    }]);
    return MeasurementStore;
  }();

  /**
   * Measuring scroll positions, element heights, etc is different between
   * different browsers and the window object vs other DOM nodes. These
   * utils abstract away these differences.
   */

  function getElementHeight(element) {
    return element === window ? window.innerHeight : element.clientHeight;
  }

  function getWindowScrollPos() {
    if (window.scrollY !== undefined) {
      // Modern browser
      return window.scrollY;
    }
    if (document.documentElement && document.documentElement.scrollTop !== undefined) {
      // IE support.
      return document.documentElement.scrollTop;
    }
    return 0;
  }

  function getRelativeScrollTop(element) {
    return element === window ? getWindowScrollPos() : element.scrollTop - element.getBoundingClientRect().top;
  }

  function getScrollHeight(element) {
    return element === window && document.documentElement ? document.documentElement.scrollHeight : element.scrollHeight;
  }

  function getScrollPos(element) {
    return element === window ? getWindowScrollPos() : element.scrollTop;
  }

  var DefaultLayoutSymbol = Symbol('default');
  var UniformRowLayoutSymbol = Symbol('uniformRow');

  var mindex$1 = function mindex(arr) {
    var idx = 0;
    for (var i = 0; i < arr.length; i += 1) {
      if (arr[i] < arr[idx]) {
        idx = i;
      }
    }
    return idx;
  };

  var offscreen = function offscreen(width) {
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
    return {
      top: -9999,
      left: -9999,
      width: width,
      height: height
    };
  };

  var defaultLayout = (function (_ref) {
    var cache = _ref.cache,
        _ref$columnWidth = _ref.columnWidth,
        columnWidth = _ref$columnWidth === undefined ? 236 : _ref$columnWidth,
        _ref$gutter = _ref.gutter,
        gutter = _ref$gutter === undefined ? 14 : _ref$gutter,
        _ref$minCols = _ref.minCols,
        minCols = _ref$minCols === undefined ? 2 : _ref$minCols,
        width = _ref.width;
    return function (items) {
      if (width == null) {
        return items.map(function () {
          return offscreen(columnWidth);
        });
      }

      var columnWidthAndGutter = columnWidth + gutter;
      var columnCount = Math.max(Math.floor((width + gutter) / columnWidthAndGutter), minCols);
      // the total height of each column
      var heights = new Array(columnCount).fill(0);
      var centerOffset = Math.max(Math.floor((width - columnWidthAndGutter * columnCount + gutter) / 2), 0);

      return items.reduce(function (acc, item) {
        var positions = acc;
        // $FlowFixMe
        var height = cache.get(item);
        var position = void 0;

        if (height == null) {
          position = offscreen(columnWidth);
        } else {
          var heightAndGutter = height + gutter;
          var col = mindex$1(heights);
          var _top = heights[col];
          var _left = col * columnWidthAndGutter + centerOffset;

          heights[col] += heightAndGutter;
          position = { top: _top, left: _left, width: columnWidth, height: height };
        }
        positions.push(position);
        return positions;
      }, []);
    };
  });

  var offscreen$1 = function offscreen(width) {
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
    return {
      top: -9999,
      left: -9999,
      width: width,
      height: height
    };
  };

  var uniformRowLayout = (function (_ref) {
    var cache = _ref.cache,
        _ref$columnWidth = _ref.columnWidth,
        columnWidth = _ref$columnWidth === undefined ? 236 : _ref$columnWidth,
        _ref$gutter = _ref.gutter,
        gutter = _ref$gutter === undefined ? 14 : _ref$gutter,
        width = _ref.width,
        _ref$minCols = _ref.minCols,
        minCols = _ref$minCols === undefined ? 3 : _ref$minCols;
    return function (items) {
      if (width == null) {
        return items.map(function () {
          return offscreen$1(columnWidth);
        });
      }

      var columnWidthAndGutter = columnWidth + gutter;
      var columnCount = Math.max(Math.floor((width + gutter) / columnWidthAndGutter), minCols);

      var positions = [];
      var heights = [];

      for (var i = 0; i < items.length; i += 1) {
        var position = void 0;
        var _height = cache.get(items[i]);

        if (_height == null) {
          position = offscreen$1(columnWidth);
        } else {
          var column = i % columnCount;
          var row = Math.floor(i / columnCount);

          if (column === 0 || _height > heights[row]) {
            heights[row] = _height;
          }

          var _top = row > 0 ? heights.slice(0, row).reduce(function (sum, y) {
            return sum + y + gutter;
          }, 0) : 0;

          position = {
            top: _top,
            left: column * columnWidthAndGutter,
            width: columnWidth,
            height: _height
          };
        }
        positions.push(position);
      }
      return positions;
    };
  });

  var mindex$2 = function mindex(arr) {
    var idx = 0;
    for (var i = 0; i < arr.length; i += 1) {
      if (arr[i] < arr[idx]) {
        idx = i;
      }
    }
    return idx;
  };

  var fullWidthLayout = (function (_ref) {
    var _ref$gutter = _ref.gutter,
        gutter = _ref$gutter === undefined ? 0 : _ref$gutter,
        cache = _ref.cache,
        _ref$minCols = _ref.minCols,
        minCols = _ref$minCols === undefined ? 2 : _ref$minCols,
        _ref$idealColumnWidth = _ref.idealColumnWidth,
        idealColumnWidth = _ref$idealColumnWidth === undefined ? 240 : _ref$idealColumnWidth,
        width = _ref.width;

    if (width == null) {
      return function (items) {
        return items.map(function () {
          return {
            top: Infinity,
            left: Infinity,
            width: Infinity,
            height: Infinity
          };
        });
      };
    }

    // "This is kind of crazy!" - you
    // Yes, indeed. The "guessing" here is meant to replicate the pass that the
    // original implementation takes with CSS.
    var colguess = Math.floor(width / idealColumnWidth);
    var columnCount = Math.max(Math.floor((width - colguess * gutter) / idealColumnWidth), minCols);
    var columnWidth = Math.floor(width / columnCount);

    return function (items) {
      // the total height of each column
      var heights = new Array(columnCount).fill(0);

      return items.reduce(function (acc, item) {
        var positions = acc;
        var height = cache.get(item);
        var position = void 0;

        if (height == null) {
          position = {
            top: Infinity,
            left: Infinity,
            width: columnWidth,
            height: Infinity
          };
        } else {
          var col = mindex$2(heights);
          var _top = heights[col];
          var _left = col * columnWidth + gutter / 2;

          heights[col] += height;
          position = {
            top: _top,
            left: _left,
            width: columnWidth - gutter,
            height: height
          };
        }

        positions.push(position);
        return positions;
      }, []);
    };
  });

  var MasonryLayout = function MasonryLayout() {
    classCallCheck(this, MasonryLayout);
  };

  var UniformRowLayout = function UniformRowLayout() {
    classCallCheck(this, UniformRowLayout);
  };

  var RESIZE_DEBOUNCE = 300;
  // Multiplied against container height.
  // The amount of extra buffer space for populating visible items.
  var VIRTUAL_BUFFER_FACTOR = 0.7;

  var layoutNumberToCssDimension = function layoutNumberToCssDimension(n) {
    return n !== Infinity ? n : undefined;
  };

  var Masonry = function (_React$Component) {
    inherits(Masonry, _React$Component);
    createClass(Masonry, null, [{
      key: 'createMeasurementStore',
      value: function createMeasurementStore() {
        return new MeasurementStore();
      }

      /**
       * Delays resize handling in case the scroll container is still being resized.
       */

    }]);

    function Masonry(props) {
      classCallCheck(this, Masonry);

      var _this = possibleConstructorReturn(this, (Masonry.__proto__ || Object.getPrototypeOf(Masonry)).call(this, props));

      _this.handleResize = debounce(function () {
        if (_this.gridWrapper) {
          _this.setState({ width: _this.gridWrapper.clientWidth });
        }
      }, RESIZE_DEBOUNCE);
      _this.updateScrollPosition = throttle(function () {
        if (!_this.scrollContainer) {
          return;
        }
        var scrollContainer = _this.scrollContainer.getScrollContainerRef();

        if (!scrollContainer) {
          return;
        }

        _this.setState({
          scrollTop: getScrollPos(scrollContainer)
        });
      });
      _this.measureContainerAsync = debounce(function () {
        _this.measureContainer();
      }, 0);

      _this.setGridWrapperRef = function (ref) {
        _this.gridWrapper = ref;
      };

      _this.setScrollContainerRef = function (ref) {
        _this.scrollContainer = ref;
      };

      _this.fetchMore = function () {
        var loadItems = _this.props.loadItems;

        if (loadItems && typeof loadItems === 'function') {
          _this.setState({
            isFetching: true
          }, function () {
            return loadItems({ from: _this.props.items.length });
          });
        }
      };

      _this.renderMasonryComponent = function (itemData, idx, position) {
        var _this$props = _this.props,
            Component = _this$props.comp,
            virtualize = _this$props.virtualize,
            virtualBoundsTop = _this$props.virtualBoundsTop,
            virtualBoundsBottom = _this$props.virtualBoundsBottom;
        var top = position.top,
            left = position.left,
            width = position.width,
            height = position.height;


        var isVisible = void 0;
        if (_this.props.scrollContainer) {
          var virtualBuffer = _this.containerHeight * VIRTUAL_BUFFER_FACTOR;
          var offsetScrollPos = _this.state.scrollTop - _this.containerOffset;
          var viewportTop = virtualBoundsTop ? offsetScrollPos - virtualBoundsTop : offsetScrollPos - virtualBuffer;
          var viewportBottom = virtualBoundsBottom ? offsetScrollPos + _this.containerHeight + virtualBoundsBottom : offsetScrollPos + _this.containerHeight + virtualBuffer;

          isVisible = !(position.top + position.height < viewportTop || position.top > viewportBottom);
        } else {
          // if no scroll container is passed in, items should always be visible
          isVisible = true;
        }

        var itemComponent = React.createElement(
          'div',
          {
            key: 'item-' + idx,
            className: [styles$h.Masonry__Item, styles$h.Masonry__Item__Mounted].join(' '),
            'data-grid-item': true,
            style: {
              top: 0,
              left: 0,
              transform: 'translateX(' + left + 'px) translateY(' + top + 'px)',
              WebkitTransform: 'translateX(' + left + 'px) translateY(' + top + 'px)',
              width: layoutNumberToCssDimension(width),
              height: layoutNumberToCssDimension(height)
            }
          },
          React.createElement(Component, { data: itemData, itemIdx: idx, isMeasuring: false })
        );

        return virtualize ? isVisible && itemComponent || null : itemComponent;
      };

      _this.containerHeight = 0;
      _this.containerOffset = 0;

      _this.state = {
        hasPendingMeasurements: props.items.some(function (item) {
          return !!item && !props.measurementStore.has(item);
        }),
        isFetching: false,
        // eslint-disable-next-line react/no-unused-state
        items: props.items,
        scrollTop: 0,
        width: undefined
      };
      return _this;
    }

    /**
     * Adds hooks after the component mounts.
     */


    createClass(Masonry, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        var _this2 = this;

        window.addEventListener('resize', this.handleResize);

        this.measureContainer();

        var scrollTop = this.state.scrollTop;

        if (this.scrollContainer != null) {
          var _scrollContainer = this.scrollContainer.getScrollContainerRef();
          if (_scrollContainer) {
            scrollTop = getScrollPos(_scrollContainer);
          }
        }

        this.setState(function (prevState) {
          return {
            scrollTop: scrollTop,
            width: _this2.gridWrapper ? _this2.gridWrapper.clientWidth : prevState.width
          };
        });
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps, prevState) {
        var _this3 = this;

        var _props = this.props,
            items = _props.items,
            measurementStore = _props.measurementStore;


        this.measureContainerAsync();

        if (prevState.width != null && this.state.width !== prevState.width) {
          measurementStore.reset();
        }
        // calculate whether we still have pending measurements
        var hasPendingMeasurements = items.some(function (item) {
          return !!item && !measurementStore.has(item);
        });
        if (hasPendingMeasurements || hasPendingMeasurements !== this.state.hasPendingMeasurements || prevState.width == null) {
          this.insertAnimationFrame = requestAnimationFrame(function () {
            _this3.setState({
              hasPendingMeasurements: hasPendingMeasurements
            });
          });
        }
      }

      /**
       * Remove listeners when unmounting.
       */

    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (this.insertAnimationFrame) {
          cancelAnimationFrame(this.insertAnimationFrame);
        }

        // Make sure async methods are cancelled.
        this.measureContainerAsync.clearTimeout();
        this.handleResize.clearTimeout();
        this.updateScrollPosition.clearTimeout();

        window.removeEventListener('resize', this.handleResize);
      }
    }, {
      key: 'measureContainer',
      value: function measureContainer() {
        if (this.scrollContainer != null) {
          var _scrollContainer2 = this.scrollContainer;

          var scrollContainerRef = _scrollContainer2.getScrollContainerRef();
          if (scrollContainerRef) {
            this.containerHeight = getElementHeight(scrollContainerRef);
            var el = this.gridWrapper;
            if (el instanceof HTMLElement) {
              var relativeScrollTop = getRelativeScrollTop(scrollContainerRef);
              this.containerOffset = el.getBoundingClientRect().top + relativeScrollTop;
            }
          }
        }
      }

      /**
       * Clear measurements/positions and force a reflow of the entire grid.
       * Only use this if absolutely necessary - ex: We need to reflow items if the
       * number of columns we would display should change after a resize.
       */

    }, {
      key: 'reflow',
      value: function reflow() {
        this.props.measurementStore.reset();
        this.measureContainer();
        this.forceUpdate();
      }
    }, {
      key: 'render',
      value: function render() {
        var _this4 = this;

        var _props2 = this.props,
            columnWidth = _props2.columnWidth,
            Component = _props2.comp,
            flexible = _props2.flexible,
            gutter = _props2.gutterWidth,
            measurementStore = _props2.measurementStore,
            items = _props2.items,
            minCols = _props2.minCols;
        var _state = this.state,
            hasPendingMeasurements = _state.hasPendingMeasurements,
            width = _state.width;


        var layout = void 0;
        if (flexible && width !== null) {
          layout = fullWidthLayout({
            gutter: gutter,
            cache: measurementStore,
            minCols: minCols,
            idealColumnWidth: columnWidth,
            width: width
          });
        } else if (this.props.layout === UniformRowLayoutSymbol || this.props.layout instanceof UniformRowLayout) {
          layout = uniformRowLayout({
            cache: measurementStore,
            columnWidth: columnWidth,
            gutter: gutter,
            minCols: minCols,
            width: width
          });
        } else {
          layout = defaultLayout({
            cache: measurementStore,
            columnWidth: columnWidth,
            gutter: gutter,
            minCols: minCols,
            width: width
          });
        }

        var gridBody = void 0;
        if (width == null && hasPendingMeasurements) {
          // When hyrdating from a server render, we don't have the width of the grid
          // and the measurement store is empty
          gridBody = React.createElement(
            'div',
            {
              className: styles$h.Masonry,
              style: { height: 0, width: '100%' },
              ref: this.setGridWrapperRef
            },
            items.filter(function (item) {
              return item;
            }).map(function (item, i) {
              return React.createElement(
                'div',
                { // keep this in sync with renderMasonryComponent
                  className: 'static',
                  'data-grid-item': true,
                  key: i,
                  style: {
                    top: 0,
                    left: 0,
                    transform: 'translateX(0px) translateY(0px)',
                    WebkitTransform: 'translateX(0px) translateY(0px)',
                    width: flexible ? undefined : layoutNumberToCssDimension(columnWidth) // we can't set a width for server rendered flexible items
                  },
                  ref: function ref(el) {
                    if (el && !flexible) {
                      // only measure flexible items on client
                      measurementStore.set(item, el.clientHeight);
                    }
                  }
                },
                React.createElement(Component, { data: item, itemIdx: i, isMeasuring: false })
              );
            })
          );
        } else if (width == null) {
          // When the width is empty (usually after a re-mount) render an empty
          // div to collect the width for layout
          gridBody = React.createElement('div', { style: { width: '100%' }, ref: this.setGridWrapperRef });
        } else {
          // Full layout is possible
          var itemsToRender = items.filter(function (item) {
            return item && measurementStore.has(item);
          });
          var itemsToMeasure = items.filter(function (item) {
            return item && !measurementStore.has(item);
          }).slice(0, minCols);

          var positions = layout(itemsToRender);
          var measuringPositions = layout(itemsToMeasure);
          // Math.max() === -Infinity when there are no positions
          var height = positions.length ? Math.max.apply(Math, toConsumableArray(positions.map(function (pos) {
            return pos.top + pos.height;
          }))) : 0;
          gridBody = React.createElement(
            'div',
            { style: { width: '100%' }, ref: this.setGridWrapperRef },
            React.createElement(
              'div',
              { className: styles$h.Masonry, style: { height: height, width: width } },
              itemsToRender.map(function (item, i) {
                return _this4.renderMasonryComponent(item, i, positions[i]);
              })
            ),
            React.createElement(
              'div',
              { className: styles$h.Masonry, style: { width: width } },
              itemsToMeasure.map(function (data, i) {
                // itemsToMeasure is always the length of minCols, so i will always be 0..minCols.length
                // we normalize the index here relative to the item list as a whole so that itemIdx is correct
                // and so that React doesnt reuse the measurement nodes
                var measurementIndex = itemsToRender.length + i;
                var position = measuringPositions[i];
                return React.createElement(
                  'div',
                  {
                    key: 'measuring-' + measurementIndex,
                    style: {
                      visibility: 'hidden',
                      position: 'absolute',
                      top: layoutNumberToCssDimension(position.top),
                      left: layoutNumberToCssDimension(position.left),
                      width: layoutNumberToCssDimension(position.width),
                      height: layoutNumberToCssDimension(position.height)
                    },
                    ref: function ref(el) {
                      if (el) {
                        measurementStore.set(data, el.clientHeight);
                      }
                    }
                  },
                  React.createElement(Component, {
                    data: data,
                    itemIdx: measurementIndex,
                    isMeasuring: true
                  })
                );
              })
            ),
            this.scrollContainer && React.createElement(FetchItems, {
              containerHeight: this.containerHeight,
              fetchMore: this.fetchMore,
              isFetching: this.state.isFetching || this.state.hasPendingMeasurements,
              scrollHeight: height,
              scrollTop: this.state.scrollTop
            })
          );
        }

        return this.props.scrollContainer ? React.createElement(
          ScrollContainer,
          {
            ref: this.setScrollContainerRef,
            onScroll: this.updateScrollPosition,
            scrollContainer: this.props.scrollContainer
          },
          gridBody
        ) : gridBody;
      }
    }], [{
      key: 'getDerivedStateFromProps',
      value: function getDerivedStateFromProps(props, state) {
        var items = props.items,
            measurementStore = props.measurementStore;
        // whenever we're receiving new props, determine whether any items need to be measured
        // TODO - we should treat items as immutable

        var hasPendingMeasurements = items.some(function (item) {
          return !measurementStore.has(item);
        });

        // Shallow compare all items, if any change reflow the grid.
        for (var i = 0; i < items.length; i += 1) {
          // We've reached the end of our current props and everything matches.
          // If we hit this case it means we need to insert new items.
          if (state.items[i] === undefined) {
            return {
              hasPendingMeasurements: hasPendingMeasurements,
              items: items,
              isFetching: false
            };
          }

          // Reset grid items when:
          if (
          // An item object ref does not match.
          items[i] !== state.items[i] ||
          // Or less items than we currently have are passed in.
          items.length < state.items.length) {
            return {
              hasPendingMeasurements: hasPendingMeasurements,
              items: items,
              isFetching: false
            };
          }
        }

        // Reset items if new items array is empty.
        if (items.length === 0 && state.items.length > 0) {
          return {
            hasPendingMeasurements: hasPendingMeasurements,
            items: items,
            isFetching: false
          };
        }
        if (hasPendingMeasurements !== state.hasPendingMeasurements) {
          // make sure we always update hasPendingMeasurements
          return {
            hasPendingMeasurements: hasPendingMeasurements,
            items: items
          };
        }

        // Return null to indicate no change to state.
        return null;
      }
    }]);
    return Masonry;
  }(React.Component);

  Masonry.propTypes = {
    /**
     * The preferred/target item width. If `flexible` is set, the item width will
     * grow to fill column space, and shrink to fit if below min columns.
     */
    columnWidth: PropTypes.number,

    /**
     * The component to render.
     */
    /* eslint react/no-unused-prop-types: 0 */
    comp: PropTypes.func.isRequired,

    /**
     * The preferred/target item width. Item width will grow to fill
     * column space, and shrink to fit if below min columns.
     */
    flexible: PropTypes.bool,

    /**
     * The amount of space between each item.
     */
    gutterWidth: PropTypes.number,

    /**
     * An array of all objects to display in the grid.
     */
    items: PropTypes.arrayOf(PropTypes.shape({})).isRequired,

    /**
     * Measurement Store
     */
    measurementStore: PropTypes.instanceOf(MeasurementStore),

    /**
     * Layout system to use for items
     */
    layout: PropTypes.oneOfType([PropTypes.instanceOf(MasonryLayout), PropTypes.instanceOf(UniformRowLayout), PropTypes.symbol]),

    /**
     * A callback which the grid calls when we need to load more items as the user scrolls.
     * The callback should update the state of the items, and pass those in as props
     * to this component.
     */
    loadItems: PropTypes.func,

    /**
     * Minimum number of columns to display.
     */
    minCols: PropTypes.number,

    /**
     * Function that the grid calls to get the scroll container.
     * This is required if the grid is expected to be scrollable.
     */
    scrollContainer: PropTypes.func,

    /**
     * Whether or not to use actual virtualization
     */
    virtualize: PropTypes.bool
  };
  Masonry.defaultProps = {
    columnWidth: 236,
    measurementStore: new MeasurementStore(),
    minCols: 3,
    layout: DefaultLayoutSymbol,
    loadItems: function loadItems() {},
    virtualize: false
  };

  var NoScrollBehavior = function (_React$Component) {
    inherits(NoScrollBehavior, _React$Component);

    function NoScrollBehavior(props) {
      classCallCheck(this, NoScrollBehavior);

      var _this = possibleConstructorReturn(this, (NoScrollBehavior.__proto__ || Object.getPrototypeOf(NoScrollBehavior)).call(this, props));

      _this.prevOverflow = null;
      return _this;
    }

    createClass(NoScrollBehavior, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        if (typeof window !== 'undefined') {
          this.prevOverflow = window.document.body.style.overflow;
          window.document.body.style.overflow = 'hidden';
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (typeof window !== 'undefined') {
          window.document.body.style.overflow = this.prevOverflow;
        }
      }
    }, {
      key: 'render',
      value: function render() {
        return this.props.children;
      }
    }]);
    return NoScrollBehavior;
  }(React.Component);

  function queryFocusableAll(el) {
    var selector = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'iframe', 'object', 'embed', '[tabindex="-1"]', '[tabindex="0"]', '[contenteditable]', 'audio[controls]', 'video[controls]', 'summary'].join(',');
    return el.querySelectorAll(selector);
  }

  var focusElement = function focusElement(el) {
    if (typeof el.focus === 'function') {
      el.focus();
    }
  };

  var TrapFocusBehavior = function (_React$Component) {
    inherits(TrapFocusBehavior, _React$Component);

    function TrapFocusBehavior() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, TrapFocusBehavior);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TrapFocusBehavior.__proto__ || Object.getPrototypeOf(TrapFocusBehavior)).call.apply(_ref, [this].concat(args))), _this), _this.setElRef = function (el) {
        if (el) {
          _this.el = el;
        }
      }, _this.handleFocus = function (event) {
        if (!_this.el || event.target instanceof Node && _this.el.contains(event.target)) {
          return;
        }

        event.stopPropagation();
        event.preventDefault();
        _this.focusFirstChild();
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(TrapFocusBehavior, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        this.previouslyFocusedEl = document.activeElement;
        this.focusFirstChild();
        document.addEventListener('focus', this.handleFocus, true);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        document.removeEventListener('focus', this.handleFocus, true);
        if (this.previouslyFocusedEl) {
          focusElement(this.previouslyFocusedEl);
        }
      }
    }, {
      key: 'focusFirstChild',
      value: function focusFirstChild() {
        var el = this.el;

        if (el) {
          focusElement(queryFocusableAll(el)[0]);
        }
      }
    }, {
      key: 'render',
      value: function render() {
        return React.createElement(
          'div',
          { ref: this.setElRef },
          this.props.children
        );
      }
    }]);
    return TrapFocusBehavior;
  }(React.Component);

  var styles$i = { "Backdrop": "_uj _4h _4m _4j _4k _4l _za _3d", "container": "_uk _4g _4q _4s _5a _4m _4j _50 _y7", "wrapper": "_ul _4f _49 _4s _37 _2y _70 _6y" };

  var SIZE_WIDTH_MAP$1 = {
    sm: 414,
    md: 544,
    lg: 804
  };

  var ESCAPE_KEY_CODE$1 = 27;

  var Backdrop = function Backdrop(_ref) {
    var children = _ref.children;
    return React.createElement(
      React.Fragment,
      null,
      React.createElement('div', { className: styles$i.Backdrop }),
      children
    );
  };

  var Modal = function (_React$Component) {
    inherits(Modal, _React$Component);

    function Modal() {
      var _ref2;

      var _temp, _this, _ret;

      classCallCheck(this, Modal);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref2 = Modal.__proto__ || Object.getPrototypeOf(Modal)).call.apply(_ref2, [this].concat(args))), _this), _this.handleOutsideClick = function () {
        _this.props.onDismiss();
      }, _this.handleCloseClick = function () {
        _this.props.onDismiss();
      }, _this.handleKeyUp = function (event) {
        if (event.keyCode === ESCAPE_KEY_CODE$1) {
          _this.props.onDismiss();
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Modal, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        window.addEventListener('keyup', this.handleKeyUp);
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        window.removeEventListener('keyup', this.handleKeyUp);
      }
    }, {
      key: 'render',
      value: function render() {
        var _props = this.props,
            accessibilityCloseLabel = _props.accessibilityCloseLabel,
            accessibilityModalLabel = _props.accessibilityModalLabel,
            children = _props.children,
            footer = _props.footer,
            heading = _props.heading,
            _props$role = _props.role,
            role = _props$role === undefined ? 'dialog' : _props$role,
            _props$size = _props.size,
            size = _props$size === undefined ? 'sm' : _props$size;

        var width = SIZE_WIDTH_MAP$1[size];

        return React.createElement(
          NoScrollBehavior,
          null,
          React.createElement(
            TrapFocusBehavior,
            null,
            React.createElement(
              'div',
              {
                'aria-label': accessibilityModalLabel,
                className: styles$i.container,
                role: role
              },
              React.createElement(
                Backdrop,
                null,
                React.createElement(
                  OutsideEventBehavior,
                  { onClick: this.handleOutsideClick },
                  React.createElement(
                    'div',
                    { className: styles$i.wrapper, tabIndex: -1, style: { width: width } },
                    React.createElement(
                      Box,
                      {
                        flex: 'grow',
                        position: 'relative',
                        display: 'flex',
                        direction: 'column',
                        width: '100%'
                      },
                      React.createElement(
                        Box,
                        { fit: true },
                        role === 'dialog' ? React.createElement(
                          Box,
                          {
                            dangerouslySetInlineStyle: {
                              __style: { paddingLeft: 50, paddingRight: 50 }
                            },
                            display: 'flex',
                            justifyContent: 'center',
                            paddingY: 5
                          },
                          React.createElement(
                            Heading,
                            { size: 'xs', accessibilityLevel: 1 },
                            heading
                          )
                        ) : React.createElement(
                          Box,
                          { display: 'flex', padding: 4 },
                          React.createElement(
                            Heading,
                            { size: 'sm', accessibilityLevel: 1 },
                            heading
                          )
                        ),
                        role === 'dialog' && React.createElement(
                          Box,
                          { padding: 2, position: 'absolute', top: true, right: true },
                          React.createElement(IconButton, {
                            accessibilityLabel: accessibilityCloseLabel,
                            icon: 'cancel',
                            onClick: this.handleCloseClick
                          })
                        ),
                        role === 'dialog' && React.createElement(Divider, null)
                      ),
                      React.createElement(
                        Box,
                        { flex: 'grow', overflow: 'auto', position: 'relative' },
                        children
                      ),
                      React.createElement(
                        Box,
                        { fit: true },
                        footer && React.createElement(
                          Box,
                          null,
                          role === 'dialog' && React.createElement(Divider, null),
                          React.createElement(
                            Box,
                            { padding: 4 },
                            footer
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        );
      }
    }]);
    return Modal;
  }(React.Component);

  Modal.propTypes = {
    children: PropTypes.node,
    accessibilityCloseLabel: PropTypes.string.isRequired,
    footer: PropTypes.node,
    heading: PropTypes.string.isRequired,
    accessibilityModalLabel: PropTypes.string.isRequired,
    onDismiss: PropTypes.func,
    role: PropTypes.oneOf(['alertdialog', 'dialog']),
    size: PropTypes.oneOf(['sm', 'md', 'lg'])
  };

  var styles$j = { "innerCircle": "_ut _4q", "PulseAnimation": "_uu", "outerCircle": "_uv", "AppearAnimation": "_uw" };

  function Pulsar(props) {
    var paused = props.paused,
        _props$size = props.size,
        size = _props$size === undefined ? 135 : _props$size;


    return React.createElement(
      Box,
      {
        dangerouslySetInlineStyle: {
          __style: {
            animationIterationCount: paused ? 0 : 'infinite',
            outline: 'none',
            boxShadow: 'none'
          }
        },
        display: paused ? 'none' : 'block',
        height: size,
        position: 'relative',
        width: size
      },
      React.createElement(
        'div',
        { className: styles$j.innerCircle },
        React.createElement('div', { className: styles$j.outerCircle })
      )
    );
  }

  Pulsar.propTypes = {
    paused: PropTypes.bool,
    size: PropTypes.number
  };

  var styles$k = { "RadioButton": "_ux _45 _4q _2w _4s _50 _5a", "RadioButtonSm": "_uy", "RadioButtonMd": "_uz", "RadioButtonIsFocused": "_v0 _xu", "RadioButtonWhiteBg": "_v1 _37", "RadioButtonLightGrayBg": "_v2 _39", "Input": "_v3 _4h _od", "InputEnabled": "_v4 _z8", "InputSm": "_v5", "InputMd": "_v6", "Check": "_v7 _2w", "CheckEnabled": "_v8 _3d", "CheckDisabled": "_v9 _3b" };

  var RadioButton = function (_React$Component) {
    inherits(RadioButton, _React$Component);

    function RadioButton() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, RadioButton);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = RadioButton.__proto__ || Object.getPrototypeOf(RadioButton)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        focused: false
      }, _this.handleChange = function (event) {
        var checked = event.target.checked;

        _this.props.onChange({ checked: checked, event: event });
      }, _this.handleBlur = function () {
        return _this.setState({ focused: false });
      }, _this.handleFocus = function () {
        _this.setState({ focused: true });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(RadioButton, [{
      key: 'render',
      value: function render() {
        var _classnames, _classnames2, _classnames3;

        var _props = this.props,
            checked = _props.checked,
            disabled = _props.disabled,
            id = _props.id,
            name = _props.name,
            size = _props.size,
            value = _props.value;

        return React.createElement(
          'div',
          {
            className: classnames(styles$k.RadioButton, (_classnames = {}, defineProperty(_classnames, styles$k.RadioButtonIsFocused, this.state.focused), defineProperty(_classnames, styles$k.RadioButtonSm, size === 'sm'), defineProperty(_classnames, styles$k.RadioButtonMd, size === 'md'), defineProperty(_classnames, styles$k.RadioButtonWhiteBg, !disabled || checked), defineProperty(_classnames, styles$k.RadioButtonLightGrayBg, disabled && !checked), _classnames))
          },
          React.createElement('input', {
            checked: checked,
            className: classnames(styles$k.Input, (_classnames2 = {}, defineProperty(_classnames2, styles$k.InputEnabled, !disabled), defineProperty(_classnames2, styles$k.InputSm, size === 'sm'), defineProperty(_classnames2, styles$k.InputMd, size === 'md'), _classnames2)),
            disabled: disabled,
            id: id,
            name: name,
            onBlur: this.handleBlur,
            onChange: this.handleChange,
            onFocus: this.handleFocus,
            type: 'radio',
            value: value
          }),
          checked && React.createElement('div', {
            className: classnames(styles$k.Check, (_classnames3 = {}, defineProperty(_classnames3, styles$k.CheckSm, size === 'sm'), defineProperty(_classnames3, styles$k.CheckMd, size === 'md'), defineProperty(_classnames3, styles$k.CheckEnabled, !disabled), defineProperty(_classnames3, styles$k.CheckDisabled, disabled), _classnames3))
          })
        );
      }
    }]);
    return RadioButton;
  }(React.Component);

  RadioButton.propTypes = {
    checked: PropTypes.bool,
    disabled: PropTypes.bool,
    id: PropTypes.string.isRequired,
    name: PropTypes.string,
    onChange: PropTypes.func.isRequired,
    value: PropTypes.string.isRequired,
    size: PropTypes.oneOf(['sm', 'md'])
  };
  RadioButton.defaultProps = {
    checked: false,
    disabled: false,
    size: 'md'
  };

  var ScrollFetch = function (_React$PureComponent) {
    inherits(ScrollFetch, _React$PureComponent);

    function ScrollFetch() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, ScrollFetch);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = ScrollFetch.__proto__ || Object.getPrototypeOf(ScrollFetch)).call.apply(_ref, [this].concat(args))), _this), _this.updatePosition = throttle(function () {
        _this.setState(_this.getScrollState());
      }), _this.state = {
        containerHeight: 0,
        scrollHeight: 0,
        scrollTop: 0
      }, _this.getScrollHeight = function () {
        var container = _this.props.container;

        if (!container) {
          return 0;
        }
        return getScrollHeight(container);
      }, _temp), possibleConstructorReturn(_this, _ret);
    }
    /**
     * Fetches additional items if needed.
     */


    createClass(ScrollFetch, [{
      key: 'componentDidMount',


      /**
       * Adds scroll listener after the component mounts.
       */
      value: function componentDidMount() {
        var _this2 = this;

        var container = this.props.container;

        if (!container) {
          return;
        }
        setTimeout(function () {
          _this2.setState(_extends({
            containerHeight: getElementHeight(container)
          }, _this2.getScrollState()));
        });
      }

      /**
       * Update scroll buffer and check after the component updates.
       */

    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate() {
        // setTimeout so the parent component can calculate renderHeight().
        this.updatePosition();
      }

      /**
       * Returns the scrollable content height.
       */

    }, {
      key: 'getScrollState',
      value: function getScrollState() {
        var _props = this.props,
            container = _props.container,
            renderHeight = _props.renderHeight;

        if (!container) {
          return null;
        }
        var scrollHeight = renderHeight || this.getScrollHeight;

        return {
          scrollHeight: scrollHeight(),
          scrollTop: getScrollPos(container)
        };
      }
    }, {
      key: 'render',
      value: function render() {
        var _state = this.state,
            containerHeight = _state.containerHeight,
            scrollHeight = _state.scrollHeight,
            scrollTop = _state.scrollTop;
        var _props2 = this.props,
            container = _props2.container,
            fetchMore = _props2.fetchMore,
            isAtEnd = _props2.isAtEnd,
            isFetching = _props2.isFetching;


        var props = {
          containerHeight: containerHeight,
          fetchMore: fetchMore,
          isAtEnd: isAtEnd,
          isFetching: isFetching,
          scrollHeight: scrollHeight,
          scrollTop: scrollTop
        };

        if (!container || isAtEnd) {
          return null;
        }
        return React.createElement(
          ScrollContainer,
          {
            onScroll: this.updatePosition,
            scrollContainer: container
          },
          React.createElement(FetchItems, props)
        );
      }
    }]);
    return ScrollFetch;
  }(React.PureComponent);


  ScrollFetch.propTypes = {
    /**
     * The scroll container to use. Defaults to window.
     */
    container: PropTypes.shape({
      addEventListener: PropTypes.func,
      removeEventListener: PropTypes.func
    }),
    renderHeight: PropTypes.func,
    isAtEnd: PropTypes.bool,
    isFetching: PropTypes.bool,
    fetchMore: PropTypes.func
  };

  ScrollFetch.defaultProps = {
    container: typeof window !== 'undefined' ? window : null
  };

  var styles$l = { "input": "_va _xt _2q _4q _4o _3c _w6 _0 _1 _2 _w9 _6 _39 _y7", "clear": "_vb _33 _z8 _6s _6r _4f" };

  var SearchField = function (_React$Component) {
    inherits(SearchField, _React$Component);

    function SearchField() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, SearchField);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SearchField.__proto__ || Object.getPrototypeOf(SearchField)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        focused: false,
        hovered: false
      }, _this.handleChange = function (event) {
        _this.props.onChange({
          value: event.currentTarget.value,
          syntheticEvent: event
        });
      }, _this.handleClear = function (event) {
        _this.props.onChange({
          value: '',
          syntheticEvent: event
        });
      }, _this.handleMouseEnter = function () {
        return _this.setState({ hovered: true });
      }, _this.handleMouseLeave = function () {
        return _this.setState({ hovered: false });
      }, _this.handleFocus = function (event) {
        _this.setState({ focused: true });

        if (_this.props.onFocus) {
          _this.props.onFocus({
            value: event.currentTarget.value,
            syntheticEvent: event
          });
        }
      }, _this.handleBlur = function (event) {
        _this.setState({ focused: false });

        if (_this.props.onBlur) {
          _this.props.onBlur({ event: event });
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(SearchField, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            accessibilityLabel = _props.accessibilityLabel,
            id = _props.id,
            placeholder = _props.placeholder,
            value = _props.value;

        // This mirrors the built in browser behavior. If there's a value, show the
        // clear button if you're hovering or if you've focused on the field

        var showClear = (this.state.focused || this.state.hovered) && value && value.length > 0;

        return React.createElement(
          Box,
          {
            display: 'flex',
            position: 'relative',
            alignItems: 'center',
            onMouseEnter: this.handleMouseEnter,
            onMouseLeave: this.handleMouseLeave,
            onFocus: this.handleFocus,
            onBlur: this.handleBlur,
            color: 'white'
          },
          React.createElement(
            Box,
            {
              dangerouslySetInlineStyle: {
                __style: {
                  pointerEvents: 'none',
                  // Added the following lines for Safari support
                  top: '50%',
                  transform: 'translateY(-50%)'
                }
              },
              position: 'absolute',
              left: true,
              paddingX: 4
            },
            React.createElement(Icon, { icon: 'search', accessibilityLabel: '' })
          ),
          React.createElement('input', {
            'aria-label': accessibilityLabel,
            className: styles$l.input,
            id: id,
            onChange: this.handleChange,
            placeholder: placeholder,
            role: 'searchbox',
            type: 'search',
            value: value
          }),
          showClear && React.createElement(
            Box,
            { position: 'absolute', right: true, top: true },
            React.createElement(
              'button',
              {
                className: styles$l.clear,
                onClick: this.handleClear,
                tabIndex: -1,
                type: 'button'
              },
              React.createElement(Icon, { icon: 'clear', accessibilityLabel: '' })
            )
          )
        );
      }
    }]);
    return SearchField;
  }(React.Component);

  SearchField.propTypes = {
    accessibilityLabel: PropTypes.string.isRequired,
    id: PropTypes.string.isRequired,
    onBlur: PropTypes.func,
    onChange: PropTypes.func.isRequired,
    onFocus: PropTypes.func,
    placeholder: PropTypes.string,
    value: PropTypes.string
  };

  var styles$m = { "SegmentedControl": "_vc _4q _39 _4s _5b", "md": "_vd _4o", "lg": "_ve _4p", "item": "_vf _xt _5j _od _33 _z8", "itemIsNotSelected": "_vg", "itemIsSelected": "_vh _37" };

  function SegmentedControl(props) {
    var _classnames;

    var items = props.items,
        onChange = props.onChange,
        selectedItemIndex = props.selectedItemIndex,
        _props$size = props.size,
        size = _props$size === undefined ? 'md' : _props$size;

    return React.createElement(
      'div',
      {
        className: classnames(styles$m.SegmentedControl, (_classnames = {}, defineProperty(_classnames, styles$m.md, size === 'md'), defineProperty(_classnames, styles$m.lg, size === 'lg'), _classnames)),
        role: 'tablist'
      },
      items.map(function (item, i) {
        var _classnames2;

        var isSelected = i === selectedItemIndex;
        var cs = classnames(styles$m.item, (_classnames2 = {}, defineProperty(_classnames2, styles$m.itemIsNotSelected, !isSelected), defineProperty(_classnames2, styles$m.itemIsSelected, isSelected), _classnames2));
        return React.createElement(
          'button',
          {
            'aria-selected': isSelected,
            className: cs,
            key: i,
            onClick: function onClick(e) {
              return onChange({ event: e, activeIndex: i });
            },
            role: 'tab',
            type: 'button'
          },
          typeof item === 'string' ? React.createElement(
            Text,
            {
              bold: true,
              color: isSelected ? 'darkGray' : 'gray',
              align: 'center',
              size: size
            },
            item
          ) : React.createElement(
            Box,
            { display: 'flex', justifyContent: 'center' },
            item
          )
        );
      })
    );
  }

  SegmentedControl.propTypes = {
    items: PropTypes.arrayOf(PropTypes.node).isRequired,
    onChange: PropTypes.func.isRequired,
    selectedItemIndex: PropTypes.number.isRequired
  };

  var styles$n = { "select": "_vi _xt _w6 _0 _1 _2 _w9 _3c _z8 _4f _4o _42 _y7", "normal": "_vj", "errored": "_vk", "enabled": "_vl _3c _37", "disabled": "_vm _3a _39" };

  var SelectList = function (_React$Component) {
    inherits(SelectList, _React$Component);

    function SelectList() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, SelectList);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = SelectList.__proto__ || Object.getPrototypeOf(SelectList)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        focused: false,
        errorIsOpen: false
      }, _this.handleOnChange = function (event) {
        if (event.target instanceof HTMLSelectElement && _this.props.value !== event.target.value) {
          _this.props.onChange({ event: event, value: event.target.value });

          if (_this.props.errorMessage) {
            _this.setState({ errorIsOpen: false });
          }
        }
      }, _this.handleBlur = function () {
        if (_this.props.errorMessage) {
          _this.setState({ errorIsOpen: false });
        }
      }, _this.handleFocus = function () {
        if (_this.props.errorMessage) {
          _this.setState({ errorIsOpen: true });
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(SelectList, [{
      key: 'render',
      value: function render() {
        var _this2 = this;

        var _props = this.props,
            disabled = _props.disabled,
            errorMessage = _props.errorMessage,
            id = _props.id,
            idealErrorDirection = _props.idealErrorDirection,
            name = _props.name,
            options = _props.options,
            placeholder = _props.placeholder,
            value = _props.value;


        var classes = classnames(styles$n.select, disabled ? styles$n.disabled : styles$n.enabled, errorMessage ? styles$n.errored : styles$n.normal);

        return React.createElement(
          Box,
          {
            color: disabled ? 'lightGray' : 'white',
            dangerouslySetInlineStyle: { __style: { borderRadius: 4 } },
            display: 'flex',
            position: 'relative',
            width: '100%'
          },
          React.createElement(
            Box,
            {
              alignItems: 'center',
              bottom: true,
              dangerouslySetInlineStyle: {
                __style: { paddingRight: 14, paddingTop: 2 }
              },
              display: 'flex',
              position: 'absolute',
              right: true,
              top: true
            },
            React.createElement(Icon, {
              icon: 'arrow-down',
              size: 12,
              color: disabled ? 'gray' : 'darkGray',
              accessibilityLabel: ''
            })
          ),
          React.createElement(
            'select',
            {
              'aria-describedby': errorMessage && this.state.focused ? id + '-gestalt-error' : null,
              'aria-invalid': errorMessage ? 'true' : 'false',
              className: classes,
              disabled: disabled,
              id: id,
              name: name,
              onBlur: this.handleBlur,
              onFocus: this.handleFocus,
              onChange: this.handleOnChange,
              ref: function ref(c) {
                _this2.select = c;
              },
              value: value
            },
            placeholder && !value && React.createElement(
              'option',
              { selected: true, disabled: true, value: true, hidden: true },
              placeholder
            ),
            options.map(function (option) {
              return React.createElement(
                'option',
                { key: option.value, value: option.value },
                option.label
              );
            })
          ),
          errorMessage && this.state.errorIsOpen && React.createElement(
            Flyout,
            {
              anchor: this.select,
              color: 'orange',
              idealDirection: idealErrorDirection,
              onDismiss: function onDismiss() {
                return _this2.setState({ errorIsOpen: false });
              },
              size: 'sm'
            },
            React.createElement(
              Box,
              { padding: 3 },
              React.createElement(
                Text,
                { bold: true, color: 'white' },
                React.createElement(
                  'span',
                  { id: id + '-gestalt-error' },
                  errorMessage
                )
              )
            )
          )
        );
      }
    }], [{
      key: 'getDerivedStateFromProps',
      value: function getDerivedStateFromProps(props, state) {
        if (props.errorMessage !== state.errorMessage) {
          return {
            errorIsOpen: !!props.errorMessage,
            errorMessage: props.errorMessage
          };
        }

        return null;
      }
    }]);
    return SelectList;
  }(React.Component);

  SelectList.propTypes = {
    disabled: PropTypes.bool,
    errorMessage: PropTypes.string,
    id: PropTypes.string.isRequired,
    idealErrorDirection: PropTypes.string,
    name: PropTypes.string,
    onChange: PropTypes.func.isRequired,
    options: PropTypes.arrayOf(PropTypes.exact({
      label: PropTypes.string.isRequired,
      value: PropTypes.string.isRequired
    })),
    placeholder: PropTypes.string,
    value: PropTypes.string
  };
  SelectList.defaultProps = {
    disabled: false,
    idealErrorDirection: 'right',
    options: []
  };

  var styles$o = { "icon": "_vn _45", "spin": "_vo" };

  var SIZE = 40;

  function Spinner(_ref) {
    var accessibilityLabel = _ref.accessibilityLabel,
        show = _ref.show;

    return show ? React.createElement(
      Box,
      { xs: { display: 'flex' }, justifyContent: 'around', overflow: 'hidden' },
      React.createElement(
        'div',
        { className: styles$o.icon },
        React.createElement(Icon, {
          icon: 'knoop',
          accessibilityLabel: accessibilityLabel,
          size: SIZE
        })
      )
    ) : React.createElement('div', null);
  }

  Spinner.propTypes = {
    show: PropTypes.bool.isRequired,
    accessibilityLabel: PropTypes.string.isRequired
  };

  function Sticky(props) {
    var _props$dangerouslySet = props.dangerouslySetZIndex,
        dangerouslySetZIndex = _props$dangerouslySet === undefined ? { __zIndex: 1 } : _props$dangerouslySet,
        children = props.children;

    var style = {
      top: props.top != null ? props.top : undefined,
      left: props.left != null ? props.left : undefined,
      right: props.right != null ? props.right : undefined,
      bottom: props.bottom != null ? props.bottom : undefined,
      // eslint-disable-next-line no-underscore-dangle
      zIndex: dangerouslySetZIndex.__zIndex
    };
    return React.createElement(
      'div',
      { className: layout.sticky, style: style },
      children
    );
  }

  Sticky.propTypes = {
    children: PropTypes.node,
    dangerouslySetZIndex: PropTypes.exact({
      __zIndex: PropTypes.number
    }),
    top: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    left: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    bottom: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    right: PropTypes.oneOfType([PropTypes.number, PropTypes.string])
  };

  var styles$p = { "switch": "_vp _45 _4q _4f", "focused": "_vq _xu", "switchDarkGray": "_vr _3d", "switchGray": "_vs _3b", "switchLightGray": "_vt _39", "switchWhite": "_vu _37", "slider": "_vv _4q _4h _37 _2w", "sliderRight": "_vw", "sliderLeft": "_vx", "sliderDark": "_vy", "sliderLight": "_vz", "checkbox": "_w0 _4h _y7 _od _33 _oi", "checkboxEnabled": "_w1 _z8" };

  var Switch = function (_React$Component) {
    inherits(Switch, _React$Component);

    function Switch() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Switch);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Switch.__proto__ || Object.getPrototypeOf(Switch)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        focused: false
      }, _this.handleBlur = function () {
        return _this.setState({ focused: false });
      }, _this.handleChange = function (event) {
        var checked = event.target.checked;

        _this.props.onChange({
          event: event,
          value: checked
        });
      }, _this.handleFocus = function () {
        _this.setState({ focused: true });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Switch, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            disabled = _props.disabled,
            id = _props.id,
            name = _props.name,
            switched = _props.switched;


        var switchStyles = classnames(styles$p.switch, defineProperty({}, styles$p.focused, this.state.focused),
        // eslint-disable-next-line no-nested-ternary
        disabled ? switched ? styles$p.switchGray : styles$p.switchLightGray : switched ? styles$p.switchDarkGray : styles$p.switchWhite);

        var sliderStyles = classnames(styles$p.slider, switched ? styles$p.sliderRight : styles$p.sliderLeft, switched && !disabled ? styles$p.sliderDark : styles$p.sliderLight);

        var inputStyles = classnames(styles$p.checkbox, defineProperty({}, styles$p.checkboxEnabled, !disabled));

        return React.createElement(
          'div',
          { className: switchStyles },
          React.createElement('input', {
            checked: switched,
            className: inputStyles,
            disabled: disabled,
            id: id,
            name: name,
            onBlur: this.handleBlur,
            onChange: this.handleChange,
            onFocus: this.handleFocus,
            type: 'checkbox'
          }),
          React.createElement('div', { className: sliderStyles })
        );
      }
    }]);
    return Switch;
  }(React.Component);

  Switch.propTypes = {
    disabled: PropTypes.bool,
    id: PropTypes.string.isRequired,
    name: PropTypes.string,
    onChange: PropTypes.func.isRequired,
    switched: PropTypes.bool
  };
  Switch.defaultProps = {
    disabled: false,
    switched: false
  };

  var styles$q = { "Tabs": "_w2 _4s", "tab": "_w3 _xt _4q _4o _4s _4w undefined _5a _33 _2x _od _z8", "tabIsNotActive": "_w4 _42 _3a", "tabIsActive": "_w5 _39 _3c" };

  var Tabs = function (_React$Component) {
    inherits(Tabs, _React$Component);

    function Tabs() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Tabs);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Tabs.__proto__ || Object.getPrototypeOf(Tabs)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        focusedTabIndex: undefined,
        hoveredTabIndex: undefined
      }, _this.handleTabClick = function (i, e) {
        var onChange = _this.props.onChange;

        onChange({ activeTabIndex: i, event: e });
      }, _this.handleTabFocus = function (i) {
        return _this.setState({ focusedTabIndex: i });
      }, _this.handleTabBlur = function () {
        return _this.setState({ focusedTabIndex: undefined });
      }, _this.handleTabMouseEnter = function (i) {
        return _this.setState({ hoveredTabIndex: i });
      }, _this.handleTabMouseLeave = function () {
        return _this.setState({ hoveredTabIndex: undefined });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Tabs, [{
      key: 'render',
      value: function render() {
        var _this2 = this;

        var _props = this.props,
            tabs = _props.tabs,
            activeTabIndex = _props.activeTabIndex;
        var _state = this.state,
            focusedTabIndex = _state.focusedTabIndex,
            hoveredTabIndex = _state.hoveredTabIndex;

        return React.createElement(
          'div',
          { className: styles$q.Tabs, role: 'tablist' },
          tabs.map(function (_ref2, i) {
            var _classnames;

            var text = _ref2.text,
                href = _ref2.href;

            var isActive = i === activeTabIndex;
            var isHovered = i === hoveredTabIndex;
            var isFocused = i === focusedTabIndex;
            var cs = classnames(styles$q.tab, (_classnames = {}, defineProperty(_classnames, styles$q.tabIsNotActive, !isActive), defineProperty(_classnames, styles$q.tabIsActive, isActive), _classnames));
            return React.createElement(
              'a',
              {
                'aria-selected': isActive,
                className: cs,
                href: href,
                key: i,
                onClick: function onClick(e) {
                  return _this2.handleTabClick(i, e);
                },
                onFocus: function onFocus() {
                  return _this2.handleTabFocus(i);
                },
                onBlur: _this2.handleTabBlur,
                onMouseEnter: function onMouseEnter() {
                  return _this2.handleTabMouseEnter(i);
                },
                onMouseLeave: _this2.handleTabMouseLeave,
                role: 'tab'
              },
              React.createElement(
                Text,
                {
                  bold: true,
                  color: isActive || isHovered || isFocused ? 'darkGray' : 'gray',
                  size: 'md'
                },
                text
              )
            );
          })
        );
      }
    }]);
    return Tabs;
  }(React.Component);

  Tabs.propTypes = {
    activeTabIndex: PropTypes.number.isRequired,
    tabs: PropTypes.arrayOf(PropTypes.exact({
      text: PropTypes.node,
      href: PropTypes.string
    })).isRequired,
    onChange: PropTypes.func.isRequired
  };

  var styles$r = { "textArea": "_wr _xt _4q _w6 _0 _1 _2 _w9 _4 _y7", "normal": "_ws", "errored": "_wt", "enabled": "_wu _3c _37", "disabled": "_wv _3a _39" };

  var TextArea = function (_React$Component) {
    inherits(TextArea, _React$Component);

    function TextArea() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, TextArea);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TextArea.__proto__ || Object.getPrototypeOf(TextArea)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        focused: false,
        errorIsOpen: false
      }, _this.handleChange = function (event) {
        _this.props.onChange({
          event: event,
          value: event.currentTarget.value
        });

        if (_this.props.errorMessage) {
          _this.setState({ errorIsOpen: true });
        }
      }, _this.handleBlur = function (event) {
        if (_this.props.errorMessage) {
          _this.setState({ errorIsOpen: false });
        }
        if (_this.props.onBlur) {
          _this.props.onBlur({
            event: event,
            value: event.currentTarget.value
          });
        }
      }, _this.handleFocus = function (event) {
        if (_this.props.errorMessage) {
          _this.setState({ errorIsOpen: true });
        }
        if (_this.props.onFocus) {
          _this.props.onFocus({
            event: event,
            value: event.currentTarget.value
          });
        }
      }, _this.handleKeyDown = function (event) {
        if (_this.props.onKeyDown) {
          _this.props.onKeyDown({
            event: event,
            value: event.currentTarget.value
          });
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(TextArea, [{
      key: 'render',
      value: function render() {
        var _this2 = this;

        var _props = this.props,
            disabled = _props.disabled,
            errorMessage = _props.errorMessage,
            hasError = _props.hasError,
            id = _props.id,
            idealErrorDirection = _props.idealErrorDirection,
            name = _props.name,
            placeholder = _props.placeholder,
            rows = _props.rows,
            value = _props.value;


        var classes = classnames(styles$r.textArea, disabled ? styles$r.disabled : styles$r.enabled, hasError || errorMessage ? styles$r.errored : styles$r.normal);

        return React.createElement(
          'span',
          null,
          React.createElement('textarea', {
            'aria-describedby': errorMessage && this.state.focused ? id + '-gestalt-error' : null,
            'aria-invalid': errorMessage || hasError ? 'true' : 'false',
            className: classes,
            disabled: disabled,
            id: id,
            name: name,
            onBlur: this.handleBlur,
            onChange: this.handleChange,
            onFocus: this.handleFocus,
            onKeyDown: this.handleKeyDown,
            placeholder: placeholder,
            ref: function ref(c) {
              _this2.textarea = c;
            },
            rows: rows,
            value: value
          }),
          errorMessage && this.state.errorIsOpen ? React.createElement(
            Flyout,
            {
              anchor: this.textarea,
              color: 'orange',
              idealDirection: idealErrorDirection,
              onDismiss: function onDismiss() {
                return _this2.setState({ errorIsOpen: false });
              },
              size: 'sm'
            },
            React.createElement(
              Box,
              { padding: 3 },
              React.createElement(
                Text,
                { bold: true, color: 'white' },
                React.createElement(
                  'span',
                  { id: id + '-gestalt-error' },
                  errorMessage
                )
              )
            )
          ) : null
        );
      }
    }], [{
      key: 'getDerivedStateFromProps',
      value: function getDerivedStateFromProps(props, state) {
        if (props.errorMessage !== state.errorMessage) {
          return {
            errorIsOpen: !!props.errorMessage,
            errorMessage: props.errorMessage
          };
        }

        return null;
      }
    }]);
    return TextArea;
  }(React.Component);

  TextArea.propTypes = {
    disabled: PropTypes.bool,
    errorMessage: PropTypes.string,
    hasError: PropTypes.bool,
    id: PropTypes.string.isRequired,
    idealErrorDirection: PropTypes.string,
    name: PropTypes.string,
    onBlur: PropTypes.func,
    onChange: PropTypes.func.isRequired,
    onFocus: PropTypes.func,
    onKeyDown: PropTypes.func,
    placeholder: PropTypes.string,
    rows: PropTypes.number,
    value: PropTypes.string
  };
  TextArea.defaultProps = {
    disabled: false,
    hasError: false,
    idealErrorDirection: 'right',
    rows: 3
  };

  var styles$s = { "textField": "_ww _xt _4q _4o _w6 _0 _1 _2 _w9 _y7", "normal": "_wx", "errored": "_wy", "enabled": "_wz _3c _37", "disabled": "_x0 _3a _39" };

  var TextField = function (_React$Component) {
    inherits(TextField, _React$Component);

    function TextField() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, TextField);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = TextField.__proto__ || Object.getPrototypeOf(TextField)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        focused: false,
        errorIsOpen: false
      }, _this.handleChange = function (event) {
        _this.props.onChange({
          event: event,
          value: event.currentTarget.value
        });
      }, _this.handleBlur = function (event) {
        if (_this.props.errorMessage) {
          _this.setState({ errorIsOpen: false });
        }
        if (_this.props.onBlur) {
          _this.props.onBlur({
            event: event,
            value: event.currentTarget.value
          });
        }
      }, _this.handleFocus = function (event) {
        if (_this.props.errorMessage) {
          _this.setState({ errorIsOpen: true });
        }
        if (_this.props.onFocus) {
          _this.props.onFocus({
            event: event,
            value: event.currentTarget.value
          });
        }
      }, _this.handleKeyDown = function (event) {
        if (_this.props.onKeyDown) {
          _this.props.onKeyDown({
            event: event,
            value: event.currentTarget.value
          });
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(TextField, [{
      key: 'render',
      value: function render() {
        var _this2 = this;

        var _props = this.props,
            autoComplete = _props.autoComplete,
            disabled = _props.disabled,
            errorMessage = _props.errorMessage,
            hasError = _props.hasError,
            id = _props.id,
            idealErrorDirection = _props.idealErrorDirection,
            name = _props.name,
            placeholder = _props.placeholder,
            type = _props.type,
            value = _props.value;


        var classes = classnames(styles$s.textField, disabled ? styles$s.disabled : styles$s.enabled, hasError || errorMessage ? styles$s.errored : styles$s.normal);

        // type='number' doesn't work on ios safari without a pattern
        // https://stackoverflow.com/questions/14447668/input-type-number-is-not-showing-a-number-keypad-on-ios
        var pattern = type === 'number' ? '\\d*' : undefined;

        return React.createElement(
          'span',
          null,
          React.createElement('input', {
            'aria-describedby': errorMessage && this.state.focused ? id + '-gestalt-error' : null,
            'aria-invalid': errorMessage || hasError ? 'true' : 'false',
            autoComplete: autoComplete,
            className: classes,
            disabled: disabled,
            id: id,
            name: name,
            onBlur: this.handleBlur,
            onChange: this.handleChange,
            onFocus: this.handleFocus,
            onKeyDown: this.handleKeyDown,
            pattern: pattern,
            placeholder: placeholder,
            ref: function ref(c) {
              _this2.textfield = c;
            },
            type: type,
            value: value
          }),
          errorMessage && this.state.errorIsOpen && React.createElement(
            Flyout,
            {
              anchor: this.textfield,
              color: 'orange',
              idealDirection: idealErrorDirection,
              onDismiss: function onDismiss() {
                return _this2.setState({ errorIsOpen: false });
              },
              size: 'sm'
            },
            React.createElement(
              Box,
              { padding: 3 },
              React.createElement(
                Text,
                { bold: true, color: 'white' },
                React.createElement(
                  'span',
                  { id: id + '-gestalt-error' },
                  errorMessage
                )
              )
            )
          )
        );
      }
    }], [{
      key: 'getDerivedStateFromProps',
      value: function getDerivedStateFromProps(props, state) {
        if (props.errorMessage !== state.errorMessage) {
          return {
            errorIsOpen: !!props.errorMessage,
            errorMessage: props.errorMessage
          };
        }

        return null;
      }
    }]);
    return TextField;
  }(React.Component);

  TextField.propTypes = {
    autoComplete: PropTypes.oneOf(['current-password', 'on', 'off', 'username']),
    disabled: PropTypes.bool,
    errorMessage: PropTypes.string,
    hasError: PropTypes.bool,
    id: PropTypes.string.isRequired,
    idealErrorDirection: PropTypes.string,
    name: PropTypes.string,
    onBlur: PropTypes.func,
    onChange: PropTypes.func.isRequired,
    onFocus: PropTypes.func,
    onKeyDown: PropTypes.func,
    placeholder: PropTypes.string,
    type: PropTypes.oneOf(['date', 'email', 'number', 'password', 'text', 'url']),
    value: PropTypes.string
  };
  TextField.defaultProps = {
    disabled: false,
    hasError: false,
    idealErrorDirection: 'right',
    type: 'text'
  };

  function Toast(props) {
    var _props$color = props.color,
        color = _props$color === undefined ? 'darkGray' : _props$color,
        icon = props.icon,
        thumbnail = props.thumbnail,
        text = props.text;


    var contents = void 0;
    // Confirmation Toasts
    if (text instanceof Array && text.length > 1) {
      contents = React.createElement(
        Box,
        { xs: { display: 'flex' } },
        React.createElement(
          Box,
          { xs: { display: 'flexColumn' }, flex: 'none', justifyContent: 'center' },
          thumbnail ? React.createElement(
            Mask,
            { shape: 'rounded', height: 48, width: 48 },
            thumbnail
          ) : null
        ),
        React.createElement(
          Box,
          {
            xs: { display: 'flexColumn' },
            justifyContent: 'center',
            dangerouslySetInlineStyle: { __style: { paddingLeft: 10 } }
          },
          React.createElement(
            Box,
            {
              dangerouslySetInlineStyle: { __style: { fontWeight: 'normal' } }
            },
            React.createElement(
              Text,
              { color: 'white', size: 'lg' },
              text[0]
            )
          ),
          React.createElement(
            Text,
            { bold: true, color: 'white', size: 'lg' },
            text[1]
          )
        )
      );
    } else {
      // Toasts as Guides
      contents = React.createElement(
        Box,
        {
          xs: { display: 'flex' },
          justifyContent: 'between',
          alignItems: 'center'
        },
        React.createElement(
          Text,
          { bold: true, color: 'white', size: 'lg' },
          text
        ),
        icon && React.createElement(
          Box,
          { dangerouslySetInlineStyle: { __style: { paddingLeft: 24 } } },
          React.createElement(Icon, { accessibilityLabel: '', color: 'white', icon: icon, size: 36 })
        )
      );
    }

    return React.createElement(
      Box,
      { marginBottom: 3, paddingX: 4, maxWidth: 376, width: '100vw' },
      React.createElement(
        Box,
        { color: color, fit: true, paddingX: 8, paddingY: 5, shape: 'pill' },
        contents
      )
    );
  }

  Toast.propTypes = {
    color: PropTypes.oneOf(['darkGray', 'orange']),
    icon: PropTypes.oneOf(['arrow-circle-forward']), // leaving open to additional icons in the future
    text: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]).isRequired,
    thumbnail: PropTypes.node
  };

  function Tooltip(props) {
    var anchor = props.anchor,
        children = props.children,
        idealDirection = props.idealDirection,
        onDismiss = props.onDismiss,
        _props$positionRelati = props.positionRelativeToAnchor,
        positionRelativeToAnchor = _props$positionRelati === undefined ? true : _props$positionRelati,
        _props$size = props.size,
        size = _props$size === undefined ? 'md' : _props$size;


    if (!anchor) {
      return null;
    }

    return React.createElement(
      Controller,
      {
        anchor: anchor,
        bgColor: 'darkGray',
        idealDirection: idealDirection,
        positionRelativeToAnchor: positionRelativeToAnchor,
        onDismiss: onDismiss,
        size: size
      },
      React.createElement(
        Box,
        { column: 12, padding: 3 },
        children
      )
    );
  }

  Tooltip.propTypes = {
    anchor: PropTypes.shape({
      contains: PropTypes.func,
      getBoundingClientRect: PropTypes.func
    }),
    children: PropTypes.node,
    idealDirection: PropTypes.oneOf(['up', 'right', 'down', 'left']),
    onDismiss: PropTypes.func.isRequired,
    positionRelativeToAnchor: PropTypes.bool,
    size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl'])
  };

  var styles$t = { "touchable": "_x1 _xt", "fullHeight": "_x2", "fullWidth": "_x3 _y7", "square": "_x4 _2v", "circle": "_x5 _2w", "rounded": "_x6 _2y", "roundedTop": "_x7 _2z", "roundedRight": "_x8 _30", "roundedBottom": "_x9 _31", "roundedLeft": "_xa _32", "pill": "_xb _2x", "pointer": "_xc _z8", "zoomIn": "_xd _z9", "zoomOut": "_xe _za", "copy": "_xf _zb", "move": "_xg _zc", "noDrop": "_xh _zd", "grab": "_xi _ze", "grabbing": "_xj _zf" };

  var SPACE_CHAR_CODE = 32;
  var ENTER_CHAR_CODE = 13;

  var Touchable = function (_React$Component) {
    inherits(Touchable, _React$Component);

    function Touchable() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Touchable);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Touchable.__proto__ || Object.getPrototypeOf(Touchable)).call.apply(_ref, [this].concat(args))), _this), _this.handleKeyPress = function (event) {
        var onTouch = _this.props.onTouch;
        // Check to see if space or enter were pressed

        if (onTouch && (event.charCode === SPACE_CHAR_CODE || event.charCode === ENTER_CHAR_CODE)) {
          // Prevent the default action to stop scrolling when space is pressed
          event.preventDefault();
          onTouch({ event: event });
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Touchable, [{
      key: 'render',
      value: function render() {
        var _classnames;

        var _props = this.props,
            children = _props.children,
            _props$fullWidth = _props.fullWidth,
            fullWidth = _props$fullWidth === undefined ? true : _props$fullWidth,
            fullHeight = _props.fullHeight,
            _props$mouseCursor = _props.mouseCursor,
            mouseCursor = _props$mouseCursor === undefined ? 'pointer' : _props$mouseCursor,
            onMouseEnter = _props.onMouseEnter,
            onMouseLeave = _props.onMouseLeave,
            onTouch = _props.onTouch,
            _props$shape = _props.shape,
            shape = _props$shape === undefined ? 'square' : _props$shape;


        var classes = classnames(styles$t.touchable, styles$t[mouseCursor], styles$t[shape], (_classnames = {}, defineProperty(_classnames, styles$t.fullHeight, fullHeight), defineProperty(_classnames, styles$t.fullWidth, fullWidth), _classnames));

        return React.createElement(
          'div',
          {
            className: classes,
            onClick: function onClick(event) {
              return onTouch && onTouch({ event: event });
            },
            onMouseEnter: function (_onMouseEnter) {
              function onMouseEnter(_x) {
                return _onMouseEnter.apply(this, arguments);
              }

              onMouseEnter.toString = function () {
                return _onMouseEnter.toString();
              };

              return onMouseEnter;
            }(function (event) {
              return onMouseEnter && onMouseEnter({ event: event });
            }),
            onMouseLeave: function (_onMouseLeave) {
              function onMouseLeave(_x2) {
                return _onMouseLeave.apply(this, arguments);
              }

              onMouseLeave.toString = function () {
                return _onMouseLeave.toString();
              };

              return onMouseLeave;
            }(function (event) {
              return onMouseLeave && onMouseLeave({ event: event });
            }),
            onKeyPress: this.handleKeyPress,
            role: 'button',
            tabIndex: '0'
          },
          children
        );
      }
    }]);
    return Touchable;
  }(React.Component);


  Touchable.propTypes = {
    children: PropTypes.node,
    fullHeight: PropTypes.bool,
    fullWidth: PropTypes.bool,
    mouseCursor: PropTypes.oneOf(['copy', 'grab', 'grabbing', 'move', 'noDrop', 'pointer', 'zoomIn', 'zoomOut']),
    onTouch: PropTypes.func,
    onMouseEnter: PropTypes.func,
    onMouseLeave: PropTypes.func,
    shape: PropTypes.oneOf(['square', 'rounded', 'pill', 'circle', 'roundedTop', 'roundedBottom', 'roundedLeft', 'roundedRight'])
  };

  var styles$u = { "video": "_xk _45 _4h _y7", "player": "_xl _4f _y7", "playhead": "_xm _4s _50 _y7 _z8", "controls": "_xn _4h _4s _50 _4l _4m _4k _6e _6d" };

  var VideoPlayhead = function (_React$PureComponent) {
    inherits(VideoPlayhead, _React$PureComponent);

    function VideoPlayhead() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, VideoPlayhead);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = VideoPlayhead.__proto__ || Object.getPrototypeOf(VideoPlayhead)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        seeking: false
      }, _this.setPlayheadRef = function (ref) {
        _this.playhead = ref;
      }, _this.seek = function (clientX) {
        if (_this.playhead) {
          var _this$props = _this.props,
              _duration = _this$props.duration,
              _seek = _this$props.seek;

          var _this$playhead$getBou = _this.playhead.getBoundingClientRect(),
              left = _this$playhead$getBou.left,
              width = _this$playhead$getBou.width;

          var percent = Math.max(0, Math.min((clientX - left) / width, 1));
          var newTime = percent * _duration;
          _seek(newTime);
        }
      }, _this.stopClick = function (event) {
        return event.stopPropagation();
      }, _this.handleMouseDown = function (event) {
        _this.setState({ seeking: true });
        _this.seek(event.clientX);
      }, _this.handleMouseMove = function (event) {
        var seeking = _this.state.seeking;

        if (seeking) {
          _this.seek(event.clientX);
        }
      }, _this.handleMouseUp = function () {
        _this.setState({ seeking: false });
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(VideoPlayhead, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            currentTime = _props.currentTime,
            duration = _props.duration;

        var width = Math.floor(currentTime * 10000 / duration) / 100 + '%';
        return React.createElement(
          Box,
          {
            position: 'relative',
            display: 'flex',
            flex: 'grow',
            alignItems: 'center',
            height: 16
          },
          React.createElement(
            'div',
            {
              'aria-valuemax': duration,
              'aria-valuemin': '0',
              'aria-valuenow': currentTime,
              className: styles$u.playhead,
              onClick: this.stopClick,
              onKeyPress: this.stopClick,
              onMouseDown: this.handleMouseDown,
              onMouseMove: this.handleMouseMove,
              onMouseUp: this.handleMouseUp,
              ref: this.setPlayheadRef,
              role: 'progressbar',
              tabIndex: '-1'
            },
            React.createElement(
              Box,
              {
                left: true,
                right: true,
                position: 'absolute',
                color: 'lightGray',
                shape: 'rounded',
                height: 4
              },
              React.createElement(Box, { color: 'white', shape: 'rounded', height: '100%', width: width })
            ),
            React.createElement(
              Box,
              {
                position: 'absolute',
                shape: 'rounded',
                height: 4,
                dangerouslySetInlineStyle: { __style: { left: width } }
              },
              React.createElement(Box, {
                shape: 'circle',
                width: 16,
                height: 16,
                color: 'white',
                marginLeft: -2,
                dangerouslySetInlineStyle: { __style: { marginTop: -6 } }
              })
            )
          )
        );
      }
    }]);
    return VideoPlayhead;
  }(React.PureComponent);

  VideoPlayhead.propTypes = {
    currentTime: PropTypes.number.isRequired,
    duration: PropTypes.number.isRequired,
    seek: PropTypes.func.isRequired
  };

  var fullscreenEnabled = function fullscreenEnabled() {
    return (
      // $FlowIssue - vendor prefix missing from Flow
      document.fullscreenEnabled ||
      // $FlowIssue - vendor prefix missing from Flow
      document.webkitFullscreenEnabled ||
      // $FlowIssue - vendor prefix missing from Flow
      document.mozFullScreenEnabled ||
      // $FlowIssue - vendor prefix missing from Flow
      document.msFullscreenEnabled
    );
  };

  var timeToString = function timeToString(time) {
    var rounded = Math.floor(time || 0);
    var minutes = Math.floor(rounded / 60);
    var seconds = rounded - minutes * 60;
    var minutesStr = minutes < 10 ? '0' + minutes : minutes;
    var secondsStr = seconds < 10 ? '0' + seconds : seconds;
    return minutesStr + ':' + secondsStr;
  };

  var VideoControls = function (_React$Component) {
    inherits(VideoControls, _React$Component);

    function VideoControls() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, VideoControls);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = VideoControls.__proto__ || Object.getPrototypeOf(VideoControls)).call.apply(_ref, [this].concat(args))), _this), _this.handleFullscreenChange = function (_ref2) {
        var event = _ref2.event;
        var onFullscreenChange = _this.props.onFullscreenChange;

        event.stopPropagation();
        onFullscreenChange();
      }, _this.handlePlayingChange = function (_ref3) {
        var event = _ref3.event;
        var _this$props = _this.props,
            playing = _this$props.playing,
            onPause = _this$props.onPause,
            onPlay = _this$props.onPlay;

        if (playing) {
          onPause(event);
        } else {
          onPlay(event);
        }
      }, _this.handleVolumeChange = function (_ref4) {
        var event = _ref4.event;
        var onVolumeChange = _this.props.onVolumeChange;

        onVolumeChange(event);
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(VideoControls, [{
      key: 'render',
      value: function render() {
        var _props = this.props,
            accessibilityMaximizeLabel = _props.accessibilityMaximizeLabel,
            accessibilityMinimizeLabel = _props.accessibilityMinimizeLabel,
            accessibilityMuteLabel = _props.accessibilityMuteLabel,
            accessibilityPauseLabel = _props.accessibilityPauseLabel,
            accessibilityPlayLabel = _props.accessibilityPlayLabel,
            accessibilityUnmuteLabel = _props.accessibilityUnmuteLabel,
            currentTime = _props.currentTime,
            duration = _props.duration,
            fullscreen = _props.fullscreen,
            playing = _props.playing,
            seek = _props.seek,
            volume = _props.volume;

        var muted = volume === 0;
        var showFullscreenButton = typeof document !== 'undefined' && !!fullscreenEnabled();
        return React.createElement(
          'div',
          { className: styles$u.controls },
          React.createElement(
            Box,
            { padding: 2 },
            React.createElement(
              Touchable,
              { onTouch: this.handlePlayingChange, fullWidth: false },
              React.createElement(Icon, {
                accessibilityLabel: playing ? accessibilityPauseLabel : accessibilityPlayLabel,
                color: 'white',
                icon: playing ? 'pause' : 'play',
                size: 20
              })
            )
          ),
          React.createElement(
            Box,
            { width: 50, padding: 2 },
            React.createElement(
              Text,
              { color: 'white', align: 'right', size: 'xs' },
              timeToString(currentTime)
            )
          ),
          React.createElement(
            Box,
            { padding: 2, flex: 'grow' },
            React.createElement(VideoPlayhead, {
              currentTime: currentTime,
              duration: duration,
              seek: seek
            })
          ),
          React.createElement(
            Box,
            { width: 50, padding: 2 },
            React.createElement(
              Text,
              { color: 'white', align: 'right', size: 'xs' },
              timeToString(duration)
            )
          ),
          React.createElement(
            Box,
            { padding: 2 },
            React.createElement(
              Touchable,
              { onTouch: this.handleVolumeChange, fullWidth: false },
              React.createElement(Icon, {
                accessibilityLabel: muted ? accessibilityUnmuteLabel : accessibilityMuteLabel,
                color: 'white',
                icon: muted ? 'mute' : 'sound',
                size: 20
              })
            )
          ),
          showFullscreenButton && React.createElement(
            Box,
            { padding: 2 },
            React.createElement(
              Touchable,
              { onTouch: this.handleFullscreenChange, fullWidth: false },
              React.createElement(Icon, {
                accessibilityLabel: fullscreen ? accessibilityMinimizeLabel : accessibilityMaximizeLabel,
                color: 'white',
                icon: fullscreen ? 'minimize' : 'maximize',
                size: 20
              })
            )
          )
        );
      }
    }]);
    return VideoControls;
  }(React.Component);

  VideoControls.propTypes = {
    accessibilityMaximizeLabel: PropTypes.string.isRequired,
    accessibilityMinimizeLabel: PropTypes.string.isRequired,
    accessibilityMuteLabel: PropTypes.string.isRequired,
    accessibilityPauseLabel: PropTypes.string.isRequired,
    accessibilityPlayLabel: PropTypes.string.isRequired,
    accessibilityUnmuteLabel: PropTypes.string.isRequired,
    currentTime: PropTypes.number.isRequired,
    duration: PropTypes.number.isRequired,
    fullscreen: PropTypes.bool.isRequired,
    onFullscreenChange: PropTypes.func.isRequired,
    onPause: PropTypes.func.isRequired,
    onPlay: PropTypes.func.isRequired,
    onVolumeChange: PropTypes.func.isRequired,
    playing: PropTypes.bool.isRequired,
    seek: PropTypes.func.isRequired,
    volume: PropTypes.number.isRequired
  };

  // For more information on fullscreen and vendor prefixes see
  // https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API

  var requestFullscreen = function requestFullscreen(element) {
    if (element.requestFullscreen) {
      element.requestFullscreen();
      // $FlowIssue - vendor prefix missing from Flow
    } else if (element.webkitRequestFullscreen) {
      // $FlowIssue - vendor prefix missing from Flow
      element.webkitRequestFullscreen();
      // $FlowIssue - vendor prefix missing from Flow
    } else if (element.mozRequestFullScreen) {
      // $FlowIssue - vendor prefix missing from Flow
      element.mozRequestFullScreen();
      // $FlowIssue - vendor prefix missing from Flow
    } else if (element.msRequestFullscreen) {
      // $FlowIssue - vendor prefix missing from Flow
      element.msRequestFullscreen();
    }
  };

  var exitFullscreen = function exitFullscreen() {
    // $FlowIssue - vendor prefix missing from Flow
    if (document.exitFullscreen) {
      // $FlowIssue - vendor prefix missing from Flow
      document.exitFullscreen();
      // $FlowIssue - vendor prefix missing from Flow
    } else if (document.webkitExitFullscreen) {
      // $FlowIssue - vendor prefix missing from Flow
      document.webkitExitFullscreen();
      // $FlowIssue - vendor prefix missing from Flow
    } else if (document.mozCancelFullScreen) {
      // $FlowIssue - vendor prefix missing from Flow
      document.mozCancelFullScreen();
      // $FlowIssue - vendor prefix missing from Flow
    } else if (document.msExitFullscreen) {
      // $FlowIssue - vendor prefix missing from Flow
      document.msExitFullscreen();
    }
  };

  // Normally document.fullscreen suffices here as a flag, but IE11 does not
  // have a vendor specific version so we must instead use the actual element
  var isFullscreen = function isFullscreen() {
    return (
      // $FlowIssue - vendor prefix missing from Flow
      document.fullscreenElement ||
      // $FlowIssue - vendor prefix missing from Flow
      document.webkitFullscreenElement ||
      // $FlowIssue - vendor prefix missing from Flow
      document.mozFullScreenElement ||
      // $FlowIssue - vendor prefix missing from Flow
      document.msFullscreenElement
    );
  };

  var addFullscreenEventListener = function addFullscreenEventListener(listener) {
    document.addEventListener('fullscreenchange', listener);
    document.addEventListener('webkitfullscreenchange', listener);
    document.addEventListener('mozfullscreenchange', listener);
    document.addEventListener('MSFullscreenChange', listener);
  };

  var removeFullscreenEventListener = function removeFullscreenEventListener(listener) {
    document.removeEventListener('fullscreenchange', listener);
    document.removeEventListener('webkitfullscreenchange', listener);
    document.removeEventListener('mozfullscreenchange', listener);
    document.removeEventListener('MSFullscreenChange', listener);
  };

  var isNewSource = function isNewSource(oldSource, newSource) {
    if ((typeof oldSource === 'undefined' ? 'undefined' : _typeof(oldSource)) !== (typeof newSource === 'undefined' ? 'undefined' : _typeof(newSource))) {
      // If the source type changed from string to Array
      // or vice versa, we have a new source
      return true;
    }
    if (Array.isArray(newSource)) {
      if (oldSource.length !== newSource.length) {
        // If the sources are both an Array, and the lengths
        // do not match we evaluate as a new source
        return true;
      }
      // If the sources are both an Array and the same length,
      // verify every element stayed the same
      return newSource.some(function (source, index) {
        return !Array.isArray(oldSource) || source.type !== oldSource[index].type || source.src !== oldSource[index].src;
      });
    }
    // If the sources are both a string, simply compare
    // the new with the old
    return newSource !== oldSource;
  };

  var Video = function (_React$PureComponent) {
    inherits(Video, _React$PureComponent);

    function Video() {
      var _ref;

      var _temp, _this, _ret;

      classCallCheck(this, Video);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Video.__proto__ || Object.getPrototypeOf(Video)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
        currentTime: 0,
        duration: 0,
        fullscreen: false
      }, _this.setPlayerRef = function (ref) {
        _this.player = ref;
      }, _this.setVideoRef = function (ref) {
        _this.video = ref;
      }, _this.setPlaybackRate = function (playbackRate) {
        if (_this.video) {
          _this.video.playbackRate = playbackRate;
        }
      }, _this.setVolume = function (volume) {
        if (_this.video) {
          _this.video.volume = volume;
        }
      }, _this.load = function () {
        if (_this.video) {
          _this.video.load();
        }
      }, _this.pause = function () {
        if (_this.video) {
          _this.video.pause();
        }
      }, _this.play = function () {
        if (_this.video) {
          _this.video.play();
        }
      }, _this.seek = function (time) {
        if (_this.video) {
          _this.video.currentTime = time;
        }
      }, _this.toggleFullscreen = function () {
        if (isFullscreen()) {
          exitFullscreen();
        } else if (_this.player) {
          requestFullscreen(_this.player);
        }
      }, _this.handleCanPlay = function (event) {
        var onReady = _this.props.onReady;


        if (onReady) {
          onReady({ event: event });
        }
      }, _this.handleDurationChange = function (event) {
        var onDurationChange = _this.props.onDurationChange;

        var duration = _this.video && _this.video.duration || 0;
        _this.setState({ duration: duration });

        if (onDurationChange) {
          onDurationChange({ event: event, duration: duration });
        }
      }, _this.handleEnded = function (event) {
        var onEnded = _this.props.onEnded;


        if (onEnded) {
          onEnded({ event: event });
        }
      }, _this.handleFullscreenChange = function (event) {
        var onFullscreenChange = _this.props.onFullscreenChange;

        var fullscreen = !!isFullscreen();
        _this.setState({ fullscreen: fullscreen });

        if (onFullscreenChange) {
          onFullscreenChange({ event: event, fullscreen: fullscreen });
        }
      }, _this.handlePlay = function (event) {
        var onPlay = _this.props.onPlay;


        if (onPlay) {
          onPlay({ event: event });
        }
      }, _this.handlePause = function (event) {
        var onPause = _this.props.onPause;


        if (onPause) {
          onPause({ event: event });
        }
      }, _this.handleProgress = function (event) {
        var onLoadedChange = _this.props.onLoadedChange;

        var _ref2 = _this.video || {},
            buffered = _ref2.buffered;

        var loaded = buffered && buffered.length > 0 ? buffered.end(buffered.length - 1) : 0;

        if (onLoadedChange) {
          onLoadedChange({ event: event, loaded: loaded });
        }
      }, _this.handleSeek = function (event) {
        var onSeek = _this.props.onSeek;


        if (onSeek) {
          onSeek({ event: event });
        }
      }, _this.handleTimeUpdate = function (event) {
        var onTimeChange = _this.props.onTimeChange;

        var currentTime = _this.video && _this.video.currentTime || 0;
        _this.setState({ currentTime: currentTime });

        if (onTimeChange) {
          onTimeChange({ event: event, time: currentTime });
        }
      }, _this.handleVolumeChange = function (event) {
        var onVolumeChange = _this.props.onVolumeChange;

        var muted = _this.video && _this.video.muted || false;

        if (onVolumeChange) {
          onVolumeChange({ event: event, volume: muted ? 1 : 0 });
        }
      }, _temp), possibleConstructorReturn(_this, _ret);
    }

    createClass(Video, [{
      key: 'componentDidMount',


      /**
       * React lifecycle hooks pertinent to Video
       */

      value: function componentDidMount() {
        var _props = this.props,
            playbackRate = _props.playbackRate,
            playing = _props.playing,
            volume = _props.volume;
        // Set up event listeners to catch backdoors in fullscreen
        // changes such as using the ESC key to exit

        if (typeof document !== 'undefined') {
          addFullscreenEventListener(this.handleFullscreenChange);
        }
        // Load the video to hydrate the DOM after a server render
        this.load();
        // Set the initial volume
        this.setVolume(volume);
        // Set the initial playback rate
        this.setPlaybackRate(playbackRate);
        // Simulate an autoplay effect if the component
        if (playing) {
          this.play();
        }
      }
    }, {
      key: 'componentDidUpdate',
      value: function componentDidUpdate(prevProps) {
        // If the video source changed, reload the video
        if (isNewSource(prevProps.src, this.props.src)) {
          this.load();
        }
        // If the volume changed, set the new volume
        if (prevProps.volume !== this.props.volume) {
          this.setVolume(this.props.volume);
        }
        // If the playback rate changed, set the new rate
        if (prevProps.playbackRate !== this.props.playbackRate) {
          this.setPlaybackRate(this.props.playbackRate);
        }
        // If the playback changed, play or pause the video
        if (prevProps.playing !== this.props.playing) {
          if (this.props.playing) {
            this.play();
          } else {
            this.pause();
          }
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        removeFullscreenEventListener(this.handleFullscreenChange);
      }

      /**
       * DOM reference housekeeping that is needed for functionality
       */

      // The player element encapsulates the actual video DOM
      // element as well as the controls to bring both fullscreen


      // The actual reference to the video HTML DOM element


      /**
       * Functions that directly interact with the HTML video element
       */

      // Set the video to the desired playback rate: 1 (normal)


      // Set the video to the desired volume: 0 (muted) -> 1 (max)


      // Change the video source and re-load the video


      // Pause the video


      // Play the video


      // Seek the video to the desired time


      // Enter/exit fullscreen video player mode


      /**
       * Handlers for various media events on the video
       */

      // Sent when enough data is available that the media can be played


      // The metadata has loaded or changed, indicating a change in
      // duration of the media


      // Sent when playback completes.


      // Sent when the video is switched to/out-of fullscreen mode


      // Sent when playback of the media starts after having been paused.


      // Sent when playback is paused.


      // Sent periodically to inform interested parties of progress downloading the media


      // Sent when a seek operation completes.


      // The time indicated by the element's currentTime attribute has changed


      // Sent when the audio volume changes

    }, {
      key: 'render',
      value: function render() {
        var _props2 = this.props,
            aspectRatio = _props2.aspectRatio,
            captions = _props2.captions,
            loop = _props2.loop,
            playing = _props2.playing,
            playsInline = _props2.playsInline,
            poster = _props2.poster,
            preload = _props2.preload,
            src = _props2.src,
            volume = _props2.volume;
        var _state = this.state,
            currentTime = _state.currentTime,
            duration = _state.duration,
            fullscreen = _state.fullscreen;


        var paddingBottom = fullscreen && '0' || 1 / aspectRatio * 100 + '%';

        return React.createElement(
          'div',
          {
            ref: this.setPlayerRef,
            className: styles$u.player,
            style: { paddingBottom: paddingBottom, height: fullscreen ? '100%' : 0 }
          },
          React.createElement(
            'video',
            {
              autoPlay: playing,
              loop: loop,
              muted: volume === 0,
              playsInline: playsInline,
              poster: poster,
              preload: preload,
              src: typeof src === 'string' ? src : undefined,
              ref: this.setVideoRef,
              className: styles$u.video,
              onCanPlay: this.handleCanPlay,
              onDurationChange: this.handleDurationChange,
              onEnded: this.handleEnded,
              onSeeked: this.handleSeek,
              onTimeUpdate: this.handleTimeUpdate,
              onProgress: this.handleProgress
            },
            Array.isArray(src) && src.map(function (source) {
              return React.createElement('source', { key: source.src, src: source.src, type: source.type });
            }),
            React.createElement('track', { kind: 'captions', src: captions })
          ),
          this.props.controls && React.createElement(VideoControls, {
            accessibilityMaximizeLabel: this.props.accessibilityMaximizeLabel,
            accessibilityMinimizeLabel: this.props.accessibilityMinimizeLabel,
            accessibilityMuteLabel: this.props.accessibilityMuteLabel,
            accessibilityPauseLabel: this.props.accessibilityPauseLabel,
            accessibilityPlayLabel: this.props.accessibilityPlayLabel,
            accessibilityUnmuteLabel: this.props.accessibilityUnmuteLabel,
            currentTime: currentTime,
            duration: duration,
            fullscreen: fullscreen,
            onPlay: this.handlePlay,
            onPause: this.handlePause,
            onFullscreenChange: this.toggleFullscreen,
            onVolumeChange: this.handleVolumeChange,
            playing: playing,
            seek: this.seek,
            volume: volume
          })
        );
      }
    }]);
    return Video;
  }(React.PureComponent);

  Video.propTypes = {
    accessibilityMaximizeLabel: PropTypes.string,
    accessibilityMinimizeLabel: PropTypes.string,
    accessibilityMuteLabel: PropTypes.string,
    accessibilityPauseLabel: PropTypes.string,
    accessibilityPlayLabel: PropTypes.string,
    accessibilityUnmuteLabel: PropTypes.string,
    aspectRatio: PropTypes.number.isRequired,
    captions: PropTypes.string.isRequired,
    controls: PropTypes.bool,
    loop: PropTypes.bool,
    onDurationChange: PropTypes.func,
    onEnded: PropTypes.func,
    onFullscreenChange: PropTypes.func,
    onLoadedChange: PropTypes.func,
    onPlay: PropTypes.func,
    onPause: PropTypes.func,
    onReady: PropTypes.func,
    onSeek: PropTypes.func,
    onTimeChange: PropTypes.func,
    onVolumeChange: PropTypes.func,
    playbackRate: PropTypes.number,
    playing: PropTypes.bool,
    playsInline: PropTypes.bool,
    poster: PropTypes.string,
    preload: PropTypes.oneOf(['auto', 'metadata', 'none']),
    src: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.shape({
      type: PropTypes.oneOf(['video/m3u8', 'video/mp4', 'video/ogg']).isRequired,
      src: PropTypes.string.isRequired
    }))]).isRequired,
    volume: PropTypes.number
  };
  Video.defaultProps = {
    playbackRate: 1,
    playing: false,
    preload: 'auto',
    volume: 1
  };

  exports.Avatar = Avatar;
  exports.Box = Box;
  exports.Button = Button;
  exports.Card = Card;
  exports.Checkbox = Checkbox;
  exports.Collage = Collage;
  exports.Collection = Collection;
  exports.Column = Column;
  exports.Container = Container;
  exports.Divider = Divider;
  exports.Flyout = Flyout;
  exports.GroupAvatar = GroupAvatar;
  exports.Heading = Heading;
  exports.Icon = Icon;
  exports.IconButton = IconButton;
  exports.Image = Image;
  exports.Label = Label;
  exports.Layer = Layer;
  exports.Letterbox = Letterbox;
  exports.Link = Link;
  exports.Mask = Mask;
  exports.Masonry = Masonry;
  exports.MasonryDefaultLayout = MasonryLayout;
  exports.MasonryUniformRowLayout = UniformRowLayout;
  exports.Modal = Modal;
  exports.Pog = Pog;
  exports.Pulsar = Pulsar;
  exports.RadioButton = RadioButton;
  exports.ScrollFetch = ScrollFetch;
  exports.SearchField = SearchField;
  exports.SegmentedControl = SegmentedControl;
  exports.SelectList = SelectList;
  exports.Spinner = Spinner;
  exports.Sticky = Sticky;
  exports.Switch = Switch;
  exports.Tabs = Tabs;
  exports.Text = Text;
  exports.TextArea = TextArea;
  exports.TextField = TextField;
  exports.Toast = Toast;
  exports.Tooltip = Tooltip;
  exports.Touchable = Touchable;
  exports.Video = Video;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VzdGFsdC5qcyIsInNvdXJjZXMiOlsiLi4vc3JjL3N0eWxlLmpzIiwiLi4vc3JjL3RyYW5zZm9ybXMuanMiLCIuLi9zcmMvQm94LmpzIiwiLi4vc3JjL2ljb25zL2luZGV4LmpzIiwiLi4vc3JjL0ljb24uanMiLCIuLi9zcmMvSW1hZ2UuanMiLCIuLi9zcmMvTWFzay5qcyIsIi4uL3NyYy9BdmF0YXIuanMiLCIuLi9zcmMvVGV4dC5qcyIsIi4uL3NyYy9CdXR0b24uanMiLCIuLi9zcmMvQ2FyZC5qcyIsIi4uL3NyYy9DaGVja2JveC5qcyIsIi4uL3NyYy9Db2xsZWN0aW9uLmpzIiwiLi4vc3JjL0NvbGxhZ2UuanMiLCIuLi9zcmMvQ29sdW1uLmpzIiwiLi4vc3JjL0NvbnRhaW5lci5qcyIsIi4uL3NyYy9EaXZpZGVyLmpzIiwiLi4vc3JjL0NhcmV0LmpzIiwiLi4vc3JjL0NvbnRlbnRzLmpzIiwiLi4vc3JjL2JlaGF2aW9ycy9PdXRzaWRlRXZlbnRCZWhhdmlvci5qcyIsIi4uL3NyYy9Db250cm9sbGVyLmpzIiwiLi4vc3JjL0ZseW91dC5qcyIsIi4uL3NyYy9Hcm91cEF2YXRhci5qcyIsIi4uL3NyYy9IZWFkaW5nLmpzIiwiLi4vc3JjL1BvZy5qcyIsIi4uL3NyYy9JY29uQnV0dG9uLmpzIiwiLi4vc3JjL0xhYmVsLmpzIiwiLi4vc3JjL0xheWVyLmpzIiwiLi4vc3JjL0xldHRlcmJveC5qcyIsIi4uL3NyYy9MaW5rLmpzIiwiLi4vc3JjL2RlYm91bmNlLmpzIiwiLi4vc3JjL0ZldGNoSXRlbXMuanMiLCIuLi9zcmMvU2Nyb2xsQ29udGFpbmVyLmpzIiwiLi4vc3JjL3Rocm90dGxlLmpzIiwiLi4vc3JjL01lYXN1cmVtZW50U3RvcmUuanMiLCIuLi9zcmMvc2Nyb2xsVXRpbHMuanMiLCIuLi9zcmMvbGVnYWN5TGF5b3V0U3ltYm9scy5qcyIsIi4uL3NyYy9kZWZhdWx0TGF5b3V0LmpzIiwiLi4vc3JjL3VuaWZvcm1Sb3dMYXlvdXQuanMiLCIuLi9zcmMvZnVsbFdpZHRoTGF5b3V0LmpzIiwiLi4vc3JjL2xheW91dHMvTWFzb25yeUxheW91dC5qcyIsIi4uL3NyYy9sYXlvdXRzL1VuaWZvcm1Sb3dMYXlvdXQuanMiLCIuLi9zcmMvTWFzb25yeS5qcyIsIi4uL3NyYy9iZWhhdmlvcnMvU3RvcFNjcm9sbEJlaGF2aW9yLmpzIiwiLi4vc3JjL2JlaGF2aW9ycy9UcmFwRm9jdXNCZWhhdmlvci5qcyIsIi4uL3NyYy9Nb2RhbC5qcyIsIi4uL3NyYy9QdWxzYXIuanMiLCIuLi9zcmMvUmFkaW9CdXR0b24uanMiLCIuLi9zcmMvU2Nyb2xsRmV0Y2guanMiLCIuLi9zcmMvU2VhcmNoRmllbGQuanMiLCIuLi9zcmMvU2VnbWVudGVkQ29udHJvbC5qcyIsIi4uL3NyYy9TZWxlY3RMaXN0LmpzIiwiLi4vc3JjL1NwaW5uZXIuanMiLCIuLi9zcmMvU3RpY2t5LmpzIiwiLi4vc3JjL1N3aXRjaC5qcyIsIi4uL3NyYy9UYWJzLmpzIiwiLi4vc3JjL1RleHRBcmVhLmpzIiwiLi4vc3JjL1RleHRGaWVsZC5qcyIsIi4uL3NyYy9Ub2FzdC5qcyIsIi4uL3NyYy9Ub29sdGlwLmpzIiwiLi4vc3JjL1RvdWNoYWJsZS5qcyIsIi4uL3NyYy9WaWRlb1BsYXloZWFkLmpzIiwiLi4vc3JjL1ZpZGVvQ29udHJvbHMuanMiLCIuLi9zcmMvVmlkZW8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogQGZsb3cgKi9cblxuLypcblxuU3R5bGUgaXMgYSBtb25vaWQgdGhhdCBjYXB0dXJlIHRoZSBcInRvLWJlLWFwcGxpZWRcIiBzdHlsZXMgKGlubGluZSBhbmQgY2xhc3NlcylcbmZvciBhIEJveC4gSXQncyBiYXNpY2FsbHkgc2V0IHRoYXQgaXMgY2xvc2VkIHVuZGVyIGFuIGFzc29jaWF0aXZlIGJpbmFyeVxub3BlcmF0aW9uIGFuZCBoYXMgYW4gaWRlbnRpdHkgZWxlbWVudCBzdWNoIHRoYXQgZm9yIGFsbCBIQSBIQSBIQS4gWWVzLCBpdCdzIGFcbm1vbm9pZCwgd2hpY2ggc291bmRzIHNjYXJ5IGJ1dCBpdCdzIG5vdCByZWFsbHkgYW5kIGFjdHVhbGx5IHN1cGVyIHVzZWZ1bC4gQWxsXG50aGF0IG1lYW5zIGlzIHRoYXQgYmFzaWNhbGx5IHlvdSBjYW4gZG8gdHdvIHRoaW5ncyB3aXRoIGl0OlxuXG4gICAgMS4gY29uY2F0KGNvbmNhdChhLCBiKSwgYykgPT09IGNvbmNhdChhLCBjb25jYXQoYiwgYykpO1xuICAgIDIuIGNvbmNhdChpZGVudGl0eSgpLCBhKSA9PT0gY29uY2F0KGEsIGlkZW50aXR5KCkpID09PSBhO1xuXG5XaGF0IHRoYXQgbWVhbnMgaXMgdGhhdCBpdCdzIHJlYWxseSBlYXN5IHRvIGNvbXBvc2Ugc3R5bGVzIHRvZ2V0aGVyIGFuZCB0aGVcbm9yZGVyIGluIHdoaWNoIHlvdSBkbyBzbyBkb2Vzbid0IHJlYWxseSBtYXR0ZXIuXG5cbiovXG5cbnR5cGUgSW5saW5lU3R5bGUgPSB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IHZvaWQgfTtcblxuLy8gVE9ETzogVGhpcyB0eXBlIHNob3VsZCBiZSBvcGFxdWUsIGhvd2V2ZXIgdGhlIEJhYmVsIHBhcnNlciBkb2Vzbid0IHN1cHBvcnRcbi8vICAgICAgIHRoZSBvcGFxdWUgc3ludGF4IHlldC5cbmV4cG9ydCB0eXBlIFN0eWxlID0ge3xcbiAgY2xhc3NOYW1lOiBTZXQ8c3RyaW5nPixcbiAgaW5saW5lU3R5bGU6IElubGluZVN0eWxlLFxufH07XG5cbmV4cG9ydCBjb25zdCBpZGVudGl0eSA9ICgpOiBTdHlsZSA9PiAoe1xuICBjbGFzc05hbWU6IG5ldyBTZXQoKSxcbiAgaW5saW5lU3R5bGU6IHt9LFxufSk7XG5cbmV4cG9ydCBjb25zdCBmcm9tQ2xhc3NOYW1lID0gKC4uLmNsYXNzTmFtZXM6IEFycmF5PHN0cmluZz4pOiBTdHlsZSA9PiAoe1xuICBjbGFzc05hbWU6IG5ldyBTZXQoY2xhc3NOYW1lcyksXG4gIGlubGluZVN0eWxlOiB7fSxcbn0pO1xuXG5leHBvcnQgY29uc3QgZnJvbUlubGluZVN0eWxlID0gKGlubGluZVN0eWxlOiBJbmxpbmVTdHlsZSk6IFN0eWxlID0+ICh7XG4gIGNsYXNzTmFtZTogbmV3IFNldCgpLFxuICBpbmxpbmVTdHlsZSxcbn0pO1xuXG5leHBvcnQgY29uc3QgY29uY2F0ID0gKHN0eWxlczogQXJyYXk8U3R5bGU+KTogU3R5bGUgPT5cbiAgc3R5bGVzLnJlZHVjZShcbiAgICAoXG4gICAgICB7IGNsYXNzTmFtZTogY2xhc3NOYW1lQSwgaW5saW5lU3R5bGU6IGlubGluZVN0eWxlQSB9LFxuICAgICAgeyBjbGFzc05hbWU6IGNsYXNzTmFtZUIsIGlubGluZVN0eWxlOiBpbmxpbmVTdHlsZUIgfVxuICAgICkgPT4gKHtcbiAgICAgIGNsYXNzTmFtZTogbmV3IFNldChbLi4uY2xhc3NOYW1lQSwgLi4uY2xhc3NOYW1lQl0pLFxuICAgICAgaW5saW5lU3R5bGU6IHsgLi4uaW5saW5lU3R5bGVBLCAuLi5pbmxpbmVTdHlsZUIgfSxcbiAgICB9KSxcbiAgICBpZGVudGl0eSgpXG4gICk7XG5cbmV4cG9ydCBjb25zdCBtYXBDbGFzc05hbWUgPSAoZm46ICh4OiBzdHJpbmcpID0+IHN0cmluZykgPT4gKHtcbiAgY2xhc3NOYW1lLFxuICBpbmxpbmVTdHlsZSxcbn06IFN0eWxlKTogU3R5bGUgPT4gKHtcbiAgY2xhc3NOYW1lOiBuZXcgU2V0KEFycmF5LmZyb20oY2xhc3NOYW1lKS5tYXAoZm4pKSxcbiAgaW5saW5lU3R5bGUsXG59KTtcblxuZXhwb3J0IGNvbnN0IHRvUHJvcHMgPSAoe1xuICBjbGFzc05hbWUsXG4gIGlubGluZVN0eWxlLFxufTogU3R5bGUpOiB7IGNsYXNzTmFtZTogc3RyaW5nLCBzdHlsZTogSW5saW5lU3R5bGUgfSA9PiB7XG4gIGNvbnN0IHByb3BzID0ge307XG5cbiAgaWYgKGNsYXNzTmFtZS5zaXplID4gMCkge1xuICAgIC8vIFNvcnRpbmcgaGVyZSBlbnN1cmVzIHRoYXQgY2xhc3NOYW1lcyBhcmUgYWx3YXlzIHN0YWJsZSwgcmVkdWNpbmcgZGlmZlxuICAgIC8vIGNodXJuLiBCb3ggdXN1YWxseSBoYXMgYSBzbWFsbCBudW1iZXIgb2YgcHJvcGVydGllcyBzbyBpdCdzIG5vdCBhIHBlcmZcbiAgICAvLyBjb25jZXJuLlxuICAgIHByb3BzLmNsYXNzTmFtZSA9IEFycmF5LmZyb20oY2xhc3NOYW1lKVxuICAgICAgLnNvcnQoKVxuICAgICAgLmpvaW4oJyAnKTtcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyhpbmxpbmVTdHlsZSkubGVuZ3RoID4gMCkge1xuICAgIHByb3BzLnN0eWxlID0gaW5saW5lU3R5bGU7XG4gIH1cblxuICByZXR1cm4gcHJvcHM7XG59O1xuIiwiLy8gQGZsb3dcblxuaW1wb3J0IHtcbiAgY29uY2F0LFxuICBmcm9tQ2xhc3NOYW1lLFxuICBpZGVudGl0eSxcbiAgbWFwQ2xhc3NOYW1lLFxuICB0eXBlIFN0eWxlLFxufSBmcm9tICcuL3N0eWxlLmpzJztcblxuLypcblxuVHJhbnNmb3Jtc1xuXG5UaGVzZSBhcmUgYSBjb2xsZWN0aW9uIG9mIGEgZmV3IGZ1bmN0b3JzIHRoYXQgdGFrZSB2YWx1ZXMgYW5kIHJldHVybnMgU3R5bGUncy4gT01HLCBJIHVzZWQgdGhlIHdvcmQgZnVuY3RvciAtIGl0J3MgcmVhbGx5IGp1c3QgYSBmYW5jeSB3b3JkIGZvciBmdW5jdGlvbi5cblxuKi9cblxudHlwZSBGdW5jdG9yID0gKG46IG51bWJlcikgPT4gU3R5bGU7XG5cbi8vIEFkZHMgYSBjbGFzc25hbWUgd2hlbiBhIHByb3BlcnR5IGlzIHByZXNlbnQuXG4vL1xuLy8gICAgIDxCb3ggdG9wIC8+XG4vL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZSA9ICguLi5jbGFzc05hbWVzOiBBcnJheTxzdHJpbmc+KSA9PiAodmFsPzogYm9vbGVhbikgPT5cbiAgdmFsID8gZnJvbUNsYXNzTmFtZSguLi5jbGFzc05hbWVzKSA6IGlkZW50aXR5KCk7XG5cbi8vIE1hcHMgc3RyaW5nIHZhbHVlcyB0byBjbGFzc2VzXG4vL1xuLy8gICAgIDxCb3ggYWxpZ25JdGVtcz1cImNlbnRlclwiIC8+XG4vL1xuZXhwb3J0IGNvbnN0IG1hcHBpbmcgPSAobWFwOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9KSA9PiAodmFsOiBzdHJpbmcpID0+XG4gIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIHZhbClcbiAgICA/IGZyb21DbGFzc05hbWUobWFwW3ZhbF0pXG4gICAgOiBpZGVudGl0eSgpO1xuXG4vLyBNYXBzIGEgcmFuZ2Ugb2YgaW50ZWdlcnMgdG8gYSByYW5nZSBvZiBjbGFzc25hbWVzXG4vL1xuLy8gICAgIDxCb3ggcGFkZGluZz17MX0gLz5cbi8vXG5leHBvcnQgY29uc3QgcmFuZ2UgPSAoc2NhbGU6IHN0cmluZykgPT4gKG46IG51bWJlcikgPT5cbiAgZnJvbUNsYXNzTmFtZShgJHtzY2FsZX0ke24gPCAwID8gYE4ke01hdGguYWJzKG4pfWAgOiBufWApO1xuXG4vLyBMaWtlIGByYW5nZWAsIG1hcHMgYSByYW5nZSBvZiBpbnRlZ2VycyB0byBhIHJhbmdlIG9mIGNsYXNzbmFtZXMsIGV4Y2x1ZGluZ1xuLy8gemVybyB2YWx1ZXMuXG4vL1xuLy8gICAgIDxCb3ggcGFkZGluZz17MH0gLz5cbmV4cG9ydCBjb25zdCByYW5nZVdpdGhvdXRaZXJvID0gKHNjYWxlOiBzdHJpbmcpID0+IChuOiBudW1iZXIpID0+XG4gIG4gPT09IDAgPyBpZGVudGl0eSgpIDogcmFuZ2Uoc2NhbGUpKG4pO1xuXG4vLyBCaW5kcyBhIHN0cmluZyBjbGFzc25hbWUgdG8gdGhlIHZhbHVlIGluIGFuIG9iamVjdC4gVXNlZnVsIHdoZW4gaW50ZXJhY3Rpbmdcbi8vIHdpdGggcmFuZ2VzIHRoYXQgbmVlZCB0byBjb21lIGR5bmFtaWNhbGx5IGZyb20gYSBzdHlsZSBvYmplY3QuIFRoaXMgaXNcbi8vIHNpbWlsYXIgdG8gdGhlIE5QTSBwYWNrYWdlICdjbGFzc25hbWVzL2JpbmQnLlxuZXhwb3J0IGNvbnN0IGJpbmQgPSAoZm46IEZ1bmN0b3IsIHNjb3BlOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9KSA9PiAoXG4gIHZhbDogbnVtYmVyXG4pID0+IG1hcENsYXNzTmFtZShuYW1lID0+IHNjb3BlW25hbWVdKShmbih2YWwpKTtcblxuLy8gVGhpcyB0YWtlcyBhIHNlcmllcyBvZiB0aGUgcHJldmlvdXNseSBkZWZpbmVkIGZ1bmN0b3JzLCBydW5zIHRoZW0gYWxsXG4vLyBhZ2FpbnN0IGEgdmFsdWUgYW5kIHJldHVybnMgdGhlIHNldCBvZiB0aGVpciBjbGFzc25hbWVzLlxuZXhwb3J0IGNvbnN0IHVuaW9uID0gKC4uLmZuczogQXJyYXk8RnVuY3Rvcj4pID0+ICh2YWw6IG51bWJlcikgPT5cbiAgY29uY2F0KGZucy5tYXAoZm4gPT4gZm4odmFsKSkpO1xuIiwiLy8gQGZsb3dcblxuLypcblxuIyBXZWxjb21lIHRvIEJveCFcblxuVGhpcyBndWlkZSB3aWxsIGhlbHAgeW91IG5hdmlnYXRlIGFuZCB1bmRlcnN0YW5kIGl0cyBkZXNpZ24uIFRoaXMgZmlsZSBpcyByb3VnaGx5IG9yZ2FuaXplZCBsaWtlOlxuXG4gIDEuIEZsb3cgVHlwZXNcbiAgMi4gUHJvcCB0cmFuc2Zvcm1lcnNcbiAgMy4gQm94IGl0c2VsZlxuICA0LiBQcm9wVHlwZXNcblxuSSdsbCBleHBsYWluIGVhY2ggcGFydCBhcyB3ZSBnbyB0aHJvdWdoLiBKdXN0IHJlbWVtYmVyLCBpZiB5b3Ugd2FudCB0byBtYWtlIHVwZGF0ZXMsIFBMRUFTRSBQTEVBU0UgUExFQVNFIHVwZGF0ZSB0aGUgRmxvdyBUeXBlcyAmIFByb3BUeXBlcyAoZXZlbiB0aG91Z2ggdGhleSBsb29rIHNjYXJ5KS5cblxuKi9cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9Cb3guY3NzJztcbmltcG9ydCBib3JkZXJzIGZyb20gJy4vQm9yZGVycy5jc3MnO1xuaW1wb3J0IGNvbG9ycyBmcm9tICcuL0NvbG9ycy5jc3MnO1xuaW1wb3J0IGxheW91dCBmcm9tICcuL0xheW91dC5jc3MnO1xuaW1wb3J0IHdoaXRlc3BhY2UgZnJvbSAnLi9ib3hXaGl0ZXNwYWNlLmNzcyc7XG5pbXBvcnQgd2hpdGVzcGFjZUxlZ2FjeSBmcm9tICcuL1doaXRlc3BhY2UuY3NzJztcbmltcG9ydCB7XG4gIGNvbmNhdCxcbiAgZnJvbUNsYXNzTmFtZSxcbiAgZnJvbUlubGluZVN0eWxlLFxuICBpZGVudGl0eSxcbiAgbWFwQ2xhc3NOYW1lLFxuICB0b1Byb3BzLFxufSBmcm9tICcuL3N0eWxlLmpzJztcbmltcG9ydCB7XG4gIHVuaW9uLFxuICBiaW5kLFxuICByYW5nZSxcbiAgdG9nZ2xlLFxuICBtYXBwaW5nLFxuICByYW5nZVdpdGhvdXRaZXJvLFxufSBmcm9tICcuL3RyYW5zZm9ybXMuanMnO1xuXG4vKlxuXG4jIFByb1R5cGVzXG5cbkJveCdzIHR5cGUgZGVmaW5pdGlvbiBpcyBleGhhdXN0aXZlLiBXaXRoIHRoZSBleGNlcHRpb24gb2YgYGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGVgLCB2YWx1ZXMgc2hvdWxkbid0IGJlIGFtYmlnaW91cy4gVGhhdCBtZWFucyB0aGF0IHdlIGhhdmUgdG8gdHlwZSBvdXQgdGhpbmdzIGxpa2UgYm9pbnRzLCBidXQgdGhhdCdzIGFsc28gd2hlcmUgQm94J3MgbWFnaWMgbGllcy4gQWxzbywgYnkgcHV0dGluZyBpbiBleHRyYSBlZmZvcnQgYXJvdW5kIHR5cGUgZGVmaW5pdGlvbnMgaGVyZSwgd2UgY2FuIHNraXAgZXh0cmEgcnVudGltZSB0eXBlY2hlY2tzIGluIHRoZSB0cmFuc2Zvcm1lcnMgZm9yIHBlcmZvcm1hbmNlLlxuXG4qL1xuXG50eXBlIE5hdEJvaW50ID0gMSB8IDIgfCAzIHwgNCB8IDUgfCA2O1xudHlwZSBJbnRCb2ludCA9IC02IHwgLTUgfCAtNCB8IC0zIHwgLTIgfCAtMSB8IE5hdEJvaW50O1xudHlwZSBEaXNwbGF5ID0gJ25vbmUnIHwgJ2ZsZXgnIHwgJ2Jsb2NrJyB8ICdpbmxpbmVCbG9jaycgfCAndmlzdWFsbHlIaWRkZW4nO1xudHlwZSBEaXJlY3Rpb24gPSAncm93JyB8ICdjb2x1bW4nO1xudHlwZSBDb2x1bW4gPSAwIHwgMSB8IDIgfCAzIHwgNCB8IDUgfCA2IHwgNyB8IDggfCA5IHwgMTAgfCAxMSB8IDEyO1xudHlwZSBSZXNwb25zaXZlUHJvcHMgPSB7XG4gIGNvbHVtbj86IDEgfCAyIHwgMyB8IDQgfCA1IHwgNiB8IDcgfCA4IHwgOSB8IDEwIHwgMTEgfCAxMixcbiAgZGlzcGxheT86IGJvb2xlYW4gfCAnZmxleCcgfCAnZmxleENvbHVtbicgfCAnaW5saW5lQmxvY2snLFxufTtcbnR5cGUgTWFyZ2luID1cbiAgfCAtMTJcbiAgfCAtMTFcbiAgfCAtMTBcbiAgfCAtOVxuICB8IC04XG4gIHwgLTdcbiAgfCAtNlxuICB8IC01XG4gIHwgLTRcbiAgfCAtM1xuICB8IC0yXG4gIHwgLTFcbiAgfCAwXG4gIHwgMVxuICB8IDJcbiAgfCAzXG4gIHwgNFxuICB8IDVcbiAgfCA2XG4gIHwgN1xuICB8IDhcbiAgfCA5XG4gIHwgMTBcbiAgfCAxMVxuICB8IDEyO1xudHlwZSBQYWRkaW5nID0gMCB8IDEgfCAyIHwgMyB8IDQgfCA1IHwgNiB8IDcgfCA4IHwgOSB8IDEwIHwgMTEgfCAxMjtcbnR5cGUgUHJvcFR5cGUgPSB7XG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT86IHtcbiAgICBfX3N0eWxlOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IHZvaWQgfSxcbiAgfSxcblxuICB4cz86IFJlc3BvbnNpdmVQcm9wcyxcbiAgc20/OiBSZXNwb25zaXZlUHJvcHMsXG4gIG1kPzogUmVzcG9uc2l2ZVByb3BzLFxuICBsZz86IFJlc3BvbnNpdmVQcm9wcyxcbiAgZGVwcmVjYXRlZFBhZGRpbmc/OiBOYXRCb2ludCB8IHsgeD86IE5hdEJvaW50LCB5PzogTmF0Qm9pbnQgfSxcbiAgZGVwcmVjYXRlZE1hcmdpbj86XG4gICAgfCBJbnRCb2ludFxuICAgIHwge1xuICAgICAgICB0b3A/OiBJbnRCb2ludCxcbiAgICAgICAgcmlnaHQ/OiBJbnRCb2ludCB8ICdhdXRvJyxcbiAgICAgICAgYm90dG9tPzogSW50Qm9pbnQsXG4gICAgICAgIGxlZnQ/OiBJbnRCb2ludCB8ICdhdXRvJyxcbiAgICAgIH0sXG5cbiAgZGlzcGxheT86IERpc3BsYXksXG4gIGNvbHVtbj86IENvbHVtbixcbiAgZGlyZWN0aW9uPzogRGlyZWN0aW9uLFxuICBzbURpc3BsYXk/OiBEaXNwbGF5LFxuICBzbUNvbHVtbj86IENvbHVtbixcbiAgc21EaXJlY3Rpb24/OiBEaXJlY3Rpb24sXG4gIG1kRGlzcGxheT86IERpc3BsYXksXG4gIG1kQ29sdW1uPzogQ29sdW1uLFxuICBtZERpcmVjdGlvbj86IERpcmVjdGlvbixcbiAgbGdEaXNwbGF5PzogRGlzcGxheSxcbiAgbGdDb2x1bW4/OiBDb2x1bW4sXG4gIGxnRGlyZWN0aW9uPzogRGlyZWN0aW9uLFxuXG4gIGFsaWduQ29udGVudD86ICdzdGFydCcgfCAnZW5kJyB8ICdjZW50ZXInIHwgJ2JldHdlZW4nIHwgJ2Fyb3VuZCcgfCAnc3RyZXRjaCcsXG4gIGFsaWduSXRlbXM/OiAnc3RhcnQnIHwgJ2VuZCcgfCAnY2VudGVyJyB8ICdiYXNlbGluZScgfCAnc3RyZXRjaCcsXG4gIGFsaWduU2VsZj86ICdhdXRvJyB8ICdzdGFydCcgfCAnZW5kJyB8ICdjZW50ZXInIHwgJ2Jhc2VsaW5lJyB8ICdzdHJldGNoJyxcbiAgYm90dG9tPzogYm9vbGVhbixcbiAgY29sb3I/OlxuICAgIHwgJ2JsdWUnXG4gICAgfCAnZGFya0dyYXknXG4gICAgfCAnZGFya1dhc2gnXG4gICAgfCAnZWdncGxhbnQnXG4gICAgfCAnZ3JheSdcbiAgICB8ICdncmVlbidcbiAgICB8ICdsaWdodEdyYXknXG4gICAgfCAnbGlnaHRXYXNoJ1xuICAgIHwgJ21hcm9vbidcbiAgICB8ICdtaWRuaWdodCdcbiAgICB8ICduYXZ5J1xuICAgIHwgJ29saXZlJ1xuICAgIHwgJ29yYW5nZSdcbiAgICB8ICdvcmNoaWQnXG4gICAgfCAncGluZSdcbiAgICB8ICdwdXJwbGUnXG4gICAgfCAncmVkJ1xuICAgIHwgJ3RyYW5zcGFyZW50J1xuICAgIHwgJ3dhdGVybWVsb24nXG4gICAgfCAnd2hpdGUnLFxuICBmaXQ/OiBib29sZWFuLFxuICBmbGV4PzogJ2dyb3cnIHwgJ3NocmluaycgfCAnbm9uZScsXG4gIGhlaWdodD86IG51bWJlciB8IHN0cmluZyxcbiAganVzdGlmeUNvbnRlbnQ/OiAnc3RhcnQnIHwgJ2VuZCcgfCAnY2VudGVyJyB8ICdiZXR3ZWVuJyB8ICdhcm91bmQnLFxuICBsZWZ0PzogYm9vbGVhbixcblxuICBtYXJnaW5TdGFydD86IE1hcmdpbixcbiAgbWFyZ2luRW5kPzogTWFyZ2luLFxuXG4gIG1hcmdpbj86IE1hcmdpbixcbiAgbWFyZ2luVG9wPzogTWFyZ2luLFxuICBtYXJnaW5SaWdodD86IE1hcmdpbixcbiAgbWFyZ2luQm90dG9tPzogTWFyZ2luLFxuICBtYXJnaW5MZWZ0PzogTWFyZ2luLFxuXG4gIHNtTWFyZ2luPzogTWFyZ2luLFxuICBzbU1hcmdpblRvcD86IE1hcmdpbixcbiAgc21NYXJnaW5SaWdodD86IE1hcmdpbixcbiAgc21NYXJnaW5Cb3R0b20/OiBNYXJnaW4sXG4gIHNtTWFyZ2luTGVmdD86IE1hcmdpbixcblxuICBtZE1hcmdpbj86IE1hcmdpbixcbiAgbWRNYXJnaW5Ub3A/OiBNYXJnaW4sXG4gIG1kTWFyZ2luUmlnaHQ/OiBNYXJnaW4sXG4gIG1kTWFyZ2luQm90dG9tPzogTWFyZ2luLFxuICBtZE1hcmdpbkxlZnQ/OiBNYXJnaW4sXG5cbiAgbGdNYXJnaW4/OiBNYXJnaW4sXG4gIGxnTWFyZ2luVG9wPzogTWFyZ2luLFxuICBsZ01hcmdpblJpZ2h0PzogTWFyZ2luLFxuICBsZ01hcmdpbkJvdHRvbT86IE1hcmdpbixcbiAgbGdNYXJnaW5MZWZ0PzogTWFyZ2luLFxuXG4gIG1heEhlaWdodD86IG51bWJlciB8IHN0cmluZyxcbiAgbWF4V2lkdGg/OiBudW1iZXIgfCBzdHJpbmcsXG4gIG1pbkhlaWdodD86IG51bWJlciB8IHN0cmluZyxcbiAgbWluV2lkdGg/OiBudW1iZXIgfCBzdHJpbmcsXG5cbiAgb3ZlcmZsb3c/OiAndmlzaWJsZScgfCAnaGlkZGVuJyB8ICdzY3JvbGwnIHwgJ3Njcm9sbFgnIHwgJ3Njcm9sbFknIHwgJ2F1dG8nLFxuXG4gIHBhZGRpbmc/OiBQYWRkaW5nLFxuICBzbVBhZGRpbmc/OiBQYWRkaW5nLFxuICBtZFBhZGRpbmc/OiBQYWRkaW5nLFxuICBsZ1BhZGRpbmc/OiBQYWRkaW5nLFxuXG4gIHBhZGRpbmdYPzogUGFkZGluZyxcbiAgc21QYWRkaW5nWD86IFBhZGRpbmcsXG4gIG1kUGFkZGluZ1g/OiBQYWRkaW5nLFxuICBsZ1BhZGRpbmdYPzogUGFkZGluZyxcblxuICBwYWRkaW5nWT86IFBhZGRpbmcsXG4gIHNtUGFkZGluZ1k/OiBQYWRkaW5nLFxuICBtZFBhZGRpbmdZPzogUGFkZGluZyxcbiAgbGdQYWRkaW5nWT86IFBhZGRpbmcsXG5cbiAgcG9zaXRpb24/OiAnc3RhdGljJyB8ICdhYnNvbHV0ZScgfCAncmVsYXRpdmUnIHwgJ2ZpeGVkJyxcbiAgcmlnaHQ/OiBib29sZWFuLFxuICBzaGFwZT86XG4gICAgfCAnc3F1YXJlJ1xuICAgIHwgJ3JvdW5kZWQnXG4gICAgfCAncGlsbCdcbiAgICB8ICdjaXJjbGUnXG4gICAgfCAncm91bmRlZFRvcCdcbiAgICB8ICdyb3VuZGVkQm90dG9tJ1xuICAgIHwgJ3JvdW5kZWRMZWZ0J1xuICAgIHwgJ3JvdW5kZWRSaWdodCcsXG4gIHNocmluaz86IGJvb2xlYW4sXG4gIHRvcD86IGJvb2xlYW4sXG4gIHdpZHRoPzogbnVtYmVyIHwgc3RyaW5nLFxuICB3cmFwPzogYm9vbGVhbixcbn07XG5cbi8vIC0tXG5cbi8qXG5cbiMgVHJhbnNmb3JtZXJzXG5cblRoaXMgaXMgd2hlcmUgdGhlIG1lYXQgYW5kIHRoZSBib25lcyBvZiBCb3gncyB0cmFuc2Zvcm1zIGFyZS4gWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgdGhlIERTTCBpbiBgLi90cmFuc2Zvcm1zLmpzYCwgYnV0IGJhc2ljYWxseSB0aGV5IGFyZSBhIHNtYWxsIGRlY2xhcmF0aXZlIHdheSBvZiBzcGVjaWZ5aW5nIGhvdyBhIHByb3BlcnR5IChpLmUuIGBtYXJnaW5Ub3A9ezR9YCkgZ2V0cyB0dXJuZWQgaW50byBhIENTUyBjbGFzcyAoYG1hcmdpblRvcDRgKS5cblxuVGhlcmUncyBhIGxpdHRsZSBwcmVhbWJsZSBoZXJlLCBidXQgaXQgY3VsbWluYXRlcyBpbiBhIGJpZyBvYmplY3QgbWFwcGluZyB0aGUgYWN0dWFsIHByb3BlcnR5IG5hbWVzIHRvIHRoZSB0cmFuc2Zvcm1lciB2YWx1ZXMuXG5cbiovXG5cbmNvbnN0IG1hcmdpblN0YXJ0ID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdtYXJnaW5TdGFydCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IG1hcmdpbkVuZCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbWFyZ2luRW5kJyksIHdoaXRlc3BhY2UpO1xuY29uc3QgbWFyZ2luVG9wID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdtYXJnaW5Ub3AnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBtYXJnaW5SaWdodCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbWFyZ2luUmlnaHQnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBtYXJnaW5Cb3R0b20gPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ21hcmdpbkJvdHRvbScpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IG1hcmdpbkxlZnQgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ21hcmdpbkxlZnQnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBtYXJnaW4gPSB1bmlvbihtYXJnaW5Ub3AsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdCwgbWFyZ2luUmlnaHQpO1xuXG5jb25zdCBzbU1hcmdpblRvcCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnc21NYXJnaW5Ub3AnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBzbU1hcmdpblJpZ2h0ID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdzbU1hcmdpblJpZ2h0JyksIHdoaXRlc3BhY2UpO1xuY29uc3Qgc21NYXJnaW5Cb3R0b20gPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ3NtTWFyZ2luQm90dG9tJyksIHdoaXRlc3BhY2UpO1xuY29uc3Qgc21NYXJnaW5MZWZ0ID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdzbU1hcmdpbkxlZnQnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBzbU1hcmdpbiA9IHVuaW9uKFxuICBzbU1hcmdpblRvcCxcbiAgc21NYXJnaW5Cb3R0b20sXG4gIHNtTWFyZ2luTGVmdCxcbiAgc21NYXJnaW5SaWdodFxuKTtcblxuY29uc3QgbWRNYXJnaW5Ub3AgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ21kTWFyZ2luVG9wJyksIHdoaXRlc3BhY2UpO1xuY29uc3QgbWRNYXJnaW5SaWdodCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbWRNYXJnaW5SaWdodCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IG1kTWFyZ2luQm90dG9tID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdtZE1hcmdpbkJvdHRvbScpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IG1kTWFyZ2luTGVmdCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbWRNYXJnaW5MZWZ0JyksIHdoaXRlc3BhY2UpO1xuY29uc3QgbWRNYXJnaW4gPSB1bmlvbihcbiAgbWRNYXJnaW5Ub3AsXG4gIG1kTWFyZ2luQm90dG9tLFxuICBtZE1hcmdpbkxlZnQsXG4gIG1kTWFyZ2luUmlnaHRcbik7XG5cbmNvbnN0IGxnTWFyZ2luVG9wID0gYmluZChyYW5nZVdpdGhvdXRaZXJvKCdsZ01hcmdpblRvcCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IGxnTWFyZ2luUmlnaHQgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ2xnTWFyZ2luUmlnaHQnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBsZ01hcmdpbkJvdHRvbSA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbGdNYXJnaW5Cb3R0b20nKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBsZ01hcmdpbkxlZnQgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ2xnTWFyZ2luTGVmdCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IGxnTWFyZ2luID0gdW5pb24oXG4gIGxnTWFyZ2luVG9wLFxuICBsZ01hcmdpbkJvdHRvbSxcbiAgbGdNYXJnaW5MZWZ0LFxuICBsZ01hcmdpblJpZ2h0XG4pO1xuXG5jb25zdCBwYWRkaW5nWCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygncGFkZGluZ1gnKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBwYWRkaW5nWSA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygncGFkZGluZ1knKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBwYWRkaW5nID0gdW5pb24ocGFkZGluZ1gsIHBhZGRpbmdZKTtcblxuY29uc3Qgc21QYWRkaW5nWCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnc21QYWRkaW5nWCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IHNtUGFkZGluZ1kgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ3NtUGFkZGluZ1knKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBzbVBhZGRpbmcgPSB1bmlvbihzbVBhZGRpbmdYLCBzbVBhZGRpbmdZKTtcblxuY29uc3QgbWRQYWRkaW5nWCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbWRQYWRkaW5nWCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IG1kUGFkZGluZ1kgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ21kUGFkZGluZ1knKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBtZFBhZGRpbmcgPSB1bmlvbihtZFBhZGRpbmdYLCBtZFBhZGRpbmdZKTtcblxuY29uc3QgbGdQYWRkaW5nWCA9IGJpbmQocmFuZ2VXaXRob3V0WmVybygnbGdQYWRkaW5nWCcpLCB3aGl0ZXNwYWNlKTtcbmNvbnN0IGxnUGFkZGluZ1kgPSBiaW5kKHJhbmdlV2l0aG91dFplcm8oJ2xnUGFkZGluZ1knKSwgd2hpdGVzcGFjZSk7XG5jb25zdCBsZ1BhZGRpbmcgPSB1bmlvbihsZ1BhZGRpbmdYLCBsZ1BhZGRpbmdZKTtcblxuLypcblxuVGhlc2UgZnVuY3Rpb25zIGFyZSBsZWdhY3kuIEknZCBsaWtlIHRvIGdldCByaWQgb2YgbW9zdCBvZiB0aGlzIGZpbGUncyBkZXBlbmRlbmN5IG9uIGltcG9ydGluZyBgLi9zdHlsZS5qc2AgZGlyZWN0bHkgb25jZSB0aGVzZSBhcmUgcmVtb3ZlZC5cblxuKi9cblxuY29uc3QgcHJlZml4ID0gKHByZTogc3RyaW5nKSA9PiBtYXBDbGFzc05hbWUobmFtZSA9PiBgJHtwcmV9JHtuYW1lfWApO1xuY29uc3QgZGlzcGxheSA9IHZhbHVlID0+IHtcbiAgc3dpdGNoICh2YWx1ZSkge1xuICAgIGNhc2UgJ2ZsZXgnOlxuICAgICAgcmV0dXJuIGZyb21DbGFzc05hbWUoJ0Rpc3BsYXlGbGV4JywgJ0RpcmVjdGlvblJvdycpO1xuICAgIGNhc2UgJ2ZsZXhDb2x1bW4nOlxuICAgICAgcmV0dXJuIGZyb21DbGFzc05hbWUoJ0Rpc3BsYXlGbGV4JywgJ0RpcmVjdGlvbkNvbHVtbicpO1xuICAgIGNhc2UgJ2lubGluZUJsb2NrJzpcbiAgICAgIHJldHVybiBmcm9tQ2xhc3NOYW1lKCdEaXNwbGF5SW5saW5lQmxvY2snKTtcbiAgICBjYXNlICd2aXN1YWxseUhpZGRlbic6XG4gICAgICByZXR1cm4gZnJvbUNsYXNzTmFtZSgnRGlzcGxheVZpc3VhbGx5SGlkZGVuJyk7XG4gICAgY2FzZSBmYWxzZTpcbiAgICAgIHJldHVybiBmcm9tQ2xhc3NOYW1lKCdEaXNwbGF5Tm9uZScpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvKiBibG9jayAqL1xuICAgICAgcmV0dXJuIGZyb21DbGFzc05hbWUoJ0Rpc3BsYXlCbG9jaycpO1xuICB9XG59O1xuY29uc3QgY29sdW1uID0gcmFuZ2UoJ0NvbCcpO1xuXG5jb25zdCBmb3JtYXRJbnRCb2ludCA9IHggPT4gKHggPCAwID8gYG4ke01hdGguYWJzKHgpfWAgOiB4LnRvU3RyaW5nKCkpO1xuXG4vKlxuXG5JdCdzIHByZWZlcmFibGUgdG8gcHV0IG5ldyBwcm9wZXJ0aWVzIGludG8gdGhhdCBvYmplY3QgZGlyZWN0bHkganVzdCBzbyBpdCdzIGVhc2llciB0byByZWFkLlxuXG4qL1xuXG5jb25zdCBwcm9wVG9GbiA9IHtcbiAgeHM6IHZhbHVlID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gaWRlbnRpdHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcENsYXNzTmFtZShjID0+IHN0eWxlc1tjXSkoXG4gICAgICBwcmVmaXgoJ3hzJykoXG4gICAgICAgIGNvbmNhdChbXG4gICAgICAgICAgdmFsdWUuY29sdW1uID8gY29sdW1uKHZhbHVlLmNvbHVtbikgOiBpZGVudGl0eSgpLFxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS5kaXNwbGF5ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBkaXNwbGF5KHZhbHVlLmRpc3BsYXkpXG4gICAgICAgICAgICA6IGlkZW50aXR5KCksXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfSxcbiAgc206IHZhbHVlID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gaWRlbnRpdHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcENsYXNzTmFtZShjID0+IHN0eWxlc1tjXSkoXG4gICAgICBwcmVmaXgoJ3NtJykoXG4gICAgICAgIGNvbmNhdChbXG4gICAgICAgICAgdmFsdWUuY29sdW1uID8gY29sdW1uKHZhbHVlLmNvbHVtbikgOiBpZGVudGl0eSgpLFxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS5kaXNwbGF5ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBkaXNwbGF5KHZhbHVlLmRpc3BsYXkpXG4gICAgICAgICAgICA6IGlkZW50aXR5KCksXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfSxcbiAgbWQ6IHZhbHVlID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gaWRlbnRpdHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcENsYXNzTmFtZShjID0+IHN0eWxlc1tjXSkoXG4gICAgICBwcmVmaXgoJ21kJykoXG4gICAgICAgIGNvbmNhdChbXG4gICAgICAgICAgdmFsdWUuY29sdW1uID8gY29sdW1uKHZhbHVlLmNvbHVtbikgOiBpZGVudGl0eSgpLFxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS5kaXNwbGF5ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBkaXNwbGF5KHZhbHVlLmRpc3BsYXkpXG4gICAgICAgICAgICA6IGlkZW50aXR5KCksXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfSxcbiAgbGc6IHZhbHVlID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gaWRlbnRpdHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcENsYXNzTmFtZShjID0+IHN0eWxlc1tjXSkoXG4gICAgICBwcmVmaXgoJ2xnJykoXG4gICAgICAgIGNvbmNhdChbXG4gICAgICAgICAgdmFsdWUuY29sdW1uID8gY29sdW1uKHZhbHVlLmNvbHVtbikgOiBpZGVudGl0eSgpLFxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS5kaXNwbGF5ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBkaXNwbGF5KHZhbHVlLmRpc3BsYXkpXG4gICAgICAgICAgICA6IGlkZW50aXR5KCksXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfSxcblxuICBkaXNwbGF5OiBtYXBwaW5nKHtcbiAgICBub25lOiBzdHlsZXMueHNEaXNwbGF5Tm9uZSxcbiAgICBmbGV4OiBzdHlsZXMueHNEaXNwbGF5RmxleCxcbiAgICBibG9jazogc3R5bGVzLnhzRGlzcGxheUJsb2NrLFxuICAgIGlubGluZUJsb2NrOiBzdHlsZXMueHNEaXNwbGF5SW5saW5lQmxvY2ssXG4gICAgdmlzdWFsbHlIaWRkZW46IHN0eWxlcy54c0Rpc3BsYXlWaXN1YWxseUhpZGRlbixcbiAgfSksXG4gIGNvbHVtbjogYmluZChyYW5nZSgneHNDb2wnKSwgc3R5bGVzKSxcbiAgZGlyZWN0aW9uOiBtYXBwaW5nKHtcbiAgICByb3c6IHN0eWxlcy54c0RpcmVjdGlvblJvdyxcbiAgICBjb2x1bW46IHN0eWxlcy54c0RpcmVjdGlvbkNvbHVtbixcbiAgfSksXG5cbiAgc21EaXNwbGF5OiBtYXBwaW5nKHtcbiAgICBub25lOiBzdHlsZXMuc21EaXNwbGF5Tm9uZSxcbiAgICBmbGV4OiBzdHlsZXMuc21EaXNwbGF5RmxleCxcbiAgICBibG9jazogc3R5bGVzLnNtRGlzcGxheUJsb2NrLFxuICAgIGlubGluZUJsb2NrOiBzdHlsZXMuc21EaXNwbGF5SW5saW5lQmxvY2ssXG4gICAgdmlzdWFsbHlIaWRkZW46IHN0eWxlcy5zbURpc3BsYXlWaXN1YWxseUhpZGRlbixcbiAgfSksXG4gIHNtQ29sdW1uOiBiaW5kKHJhbmdlKCdzbUNvbCcpLCBzdHlsZXMpLFxuICBzbURpcmVjdGlvbjogbWFwcGluZyh7XG4gICAgcm93OiBzdHlsZXMuc21EaXJlY3Rpb25Sb3csXG4gICAgY29sdW1uOiBzdHlsZXMuc21EaXJlY3Rpb25Db2x1bW4sXG4gIH0pLFxuXG4gIG1kRGlzcGxheTogbWFwcGluZyh7XG4gICAgbm9uZTogc3R5bGVzLm1kRGlzcGxheU5vbmUsXG4gICAgZmxleDogc3R5bGVzLm1kRGlzcGxheUZsZXgsXG4gICAgYmxvY2s6IHN0eWxlcy5tZERpc3BsYXlCbG9jayxcbiAgICBpbmxpbmVCbG9jazogc3R5bGVzLm1kRGlzcGxheUlubGluZUJsb2NrLFxuICAgIHZpc3VhbGx5SGlkZGVuOiBzdHlsZXMubWREaXNwbGF5VmlzdWFsbHlIaWRkZW4sXG4gIH0pLFxuICBtZENvbHVtbjogYmluZChyYW5nZSgnbWRDb2wnKSwgc3R5bGVzKSxcbiAgbWREaXJlY3Rpb246IG1hcHBpbmcoe1xuICAgIHJvdzogc3R5bGVzLm1kRGlyZWN0aW9uUm93LFxuICAgIGNvbHVtbjogc3R5bGVzLm1kRGlyZWN0aW9uQ29sdW1uLFxuICB9KSxcblxuICBsZ0Rpc3BsYXk6IG1hcHBpbmcoe1xuICAgIG5vbmU6IHN0eWxlcy5sZ0Rpc3BsYXlOb25lLFxuICAgIGZsZXg6IHN0eWxlcy5sZ0Rpc3BsYXlGbGV4LFxuICAgIGJsb2NrOiBzdHlsZXMubGdEaXNwbGF5QmxvY2ssXG4gICAgaW5saW5lQmxvY2s6IHN0eWxlcy5sZ0Rpc3BsYXlJbmxpbmVCbG9jayxcbiAgICB2aXN1YWxseUhpZGRlbjogc3R5bGVzLmxnRGlzcGxheVZpc3VhbGx5SGlkZGVuLFxuICB9KSxcbiAgbGdDb2x1bW46IGJpbmQocmFuZ2UoJ2xnQ29sJyksIHN0eWxlcyksXG4gIGxnRGlyZWN0aW9uOiBtYXBwaW5nKHtcbiAgICByb3c6IHN0eWxlcy5sZ0RpcmVjdGlvblJvdyxcbiAgICBjb2x1bW46IHN0eWxlcy5sZ0RpcmVjdGlvbkNvbHVtbixcbiAgfSksXG5cbiAgYWxpZ25Db250ZW50OiBtYXBwaW5nKHtcbiAgICBzdGFydDogbGF5b3V0LmNvbnRlbnRTdGFydCxcbiAgICBlbmQ6IGxheW91dC5jb250ZW50RW5kLFxuICAgIGNlbnRlcjogbGF5b3V0LmNvbnRlbnRDZW50ZXIsXG4gICAgYmV0d2VlbjogbGF5b3V0LmNvbnRlbnRCZXR3ZWVuLFxuICAgIGFyb3VuZDogbGF5b3V0LmNvbnRlbnRBcm91bmQsXG4gICAgLy8gZGVmYXVsdDogc3RyZXRjaFxuICB9KSxcbiAgYWxpZ25JdGVtczogbWFwcGluZyh7XG4gICAgc3RhcnQ6IGxheW91dC5pdGVtc1N0YXJ0LFxuICAgIGVuZDogbGF5b3V0Lml0ZW1zRW5kLFxuICAgIGNlbnRlcjogbGF5b3V0Lml0ZW1zQ2VudGVyLFxuICAgIGJhc2VsaW5lOiBsYXlvdXQuaXRlbXNCYXNlbGluZSxcbiAgICAvLyBkZWZhdWx0OiBzdHJldGNoXG4gIH0pLFxuICBhbGlnblNlbGY6IG1hcHBpbmcoe1xuICAgIHN0YXJ0OiBsYXlvdXQuc2VsZlN0YXJ0LFxuICAgIGVuZDogbGF5b3V0LnNlbGZFbmQsXG4gICAgY2VudGVyOiBsYXlvdXQuc2VsZkNlbnRlcixcbiAgICBiYXNlbGluZTogbGF5b3V0LnNlbGZCYXNlbGluZSxcbiAgICBzdHJldGNoOiBsYXlvdXQuc2VsZlN0cmV0Y2gsXG4gICAgLy8gZGVmYXVsdDogYXV0b1xuICB9KSxcbiAgYm90dG9tOiB0b2dnbGUobGF5b3V0LmJvdHRvbTApLFxuICBjb2xvcjogbWFwcGluZyh7XG4gICAgYmx1ZTogY29sb3JzLmJsdWVCZyxcbiAgICBkYXJrR3JheTogY29sb3JzLmRhcmtHcmF5QmcsXG4gICAgcGluZTogY29sb3JzLnBpbmVCZyxcbiAgICBncmF5OiBjb2xvcnMuZ3JheUJnLFxuICAgIHJlZDogY29sb3JzLnJlZEJnLFxuICAgIG9saXZlOiBjb2xvcnMub2xpdmVCZyxcbiAgICBsaWdodEdyYXk6IGNvbG9ycy5saWdodEdyYXlCZyxcbiAgICB3aGl0ZTogY29sb3JzLndoaXRlQmcsXG4gICAgb3JhbmdlOiBjb2xvcnMub3JhbmdlQmcsXG4gICAgZ3JlZW46IGNvbG9ycy5ncmVlbkJnLFxuICAgIG5hdnk6IGNvbG9ycy5uYXZ5QmcsXG4gICAgbWlkbmlnaHQ6IGNvbG9ycy5taWRuaWdodEJnLFxuICAgIHB1cnBsZTogY29sb3JzLnB1cnBsZUJnLFxuICAgIG9yY2hpZDogY29sb3JzLm9yY2hpZEJnLFxuICAgIGVnZ3BsYW50OiBjb2xvcnMuZWdncGxhbnRCZyxcbiAgICBtYXJvb246IGNvbG9ycy5tYXJvb25CZyxcbiAgICB3YXRlcm1lbG9uOiBjb2xvcnMud2F0ZXJtZWxvbkJnLFxuICAgIGxpZ2h0V2FzaDogY29sb3JzLmxpZ2h0V2FzaEJnLFxuICAgIGRhcmtXYXNoOiBjb2xvcnMuZGFya1dhc2hCZyxcbiAgICAvLyBkZWZhdWx0OiB0cmFuc3BhcmVudFxuICB9KSxcbiAgZml0OiB0b2dnbGUobGF5b3V0LmZpdCksXG4gIGZsZXg6IG1hcHBpbmcoe1xuICAgIGdyb3c6IGxheW91dC5mbGV4R3JvdyxcbiAgICBub25lOiBsYXlvdXQuZmxleE5vbmUsXG4gICAgLy8gZGVmYXVsdDogc2hyaW5rXG4gIH0pLFxuICBoZWlnaHQ6IGhlaWdodCA9PiBmcm9tSW5saW5lU3R5bGUoeyBoZWlnaHQgfSksXG4gIGp1c3RpZnlDb250ZW50OiBtYXBwaW5nKHtcbiAgICBlbmQ6IGxheW91dC5qdXN0aWZ5RW5kLFxuICAgIGNlbnRlcjogbGF5b3V0Lmp1c3RpZnlDZW50ZXIsXG4gICAgYmV0d2VlbjogbGF5b3V0Lmp1c3RpZnlCZXR3ZWVuLFxuICAgIGFyb3VuZDogbGF5b3V0Lmp1c3RpZnlBcm91bmQsXG4gICAgLy8gZGVmYXVsdDogc3RhcnRcbiAgfSksXG4gIGxlZnQ6IHRvZ2dsZShsYXlvdXQubGVmdDApLFxuICBkZXByZWNhdGVkTWFyZ2luOiB2YWx1ZSA9PiB7XG4gICAgbGV0IG10ID0gaWRlbnRpdHkoKTtcbiAgICBsZXQgbWIgPSBpZGVudGl0eSgpO1xuICAgIGxldCBtbCA9IGlkZW50aXR5KCk7XG4gICAgbGV0IG1yID0gaWRlbnRpdHkoKTtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIGZyb21DbGFzc05hbWUod2hpdGVzcGFjZUxlZ2FjeVtgbSR7Zm9ybWF0SW50Qm9pbnQodmFsdWUpfWBdKTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmICh2YWx1ZS50b3ApIHtcbiAgICAgICAgICBtdCA9IGZyb21DbGFzc05hbWUoXG4gICAgICAgICAgICB3aGl0ZXNwYWNlTGVnYWN5W2BtdCR7Zm9ybWF0SW50Qm9pbnQodmFsdWUudG9wKX1gXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUuYm90dG9tKSB7XG4gICAgICAgICAgbWIgPSBmcm9tQ2xhc3NOYW1lKFxuICAgICAgICAgICAgd2hpdGVzcGFjZUxlZ2FjeVtgbWIke2Zvcm1hdEludEJvaW50KHZhbHVlLmJvdHRvbSl9YF1cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlZnQpIHtcbiAgICAgICAgICBtbCA9IGZyb21DbGFzc05hbWUoXG4gICAgICAgICAgICB2YWx1ZS5sZWZ0ID09PSAnYXV0bydcbiAgICAgICAgICAgICAgPyB3aGl0ZXNwYWNlTGVnYWN5Lm1sQXV0b1xuICAgICAgICAgICAgICA6IHdoaXRlc3BhY2VMZWdhY3lbYG1sJHtmb3JtYXRJbnRCb2ludCh2YWx1ZS5sZWZ0KX1gXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUucmlnaHQpIHtcbiAgICAgICAgICBtciA9IGZyb21DbGFzc05hbWUoXG4gICAgICAgICAgICB2YWx1ZS5yaWdodCA9PT0gJ2F1dG8nXG4gICAgICAgICAgICAgID8gd2hpdGVzcGFjZUxlZ2FjeS5tckF1dG9cbiAgICAgICAgICAgICAgOiB3aGl0ZXNwYWNlTGVnYWN5W2BtciR7Zm9ybWF0SW50Qm9pbnQodmFsdWUucmlnaHQpfWBdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0KFttdCwgbWIsIG1sLCBtcl0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5KCk7XG4gICAgfVxuICB9LFxuICBtYXJnaW5TdGFydCxcbiAgbWFyZ2luRW5kLFxuICBtYXJnaW4sXG4gIG1hcmdpblRvcCxcbiAgbWFyZ2luUmlnaHQsXG4gIG1hcmdpbkJvdHRvbSxcbiAgbWFyZ2luTGVmdCxcbiAgc21NYXJnaW4sXG4gIHNtTWFyZ2luVG9wLFxuICBzbU1hcmdpblJpZ2h0LFxuICBzbU1hcmdpbkJvdHRvbSxcbiAgc21NYXJnaW5MZWZ0LFxuICBtZE1hcmdpbixcbiAgbWRNYXJnaW5Ub3AsXG4gIG1kTWFyZ2luUmlnaHQsXG4gIG1kTWFyZ2luQm90dG9tLFxuICBtZE1hcmdpbkxlZnQsXG4gIGxnTWFyZ2luLFxuICBsZ01hcmdpblRvcCxcbiAgbGdNYXJnaW5SaWdodCxcbiAgbGdNYXJnaW5Cb3R0b20sXG4gIGxnTWFyZ2luTGVmdCxcbiAgbWF4SGVpZ2h0OiBtYXhIZWlnaHQgPT4gZnJvbUlubGluZVN0eWxlKHsgbWF4SGVpZ2h0IH0pLFxuICBtYXhXaWR0aDogbWF4V2lkdGggPT4gZnJvbUlubGluZVN0eWxlKHsgbWF4V2lkdGggfSksXG4gIG1pbkhlaWdodDogbWluSGVpZ2h0ID0+IGZyb21JbmxpbmVTdHlsZSh7IG1pbkhlaWdodCB9KSxcbiAgbWluV2lkdGg6IG1pbldpZHRoID0+IGZyb21JbmxpbmVTdHlsZSh7IG1pbldpZHRoIH0pLFxuICBvdmVyZmxvdzogbWFwcGluZyh7XG4gICAgaGlkZGVuOiBsYXlvdXQub3ZlcmZsb3dIaWRkZW4sXG4gICAgc2Nyb2xsOiBsYXlvdXQub3ZlcmZsb3dTY3JvbGwsXG4gICAgYXV0bzogbGF5b3V0Lm92ZXJmbG93QXV0byxcbiAgICBzY3JvbGxYOiBsYXlvdXQub3ZlcmZsb3dTY3JvbGxYLFxuICAgIHNjcm9sbFk6IGxheW91dC5vdmVyZmxvd1Njcm9sbFksXG4gICAgLy8gZGVmYXVsdDogdmlzaWJsZVxuICB9KSxcbiAgZGVwcmVjYXRlZFBhZGRpbmc6IHZhbHVlID0+IHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIGZyb21DbGFzc05hbWUod2hpdGVzcGFjZUxlZ2FjeVtgcCR7dmFsdWV9YF0pO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgICAgdmFsdWUueFxuICAgICAgICAgICAgPyBmcm9tQ2xhc3NOYW1lKHdoaXRlc3BhY2VMZWdhY3lbYHB4JHt2YWx1ZS54fWBdKVxuICAgICAgICAgICAgOiBpZGVudGl0eSgpLFxuICAgICAgICAgIHZhbHVlLnlcbiAgICAgICAgICAgID8gZnJvbUNsYXNzTmFtZSh3aGl0ZXNwYWNlTGVnYWN5W2BweSR7dmFsdWUueX1gXSlcbiAgICAgICAgICAgIDogaWRlbnRpdHkoKSxcbiAgICAgICAgXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gaWRlbnRpdHkoKTtcbiAgICB9XG4gIH0sXG4gIHBhZGRpbmcsXG4gIHBhZGRpbmdYLFxuICBwYWRkaW5nWSxcbiAgc21QYWRkaW5nLFxuICBzbVBhZGRpbmdYLFxuICBzbVBhZGRpbmdZLFxuICBtZFBhZGRpbmcsXG4gIG1kUGFkZGluZ1gsXG4gIG1kUGFkZGluZ1ksXG4gIGxnUGFkZGluZyxcbiAgbGdQYWRkaW5nWCxcbiAgbGdQYWRkaW5nWSxcbiAgcG9zaXRpb246IG1hcHBpbmcoe1xuICAgIGFic29sdXRlOiBsYXlvdXQuYWJzb2x1dGUsXG4gICAgcmVsYXRpdmU6IGxheW91dC5yZWxhdGl2ZSxcbiAgICBmaXhlZDogbGF5b3V0LmZpeGVkLFxuICAgIC8vIGRlZmF1bHQ6IHN0YXRpY1xuICB9KSxcbiAgcmlnaHQ6IHRvZ2dsZShsYXlvdXQucmlnaHQwKSxcbiAgc2hhcGU6IG1hcHBpbmcoe1xuICAgIGNpcmNsZTogYm9yZGVycy5jaXJjbGUsXG4gICAgcGlsbDogYm9yZGVycy5waWxsLFxuICAgIHJvdW5kZWQ6IGJvcmRlcnMucm91bmRlZCxcbiAgICByb3VuZGVkQm90dG9tOiBib3JkZXJzLnJvdW5kZWRCb3R0b20sXG4gICAgcm91bmRlZExlZnQ6IGJvcmRlcnMucm91bmRlZExlZnQsXG4gICAgcm91bmRlZFJpZ2h0OiBib3JkZXJzLnJvdW5kZWRSaWdodCxcbiAgICByb3VuZGVkVG9wOiBib3JkZXJzLnJvdW5kZWRUb3AsXG4gICAgLy8gZGVmYXVsdDogc3F1YXJlXG4gIH0pLFxuICB0b3A6IHRvZ2dsZShsYXlvdXQudG9wMCksXG4gIHdpZHRoOiB3aWR0aCA9PiBmcm9tSW5saW5lU3R5bGUoeyB3aWR0aCB9KSxcbiAgd3JhcDogdG9nZ2xlKGxheW91dC5mbGV4V3JhcCksXG4gIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU6IHZhbHVlID0+XG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXG4gICAgdmFsdWUgJiYgdmFsdWUuX19zdHlsZSA/IGZyb21JbmxpbmVTdHlsZSh2YWx1ZS5fX3N0eWxlKSA6IGlkZW50aXR5KCksXG59O1xuXG4vKlxuXG4jIFRoZSBDb21wb25lbnRcblxuKi9cblxuY29uc3QgY29udGFpbnMgPSAoa2V5LCBhcnIpID0+IGFyci5pbmRleE9mKGtleSkgPj0gMDtcbmNvbnN0IG9taXQgPSAoa2V5cywgb2JqKSA9PlxuICBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgoYWNjLCBrKSA9PiB7XG4gICAgaWYgKGNvbnRhaW5zKGssIGtleXMpKSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uYWNjLFxuICAgICAgW2tdOiBvYmpba10sXG4gICAgfTtcbiAgfSwge30pO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCb3goeyBjaGlsZHJlbiwgLi4ucHJvcHMgfTogUHJvcFR5cGUpIHtcbiAgLy8gRmxvdyBjYW4ndCByZWFzb24gYWJvdXQgdGhlIGNvbnN0YW50IG5hdHVyZSBvZiBPYmplY3Qua2V5cyBzbyB3ZSBjYW4ndCB1c2VcbiAgLy8gYSBmdW5jdGlvbmFsIChyZWR1Y2UpIHN0eWxlIGhlcmUuXG5cbiAgLy8gQm94IGlzIGEgXCJwYXNzLXRocm91Z2hcIiBjb21wb25lbnQsIG1lYW5pbmcgdGhhdCBpZiB5b3UgcGFzcyBwcm9wZXJ0aWVzIHRvXG4gIC8vIGl0IHRoYXQgaXQgZG9lc24ndCBrbm93IGFib3V0IChgYXJpYS1sYWJlbGAgZm9yIGluc3RhbmNlKSBpdCBwYXNzZXNcbiAgLy8gZGlyZWN0bHkgYmFjayB0byB0aGUgdW5kZXJseWluZyBgPGRpdi8+YC4gVGhhdCdzIGdlbmVyYWxseSB1c2VmdWwsIGJ1dFxuICAvLyB3ZSdkIGFsc28gbGlrZSB0byBzdHJpcCBvdXQgYSBmZXcgbmF1Z2h0eSBwcm9wZXJ0aWVzIHRoYXQgYnJlYWsgc3R5bGVcbiAgLy8gZW5jYXBzdWxhdGlvbiAoY2xhc3NOYW1lLCBzdHlsZSkgb3IgYWNjZXNzaWJpbGl0eSAob25DbGljaykuXG4gIGxldCBibGFja2xpc3QgPSBbJ29uQ2xpY2snLCAnY2xhc3NOYW1lJywgJ3N0eWxlJ107XG5cbiAgLy8gQWxsIEJveCdzIGFyZSBib3gtc2l6ZWQgYnkgZGVmYXVsdCwgc28gd2Ugc3RhcnQgb2ZmIGJ1aWxkaW5nIHVwIHRoZSBzdHlsZXNcbiAgLy8gdG8gYmUgYXBwbGllZCB3aXRoIGEgQm94IGJhc2UgY2xhc3MuXG4gIGxldCBzID0gZnJvbUNsYXNzTmFtZShzdHlsZXMuYm94KTtcblxuICAvLyBUaGlzIGxvb3BzIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgaWYgaXQgZXhpc3RzIGluIHRoZSBwcmV2aW91c2x5XG4gIC8vIGRlZmluZWQgdHJhbnNmb3JtIG1hcCwgY29uY2F0ZW50ZXMgdGhlIHJlc3VsdGluZyBzdHlsZXMgdG8gdGhlIGJhc2VcbiAgLy8gc3R5bGVzLiBJZiB0aGVyZSdzIGEgbWF0Y2gsIHdlIGFsc28gZG9uJ3QgcGFzcyB0aHJvdWdoIHRoYXQgcHJvcGVydHkuIFRoaXNcbiAgLy8gbWVhbnMgQm94J3MgcnVudGltZSBpcyBvbmx5IGRlcGVuZGVudCBvbiB0aGUgbnVtYmVyIG9mIHByb3BlcnRpZXMgcGFzc2VkXG4gIC8vIHRvIGl0ICh3aGljaCBpcyB0eXBpY2FsbHkgc21hbGwpIGluc3RlYWQgb2YgdGhlIHRvdGFsIG51bWJlciBvZiBwb3NzaWJsZVxuICAvLyBwcm9wZXJ0aWVzICh+MzAgb3Igc28pLiBXaGlsZSBpdCBtYXkgfmZlZWx+IGxpa2UgQm94IGlzIGlubmVmZmljaWVudCwgaXRzXG4gIC8vIGJpZ2dlc3QgcGVyZm9ybWFuY2UgaW1wYWN0IGlzIG9uIHN0YXJ0dXAgdGltZSBiZWNhdXNlIHRoZXJlJ3Mgc28gbXVjaCBjb2RlXG4gIC8vIGhlcmUuXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wcykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvcFRvRm4sIHByb3ApKSB7XG4gICAgICBjb25zdCBmbiA9IHByb3BUb0ZuW3Byb3BdO1xuICAgICAgY29uc3QgdmFsdWUgPSBwcm9wc1twcm9wXTtcbiAgICAgIGJsYWNrbGlzdCA9IGJsYWNrbGlzdC5jb25jYXQocHJvcCk7XG4gICAgICBzID0gY29uY2F0KFtzLCBmbih2YWx1ZSldKTtcbiAgICB9XG4gIH1cblxuICAvLyBBbmQuLi4gbWFnaWMhXG4gIHJldHVybiAoXG4gICAgPGRpdiB7Li4ub21pdChibGFja2xpc3QsIHByb3BzKX0gey4uLnRvUHJvcHMocyl9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvZGl2PlxuICApO1xufVxuXG4vKlxuXG4jIFByb3BUeXBlc1xuXG5BbmQgd2UncmUgZG9uZSBoZXJlIDopXG5cbiovXG5cbmNvbnN0IENvbHVtblByb3BUeXBlID0gUHJvcFR5cGVzLm9uZU9mKFtcbiAgMCxcbiAgMSxcbiAgMixcbiAgMyxcbiAgNCxcbiAgNSxcbiAgNixcbiAgNyxcbiAgOCxcbiAgOSxcbiAgMTAsXG4gIDExLFxuICAxMixcbl0pO1xuXG5jb25zdCBNYXJnaW5Qcm9wVHlwZSA9IFByb3BUeXBlcy5vbmVPZihbXG4gIC0xMixcbiAgLTExLFxuICAtMTAsXG4gIC05LFxuICAtOCxcbiAgLTcsXG4gIC02LFxuICAtNSxcbiAgLTQsXG4gIC0zLFxuICAtMixcbiAgLTEsXG4gIDAsXG4gIDEsXG4gIDIsXG4gIDMsXG4gIDQsXG4gIDUsXG4gIDYsXG4gIDcsXG4gIDgsXG4gIDksXG4gIDEwLFxuICAxMSxcbiAgMTIsXG5dKTtcblxuY29uc3QgUGFkZGluZ1Byb3BUeXBlID0gUHJvcFR5cGVzLm9uZU9mKFtcbiAgMCxcbiAgMSxcbiAgMixcbiAgMyxcbiAgNCxcbiAgNSxcbiAgNixcbiAgNyxcbiAgOCxcbiAgOSxcbiAgMTAsXG4gIDExLFxuICAxMixcbl0pO1xuXG5Cb3gucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU6IFByb3BUeXBlcy5leGFjdCh7XG4gICAgX19zdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgfSksXG5cbiAgeHM6IFByb3BUeXBlcy5leGFjdCh7XG4gICAgZGlzcGxheTogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBQcm9wVHlwZXMuYm9vbCxcbiAgICAgIFByb3BUeXBlcy5vbmVPZihbJ2ZsZXgnLCAnZmxleENvbHVtbicsICdpbmxpbmVCbG9jayddKSxcbiAgICBdKSxcbiAgICBjb2x1bW46IFByb3BUeXBlcy5udW1iZXIsXG4gIH0pLFxuICBzbTogUHJvcFR5cGVzLmV4YWN0KHtcbiAgICBkaXNwbGF5OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgIFByb3BUeXBlcy5ib29sLFxuICAgICAgUHJvcFR5cGVzLm9uZU9mKFsnZmxleCcsICdmbGV4Q29sdW1uJywgJ2lubGluZUJsb2NrJ10pLFxuICAgIF0pLFxuICAgIGNvbHVtbjogUHJvcFR5cGVzLm51bWJlcixcbiAgfSksXG4gIG1kOiBQcm9wVHlwZXMuZXhhY3Qoe1xuICAgIGRpc3BsYXk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgUHJvcFR5cGVzLmJvb2wsXG4gICAgICBQcm9wVHlwZXMub25lT2YoWydmbGV4JywgJ2ZsZXhDb2x1bW4nLCAnaW5saW5lQmxvY2snXSksXG4gICAgXSksXG4gICAgY29sdW1uOiBQcm9wVHlwZXMubnVtYmVyLFxuICB9KSxcbiAgbGc6IFByb3BUeXBlcy5leGFjdCh7XG4gICAgZGlzcGxheTogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBQcm9wVHlwZXMuYm9vbCxcbiAgICAgIFByb3BUeXBlcy5vbmVPZihbJ2ZsZXgnLCAnZmxleENvbHVtbicsICdpbmxpbmVCbG9jayddKSxcbiAgICBdKSxcbiAgICBjb2x1bW46IFByb3BUeXBlcy5udW1iZXIsXG4gIH0pLFxuICBkZXByZWNhdGVkTWFyZ2luOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICBQcm9wVHlwZXMubnVtYmVyLFxuICAgIFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICB0b3A6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICBib3R0b206IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICBsZWZ0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMub25lT2YoWydhdXRvJ10pXSksXG4gICAgICByaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLm9uZU9mKFsnYXV0byddKV0pLFxuICAgIH0pLFxuICBdKSxcbiAgZGVwcmVjYXRlZFBhZGRpbmc6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgIFByb3BUeXBlcy5udW1iZXIsXG4gICAgUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIHg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICB5OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIH0pLFxuICBdKSxcblxuICBkaXNwbGF5OiBQcm9wVHlwZXMub25lT2YoW1xuICAgICdub25lJyxcbiAgICAnZmxleCcsXG4gICAgJ2Jsb2NrJyxcbiAgICAnaW5saW5lQmxvY2snLFxuICAgICd2aXN1YWxseUhpZGRlbicsXG4gIF0pLFxuICBkaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ3JvdycsICdjb2x1bW4nXSksXG4gIGNvbHVtbjogQ29sdW1uUHJvcFR5cGUsXG5cbiAgc21EaXNwbGF5OiBQcm9wVHlwZXMub25lT2YoW1xuICAgICdub25lJyxcbiAgICAnZmxleCcsXG4gICAgJ2Jsb2NrJyxcbiAgICAnaW5saW5lQmxvY2snLFxuICAgICd2aXN1YWxseUhpZGRlbicsXG4gIF0pLFxuICBzbURpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsncm93JywgJ2NvbHVtbiddKSxcbiAgc21Db2x1bW46IENvbHVtblByb3BUeXBlLFxuXG4gIG1kRGlzcGxheTogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnbm9uZScsXG4gICAgJ2ZsZXgnLFxuICAgICdibG9jaycsXG4gICAgJ2lubGluZUJsb2NrJyxcbiAgICAndmlzdWFsbHlIaWRkZW4nLFxuICBdKSxcbiAgbWREaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ3JvdycsICdjb2x1bW4nXSksXG4gIG1kQ29sdW1uOiBDb2x1bW5Qcm9wVHlwZSxcblxuICBsZ0Rpc3BsYXk6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ25vbmUnLFxuICAgICdmbGV4JyxcbiAgICAnYmxvY2snLFxuICAgICdpbmxpbmVCbG9jaycsXG4gICAgJ3Zpc3VhbGx5SGlkZGVuJyxcbiAgXSksXG4gIGxnRGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2YoWydyb3cnLCAnY29sdW1uJ10pLFxuICBsZ0NvbHVtbjogQ29sdW1uUHJvcFR5cGUsXG5cbiAgYWxpZ25Db250ZW50OiBQcm9wVHlwZXMub25lT2YoW1xuICAgICdzdGFydCcsXG4gICAgJ2VuZCcsXG4gICAgJ2NlbnRlcicsXG4gICAgJ2JldHdlZW4nLFxuICAgICdhcm91bmQnLFxuICAgICdzdHJldGNoJyxcbiAgXSksXG4gIGFsaWduSXRlbXM6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ3N0YXJ0JyxcbiAgICAnZW5kJyxcbiAgICAnY2VudGVyJyxcbiAgICAnYmFzZWxpbmUnLFxuICAgICdzdHJldGNoJyxcbiAgXSksXG4gIGFsaWduU2VsZjogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnYXV0bycsXG4gICAgJ3N0YXJ0JyxcbiAgICAnZW5kJyxcbiAgICAnY2VudGVyJyxcbiAgICAnYmFzZWxpbmUnLFxuICAgICdzdHJldGNoJyxcbiAgXSksXG4gIGJvdHRvbTogUHJvcFR5cGVzLmJvb2wsXG4gIGNvbG9yOiBQcm9wVHlwZXMub25lT2YoW1xuICAgICdibHVlJyxcbiAgICAnZGFya0dyYXknLFxuICAgICdkYXJrV2FzaCcsXG4gICAgJ2VnZ3BsYW50JyxcbiAgICAnZ3JheScsXG4gICAgJ2dyZWVuJyxcbiAgICAnbGlnaHRHcmF5JyxcbiAgICAnbGlnaHRXYXNoJyxcbiAgICAnbWFyb29uJyxcbiAgICAnbWlkbmlnaHQnLFxuICAgICduYXZ5JyxcbiAgICAnb2xpdmUnLFxuICAgICdvcmFuZ2UnLFxuICAgICdvcmNoaWQnLFxuICAgICdwaW5lJyxcbiAgICAncHVycGxlJyxcbiAgICAncmVkJyxcbiAgICAndHJhbnNwYXJlbnQnLFxuICAgICd3YXRlcm1lbG9uJyxcbiAgICAnd2hpdGUnLFxuICBdKSxcbiAgZml0OiBQcm9wVHlwZXMuYm9vbCxcbiAgZmxleDogUHJvcFR5cGVzLm9uZU9mKFsnZ3JvdycsICdzaHJpbmsnLCAnbm9uZSddKSxcbiAgZ3JvdzogUHJvcFR5cGVzLmJvb2wsXG4gIGhlaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICBqdXN0aWZ5Q29udGVudDogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnc3RhcnQnLFxuICAgICdlbmQnLFxuICAgICdjZW50ZXInLFxuICAgICdiZXR3ZWVuJyxcbiAgICAnYXJvdW5kJyxcbiAgXSksXG4gIGxlZnQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIG1hcmdpblN0YXJ0OiBNYXJnaW5Qcm9wVHlwZSxcbiAgbWFyZ2luRW5kOiBNYXJnaW5Qcm9wVHlwZSxcblxuICBtYXJnaW46IE1hcmdpblByb3BUeXBlLFxuICBtYXJnaW5Ub3A6IE1hcmdpblByb3BUeXBlLFxuICBtYXJnaW5SaWdodDogTWFyZ2luUHJvcFR5cGUsXG4gIG1hcmdpbkJvdHRvbTogTWFyZ2luUHJvcFR5cGUsXG4gIG1hcmdpbkxlZnQ6IE1hcmdpblByb3BUeXBlLFxuXG4gIHNtTWFyZ2luOiBNYXJnaW5Qcm9wVHlwZSxcbiAgc21NYXJnaW5Ub3A6IE1hcmdpblByb3BUeXBlLFxuICBzbU1hcmdpblJpZ2h0OiBNYXJnaW5Qcm9wVHlwZSxcbiAgc21NYXJnaW5Cb3R0b206IE1hcmdpblByb3BUeXBlLFxuICBzbU1hcmdpbkxlZnQ6IE1hcmdpblByb3BUeXBlLFxuXG4gIG1kTWFyZ2luOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbWRNYXJnaW5Ub3A6IE1hcmdpblByb3BUeXBlLFxuICBtZE1hcmdpblJpZ2h0OiBNYXJnaW5Qcm9wVHlwZSxcbiAgbWRNYXJnaW5Cb3R0b206IE1hcmdpblByb3BUeXBlLFxuICBtZE1hcmdpbkxlZnQ6IE1hcmdpblByb3BUeXBlLFxuXG4gIGxnTWFyZ2luOiBNYXJnaW5Qcm9wVHlwZSxcbiAgbGdNYXJnaW5Ub3A6IE1hcmdpblByb3BUeXBlLFxuICBsZ01hcmdpblJpZ2h0OiBNYXJnaW5Qcm9wVHlwZSxcbiAgbGdNYXJnaW5Cb3R0b206IE1hcmdpblByb3BUeXBlLFxuICBsZ01hcmdpbkxlZnQ6IE1hcmdpblByb3BUeXBlLFxuXG4gIG1heEhlaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICBtYXhXaWR0aDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLnN0cmluZ10pLFxuICBtaW5IZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgbWluV2lkdGg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcblxuICBvdmVyZmxvdzogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAndmlzaWJsZScsXG4gICAgJ2hpZGRlbicsXG4gICAgJ3Njcm9sbCcsXG4gICAgJ3Njcm9sbFgnLFxuICAgICdzY3JvbGxZJyxcbiAgICAnYXV0bycsXG4gIF0pLFxuXG4gIHBhZGRpbmc6IFBhZGRpbmdQcm9wVHlwZSxcbiAgcGFkZGluZ1g6IFBhZGRpbmdQcm9wVHlwZSxcbiAgcGFkZGluZ1k6IFBhZGRpbmdQcm9wVHlwZSxcblxuICBzbVBhZGRpbmc6IFBhZGRpbmdQcm9wVHlwZSxcbiAgc21QYWRkaW5nWDogUGFkZGluZ1Byb3BUeXBlLFxuICBzbVBhZGRpbmdZOiBQYWRkaW5nUHJvcFR5cGUsXG5cbiAgbWRQYWRkaW5nOiBQYWRkaW5nUHJvcFR5cGUsXG4gIG1kUGFkZGluZ1g6IFBhZGRpbmdQcm9wVHlwZSxcbiAgbWRQYWRkaW5nWTogUGFkZGluZ1Byb3BUeXBlLFxuXG4gIGxnUGFkZGluZzogUGFkZGluZ1Byb3BUeXBlLFxuICBsZ1BhZGRpbmdYOiBQYWRkaW5nUHJvcFR5cGUsXG4gIGxnUGFkZGluZ1k6IFBhZGRpbmdQcm9wVHlwZSxcblxuICBwb3NpdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsnc3RhdGljJywgJ2Fic29sdXRlJywgJ3JlbGF0aXZlJywgJ2ZpeGVkJ10pLFxuICByaWdodDogUHJvcFR5cGVzLmJvb2wsXG4gIHNoYXBlOiBQcm9wVHlwZXMub25lT2YoW1xuICAgICdzcXVhcmUnLFxuICAgICdyb3VuZGVkJyxcbiAgICAncGlsbCcsXG4gICAgJ2NpcmNsZScsXG4gICAgJ3JvdW5kZWRUb3AnLFxuICAgICdyb3VuZGVkQm90dG9tJyxcbiAgICAncm91bmRlZExlZnQnLFxuICAgICdyb3VuZGVkUmlnaHQnLFxuICBdKSxcbiAgdG9wOiBQcm9wVHlwZXMuYm9vbCxcbiAgd2lkdGg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgd3JhcDogUHJvcFR5cGVzLmJvb2wsXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCBhZGQgZnJvbSAnLi9hZGQuc3ZnJztcbmltcG9ydCBhZGRDaXJjbGUgZnJvbSAnLi9hZGQtY2lyY2xlLnN2Zyc7XG5pbXBvcnQgYWRkUGluIGZyb20gJy4vYWRkLXBpbi5zdmcnO1xuaW1wb3J0IGFuZ2xlZFBpbiBmcm9tICcuL2FuZ2xlZC1waW4uc3ZnJztcbmltcG9ydCBhcnJvd0JhY2sgZnJvbSAnLi9hcnJvdy1iYWNrLnN2Zyc7XG5pbXBvcnQgYXJyb3dDaXJjbGVGb3J3YXJkIGZyb20gJy4vYXJyb3ctY2lyY2xlLWZvcndhcmQuc3ZnJztcbmltcG9ydCBhcnJvd0NpcmNsZURvd24gZnJvbSAnLi9hcnJvdy1jaXJjbGUtZG93bi5zdmcnO1xuaW1wb3J0IGFycm93RG93biBmcm9tICcuL2Fycm93LWRvd24uc3ZnJztcbmltcG9ydCBhcnJvd0ZvcndhcmQgZnJvbSAnLi9hcnJvdy1mb3J3YXJkLnN2Zyc7XG5pbXBvcnQgYXJyb3dVcCBmcm9tICcuL2Fycm93LXVwLnN2Zyc7XG5pbXBvcnQgYXJyb3dVcFJpZ2h0IGZyb20gJy4vYXJyb3ctdXAtcmlnaHQuc3ZnJztcbmltcG9ydCBiZWxsIGZyb20gJy4vYmVsbC5zdmcnO1xuaW1wb3J0IGNhbWVyYSBmcm9tICcuL2NhbWVyYS5zdmcnO1xuaW1wb3J0IGNhbWVyYVJvbGwgZnJvbSAnLi9jYW1lcmEtcm9sbC5zdmcnO1xuaW1wb3J0IGNhbmNlbCBmcm9tICcuL2NhbmNlbC5zdmcnO1xuaW1wb3J0IGNoZWNrIGZyb20gJy4vY2hlY2suc3ZnJztcbmltcG9ydCBjaGVja0NpcmNsZSBmcm9tICcuL2NoZWNrLWNpcmNsZS5zdmcnO1xuaW1wb3J0IGNpcmNsZU91dGxpbmUgZnJvbSAnLi9jaXJjbGUtb3V0bGluZS5zdmcnO1xuaW1wb3J0IGNsZWFyIGZyb20gJy4vY2xlYXIuc3ZnJztcbmltcG9ydCBjbG9jayBmcm9tICcuL2Nsb2NrLnN2Zyc7XG5pbXBvcnQgY29nIGZyb20gJy4vY29nLnN2Zyc7XG5pbXBvcnQgY29tcGFzcyBmcm9tICcuL2NvbXBhc3Muc3ZnJztcbmltcG9ydCBkYXNoIGZyb20gJy4vZGFzaC5zdmcnO1xuaW1wb3J0IGVkaXQgZnJvbSAnLi9lZGl0LnN2Zyc7XG5pbXBvcnQgZWxsaXBzaXMgZnJvbSAnLi9lbGxpcHNpcy5zdmcnO1xuaW1wb3J0IGVsbGlwc2lzQ2lyY2xlT3V0bGluZSBmcm9tICcuL2VsbGlwc2lzLWNpcmNsZS1vdXRsaW5lLnN2Zyc7XG5pbXBvcnQgZW52ZWxvcGUgZnJvbSAnLi9lbnZlbG9wZS5zdmcnO1xuaW1wb3J0IGV5ZSBmcm9tICcuL2V5ZS5zdmcnO1xuaW1wb3J0IGZhY2Vib29rIGZyb20gJy4vZmFjZWJvb2suc3ZnJztcbmltcG9ydCBmYWNlSGFwcHkgZnJvbSAnLi9mYWNlLWhhcHB5LnN2Zyc7XG5pbXBvcnQgZmFjZVNhZCBmcm9tICcuL2ZhY2Utc2FkLnN2Zyc7XG5pbXBvcnQgZmFjZVNtaWxleSBmcm9tICcuL2ZhY2Utc21pbGV5LnN2Zyc7XG5pbXBvcnQgZmlsdGVyIGZyb20gJy4vZmlsdGVyLnN2Zyc7XG5pbXBvcnQgZmxhZyBmcm9tICcuL2ZsYWcuc3ZnJztcbmltcG9ydCBmbGFzaGxpZ2h0IGZyb20gJy4vZmxhc2hsaWdodC5zdmcnO1xuaW1wb3J0IGdpZiBmcm9tICcuL2dpZi5zdmcnO1xuaW1wb3J0IGdsb2JlIGZyb20gJy4vZ2xvYmUuc3ZnJztcbmltcG9ydCBnbG9iZUNoZWNrZWQgZnJvbSAnLi9nbG9iZS1jaGVja2VkLnN2Zyc7XG5pbXBvcnQgZ21haWwgZnJvbSAnLi9nbWFpbC5zdmcnO1xuaW1wb3J0IGdvb2dsZVBsdXMgZnJvbSAnLi9nb29nbGUtcGx1cy5zdmcnO1xuaW1wb3J0IGdyYXBoQmFyIGZyb20gJy4vZ3JhcGgtYmFyLnN2Zyc7XG5pbXBvcnQga25vb3AgZnJvbSAnLi9rbm9vcC5zdmcnO1xuaW1wb3J0IGxpZ2h0YnVsYiBmcm9tICcuL2xpZ2h0YnVsYi5zdmcnO1xuaW1wb3J0IGhhbmRsZSBmcm9tICcuL2hhbmRsZS5zdmcnO1xuaW1wb3J0IGhhbmRQb2ludGluZyBmcm9tICcuL2hhbmQtcG9pbnRpbmcuc3ZnJztcbmltcG9ydCBoZWFydCBmcm9tICcuL2hlYXJ0LnN2Zyc7XG5pbXBvcnQgaGVhcnRCcm9rZW4gZnJvbSAnLi9oZWFydC1icm9rZW4uc3ZnJztcbmltcG9ydCBsaW5rIGZyb20gJy4vbGluay5zdmcnO1xuaW1wb3J0IGxvY2F0aW9uIGZyb20gJy4vbG9jYXRpb24uc3ZnJztcbmltcG9ydCBsb2NrIGZyb20gJy4vbG9jay5zdmcnO1xuaW1wb3J0IG1heGltaXplIGZyb20gJy4vbWF4aW1pemUuc3ZnJztcbmltcG9ydCBtZWdhcGhvbmUgZnJvbSAnLi9tZWdhcGhvbmUuc3ZnJztcbmltcG9ydCBtZW51IGZyb20gJy4vbWVudS5zdmcnO1xuaW1wb3J0IG1pbmltaXplIGZyb20gJy4vbWluaW1pemUuc3ZnJztcbmltcG9ydCBtb3ZlIGZyb20gJy4vbW92ZS5zdmcnO1xuaW1wb3J0IG11dGUgZnJvbSAnLi9tdXRlLnN2Zyc7XG5pbXBvcnQgcGF1c2UgZnJvbSAnLi9wYXVzZS5zdmcnO1xuaW1wb3J0IHBlb3BsZSBmcm9tICcuL3Blb3BsZS5zdmcnO1xuaW1wb3J0IHBlcnNvbiBmcm9tICcuL3BlcnNvbi5zdmcnO1xuaW1wb3J0IHBlcnNvbkFkZCBmcm9tICcuL3BlcnNvbi1hZGQuc3ZnJztcbmltcG9ydCBwaW4gZnJvbSAnLi9waW4uc3ZnJztcbmltcG9ydCBwaW5IaWRlIGZyb20gJy4vcGluLWhpZGUuc3ZnJztcbmltcG9ydCBwaW50ZXJlc3QgZnJvbSAnLi9waW50ZXJlc3Quc3ZnJztcbmltcG9ydCBwbGF5IGZyb20gJy4vcGxheS5zdmcnO1xuaW1wb3J0IHF1ZXN0aW9uTWFyayBmcm9tICcuL3F1ZXN0aW9uLW1hcmsuc3ZnJztcbmltcG9ydCByZW1vdmUgZnJvbSAnLi9yZW1vdmUuc3ZnJztcbmltcG9ydCByZXBvcnQgZnJvbSAnLi9yZXBvcnQuc3ZnJztcbmltcG9ydCBzZWFyY2ggZnJvbSAnLi9zZWFyY2guc3ZnJztcbmltcG9ydCBzZW5kIGZyb20gJy4vc2VuZC5zdmcnO1xuaW1wb3J0IHNoYXJlIGZyb20gJy4vc2hhcmUuc3ZnJztcbmltcG9ydCBzaG9wcGluZ0JhZyBmcm9tICcuL3Nob3BwaW5nLWJhZy5zdmcnO1xuaW1wb3J0IHNtaWxleSBmcm9tICcuL3NtaWxleS5zdmcnO1xuaW1wb3J0IHNtaWxleU91dGxpbmUgZnJvbSAnLi9zbWlsZXktb3V0bGluZS5zdmcnO1xuaW1wb3J0IHNvdW5kIGZyb20gJy4vc291bmQuc3ZnJztcbmltcG9ydCBzcGVlY2ggZnJvbSAnLi9zcGVlY2guc3ZnJztcbmltcG9ydCBzcGVlY2hFbGxpcHNpcyBmcm9tICcuL3NwZWVjaC1lbGxpcHNpcy5zdmcnO1xuaW1wb3J0IHRhZyBmcm9tICcuL3RhZy5zdmcnO1xuaW1wb3J0IHR3aXR0ZXIgZnJvbSAnLi90d2l0dGVyLnN2Zyc7XG5pbXBvcnQgdmlld1R5cGVEZWZhdWx0IGZyb20gJy4vdmlldy10eXBlLWRlZmF1bHQuc3ZnJztcbmltcG9ydCB2aWV3VHlwZURlbnNlIGZyb20gJy4vdmlldy10eXBlLWRlbnNlLnN2Zyc7XG5pbXBvcnQgdmlld1R5cGVMaXN0IGZyb20gJy4vdmlldy10eXBlLWxpc3Quc3ZnJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBhZGQsXG4gICdhZGQtY2lyY2xlJzogYWRkQ2lyY2xlLFxuICAnYWRkLXBpbic6IGFkZFBpbixcbiAgJ2FuZ2xlZC1waW4nOiBhbmdsZWRQaW4sXG4gICdhcnJvdy1iYWNrJzogYXJyb3dCYWNrLFxuICAnYXJyb3ctY2lyY2xlLWRvd24nOiBhcnJvd0NpcmNsZURvd24sXG4gICdhcnJvdy1jaXJjbGUtZm9yd2FyZCc6IGFycm93Q2lyY2xlRm9yd2FyZCxcbiAgJ2Fycm93LWRvd24nOiBhcnJvd0Rvd24sXG4gICdhcnJvdy1mb3J3YXJkJzogYXJyb3dGb3J3YXJkLFxuICAnYXJyb3ctdXAnOiBhcnJvd1VwLFxuICAnYXJyb3ctdXAtcmlnaHQnOiBhcnJvd1VwUmlnaHQsXG4gIGJlbGwsXG4gIGNhbWVyYSxcbiAgJ2NhbWVyYS1yb2xsJzogY2FtZXJhUm9sbCxcbiAgY2FuY2VsLFxuICBjaGVjayxcbiAgJ2NoZWNrLWNpcmNsZSc6IGNoZWNrQ2lyY2xlLFxuICAnY2lyY2xlLW91dGxpbmUnOiBjaXJjbGVPdXRsaW5lLFxuICBjbGVhcixcbiAgY2xvY2ssXG4gIGNvZyxcbiAgY29tcGFzcyxcbiAgZGFzaCxcbiAgZWRpdCxcbiAgZWxsaXBzaXMsXG4gICdlbGxpcHNpcy1jaXJjbGUtb3V0bGluZSc6IGVsbGlwc2lzQ2lyY2xlT3V0bGluZSxcbiAgZW52ZWxvcGUsXG4gIGV5ZSxcbiAgZmFjZWJvb2ssXG4gICdmYWNlLWhhcHB5JzogZmFjZUhhcHB5LFxuICAnZmFjZS1zYWQnOiBmYWNlU2FkLFxuICAnZmFjZS1zbWlsZXknOiBmYWNlU21pbGV5LFxuICBmaWx0ZXIsXG4gIGZsYWcsXG4gIGZsYXNobGlnaHQsXG4gIGdpZixcbiAgZ2xvYmUsXG4gICdnbG9iZS1jaGVja2VkJzogZ2xvYmVDaGVja2VkLFxuICBnbWFpbCxcbiAgJ2dvb2dsZS1wbHVzJzogZ29vZ2xlUGx1cyxcbiAgJ2dyYXBoLWJhcic6IGdyYXBoQmFyLFxuICBoYW5kbGUsXG4gICdoYW5kLXBvaW50aW5nJzogaGFuZFBvaW50aW5nLFxuICBoZWFydCxcbiAgJ2hlYXJ0LWJyb2tlbic6IGhlYXJ0QnJva2VuLFxuICBrbm9vcCxcbiAgbGlnaHRidWxiLFxuICBsaW5rLFxuICBsb2NhdGlvbixcbiAgbG9jayxcbiAgbWF4aW1pemUsXG4gIG1lZ2FwaG9uZSxcbiAgbWVudSxcbiAgbWluaW1pemUsXG4gIG1vdmUsXG4gIG11dGUsXG4gIHBhdXNlLFxuICBwZW9wbGUsXG4gIHBlcnNvbixcbiAgJ3BlcnNvbi1hZGQnOiBwZXJzb25BZGQsXG4gIHBpbixcbiAgJ3Bpbi1oaWRlJzogcGluSGlkZSxcbiAgcGludGVyZXN0LFxuICBwbGF5LFxuICAncXVlc3Rpb24tbWFyayc6IHF1ZXN0aW9uTWFyayxcbiAgcmVtb3ZlLFxuICByZXBvcnQsXG4gIHNlYXJjaCxcbiAgJ3Nob3BwaW5nLWJhZyc6IHNob3BwaW5nQmFnLFxuICBzbWlsZXksXG4gICdzbWlsZXktb3V0bGluZSc6IHNtaWxleU91dGxpbmUsXG4gIHNlbmQsXG4gIHNoYXJlLFxuICBzb3VuZCxcbiAgc3BlZWNoLFxuICAnc3BlZWNoLWVsbGlwc2lzJzogc3BlZWNoRWxsaXBzaXMsXG4gIHRhZyxcbiAgdHdpdHRlcixcbiAgJ3ZpZXctdHlwZS1kZWZhdWx0Jzogdmlld1R5cGVEZWZhdWx0LFxuICAndmlldy10eXBlLWRlbnNlJzogdmlld1R5cGVEZW5zZSxcbiAgJ3ZpZXctdHlwZS1saXN0Jzogdmlld1R5cGVMaXN0LFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vSWNvbi5jc3MnO1xuaW1wb3J0IGljb25zIGZyb20gJy4vaWNvbnMvaW5kZXguanMnO1xuaW1wb3J0IGNvbG9ycyBmcm9tICcuL0NvbG9ycy5jc3MnO1xuXG50eXBlIEljb25Qcm9wcyA9IHtcbiAgYWNjZXNzaWJpbGl0eUxhYmVsOiBzdHJpbmcsXG4gIGNvbG9yPzpcbiAgICB8ICdibHVlJ1xuICAgIHwgJ2RhcmtHcmF5J1xuICAgIHwgJ2VnZ3BsYW50J1xuICAgIHwgJ2dyYXknXG4gICAgfCAnZ3JlZW4nXG4gICAgfCAnbGlnaHRHcmF5J1xuICAgIHwgJ21hcm9vbidcbiAgICB8ICdtaWRuaWdodCdcbiAgICB8ICduYXZ5J1xuICAgIHwgJ29saXZlJ1xuICAgIHwgJ29yYW5nZSdcbiAgICB8ICdvcmNoaWQnXG4gICAgfCAncGluZSdcbiAgICB8ICdwdXJwbGUnXG4gICAgfCAncmVkJ1xuICAgIHwgJ3dhdGVybWVsb24nXG4gICAgfCAnd2hpdGUnLFxuICBpbmxpbmU/OiBib29sZWFuLFxuICBzaXplPzogbnVtYmVyIHwgc3RyaW5nLFxufTtcblxudHlwZSBJY29uTm9QYXRoID0ge1xuICBpY29uOiAkS2V5czx0eXBlb2YgaWNvbnM+LFxuICBkYW5nZXJvdXNseVNldFN2Z1BhdGg/OiBudWxsLFxufTtcblxudHlwZSBQYXRoTm9JY29uID0ge1xuICBpY29uPzogbnVsbCxcbiAgZGFuZ2Vyb3VzbHlTZXRTdmdQYXRoOiB7IF9fcGF0aDogc3RyaW5nIH0sXG59O1xuXG50eXBlIFByb3BzID0gSWNvblByb3BzICYgKFBhdGhOb0ljb24gfCBJY29uTm9QYXRoKTtcblxuY29uc3QgSWNvbk5hbWVzID0gT2JqZWN0LmtleXMoaWNvbnMpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJY29uKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7XG4gICAgYWNjZXNzaWJpbGl0eUxhYmVsLFxuICAgIGNvbG9yID0gJ2dyYXknLFxuICAgIGljb24sXG4gICAgaW5saW5lLFxuICAgIHNpemUgPSAxNixcbiAgICBkYW5nZXJvdXNseVNldFN2Z1BhdGgsXG4gIH0gPSBwcm9wcztcblxuICBjb25zdCBjcyA9IGNsYXNzbmFtZXMoc3R5bGVzLmljb24sIGNvbG9yc1tjb2xvcl0sIHtcbiAgICBbc3R5bGVzLmljb25CbG9ja106ICFpbmxpbmUsXG4gIH0pO1xuXG4gIGNvbnN0IHBhdGggPVxuICAgIChpY29uICYmIGljb25zW2ljb25dKSB8fFxuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuICAgIChkYW5nZXJvdXNseVNldFN2Z1BhdGggJiYgZGFuZ2Vyb3VzbHlTZXRTdmdQYXRoLl9fcGF0aCkgfHxcbiAgICB1bmRlZmluZWQ7XG5cbiAgY29uc3QgYXJpYUhpZGRlbiA9IGFjY2Vzc2liaWxpdHlMYWJlbCA9PT0gJycgPyB0cnVlIDogbnVsbDtcblxuICByZXR1cm4gKFxuICAgIDxzdmdcbiAgICAgIGNsYXNzTmFtZT17Y3N9XG4gICAgICBoZWlnaHQ9e3NpemV9XG4gICAgICB3aWR0aD17c2l6ZX1cbiAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxuICAgICAgYXJpYS1oaWRkZW49e2FyaWFIaWRkZW59XG4gICAgICBhcmlhLWxhYmVsPXthY2Nlc3NpYmlsaXR5TGFiZWx9XG4gICAgICByb2xlPVwiaW1nXCJcbiAgICA+XG4gICAgICA8dGl0bGU+e2FjY2Vzc2liaWxpdHlMYWJlbH08L3RpdGxlPlxuICAgICAgPHBhdGggZD17cGF0aH0gLz5cbiAgICA8L3N2Zz5cbiAgKTtcbn1cblxuSWNvbi5pY29ucyA9IEljb25OYW1lcztcblxuSWNvbi5wcm9wVHlwZXMgPSB7XG4gIGFjY2Vzc2liaWxpdHlMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnYmx1ZScsXG4gICAgJ2RhcmtHcmF5JyxcbiAgICAnZWdncGxhbnQnLFxuICAgICdncmF5JyxcbiAgICAnZ3JlZW4nLFxuICAgICdsaWdodEdyYXknLFxuICAgICdtYXJvb24nLFxuICAgICdtaWRuaWdodCcsXG4gICAgJ25hdnknLFxuICAgICdvbGl2ZScsXG4gICAgJ29yYW5nZScsXG4gICAgJ29yY2hpZCcsXG4gICAgJ3BpbmUnLFxuICAgICdwdXJwbGUnLFxuICAgICdyZWQnLFxuICAgICd3YXRlcm1lbG9uJyxcbiAgICAnd2hpdGUnLFxuICBdKSxcbiAgZGFuZ2Vyb3VzbHlTZXRTdmdQYXRoOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIF9fcGF0aDogUHJvcFR5cGVzLnN0cmluZyxcbiAgfSksXG4gIGljb246IFByb3BUeXBlcy5vbmVPZihJY29uTmFtZXMpLFxuICBpbmxpbmU6IFByb3BUeXBlcy5ib29sLFxuICBzaXplOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9JbWFnZS5jc3MnO1xuXG5jb25zdCBzaG91bGRTY2FsZUltYWdlID0gZml0ID0+IGZpdCA9PT0gJ2NvdmVyJyB8fCBmaXQgPT09ICdjb250YWluJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFsdDogc3RyaW5nLFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGNvbG9yOiBzdHJpbmcsXG4gIGZpdDogJ2NvbnRhaW4nIHwgJ2NvdmVyJyB8ICdub25lJyxcbiAgbmF0dXJhbEhlaWdodDogbnVtYmVyLFxuICBuYXR1cmFsV2lkdGg6IG51bWJlcixcbiAgb25FcnJvcj86ICgpID0+IHZvaWQsXG4gIG9uTG9hZD86ICgpID0+IHZvaWQsXG4gIHNpemVzPzogc3RyaW5nLFxuICBzcmM6IHN0cmluZyxcbiAgc3JjU2V0Pzogc3RyaW5nLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEltYWdlIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxQcm9wcz4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGFsdDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgICBjb2xvcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBmaXQ6IFByb3BUeXBlcy5vbmVPZihbJ2NvbnRhaW4nLCAnY292ZXInLCAnbm9uZSddKSxcbiAgICBuYXR1cmFsSGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgbmF0dXJhbFdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgb25FcnJvcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Mb2FkOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBzaXplczogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBzcmM6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBzcmNTZXQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICBmaXQ6ICdub25lJyxcbiAgfTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAoc2hvdWxkU2NhbGVJbWFnZSh0aGlzLnByb3BzLmZpdCkpIHtcbiAgICAgIHRoaXMubG9hZEltYWdlKCk7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogUHJvcHMpIHtcbiAgICBjb25zdCB7IGZpdCwgc3JjIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChzaG91bGRTY2FsZUltYWdlKGZpdCkgJiYgcHJldlByb3BzLnNyYyAhPT0gc3JjKSB7XG4gICAgICB0aGlzLmxvYWRJbWFnZSgpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUxvYWQgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICB0aGlzLnByb3BzLm9uTG9hZCgpO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVFcnJvciA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5wcm9wcy5vbkVycm9yKSB7XG4gICAgICB0aGlzLnByb3BzLm9uRXJyb3IoKTtcbiAgICB9XG4gIH07XG5cbiAgbG9hZEltYWdlKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgd2luZG93LkltYWdlKCk7XG4gICAgICBpbWFnZS5vbmxvYWQgPSB0aGlzLmhhbmRsZUxvYWQ7XG4gICAgICBpbWFnZS5vbmVycm9yID0gdGhpcy5oYW5kbGVFcnJvcjtcbiAgICAgIGltYWdlLnNyYyA9IHRoaXMucHJvcHMuc3JjO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbHQsXG4gICAgICBjb2xvcixcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZml0LFxuICAgICAgbmF0dXJhbEhlaWdodCxcbiAgICAgIG5hdHVyYWxXaWR0aCxcbiAgICAgIHNpemVzLFxuICAgICAgc3JjLFxuICAgICAgc3JjU2V0LFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgaXNTY2FsZWRJbWFnZSA9IHNob3VsZFNjYWxlSW1hZ2UoZml0KTtcbiAgICBjb25zdCBjaGlsZENvbnRlbnQgPSBjaGlsZHJlbiA/IChcbiAgICAgIDxCb3ggcG9zaXRpb249XCJhYnNvbHV0ZVwiIHRvcCBsZWZ0IGJvdHRvbSByaWdodCBvdmVyZmxvdz1cImhpZGRlblwiPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L0JveD5cbiAgICApIDogbnVsbDtcblxuICAgIHJldHVybiBpc1NjYWxlZEltYWdlID8gKFxuICAgICAgPGRpdlxuICAgICAgICBhcmlhLWxhYmVsPXthbHR9XG4gICAgICAgIGNsYXNzTmFtZT17c3R5bGVzW2ZpdF19XG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcixcbiAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGB1cmwoJyR7c3JjfScpYCxcbiAgICAgICAgfX1cbiAgICAgICAgcm9sZT1cImltZ1wiXG4gICAgICA+XG4gICAgICAgIHtjaGlsZENvbnRlbnR9XG4gICAgICA8L2Rpdj5cbiAgICApIDogKFxuICAgICAgPEJveFxuICAgICAgICBwb3NpdGlvbj1cInJlbGF0aXZlXCJcbiAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17e1xuICAgICAgICAgIF9fc3R5bGU6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICBwYWRkaW5nQm90dG9tOiBgJHsobmF0dXJhbEhlaWdodCAvIG5hdHVyYWxXaWR0aCkgKiAxMDB9JWAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgPGltZ1xuICAgICAgICAgIGFsdD17YWx0fVxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmltZ31cbiAgICAgICAgICBvbkVycm9yPXt0aGlzLmhhbmRsZUVycm9yfVxuICAgICAgICAgIG9uTG9hZD17dGhpcy5oYW5kbGVMb2FkfVxuICAgICAgICAgIHNpemVzPXtzaXplc31cbiAgICAgICAgICBzcmM9e3NyY31cbiAgICAgICAgICBzcmNTZXQ9e3NyY1NldH1cbiAgICAgICAgLz5cbiAgICAgICAge2NoaWxkQ29udGVudH1cbiAgICAgIDwvQm94PlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL01hc2suY3NzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgaGVpZ2h0PzogbnVtYmVyIHwgc3RyaW5nLFxuICBzaGFwZT86ICdjaXJjbGUnIHwgJ3JvdW5kZWQnIHwgJ3NxdWFyZScsXG4gIHdpZHRoPzogbnVtYmVyIHwgc3RyaW5nLFxuICB3YXNoPzogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXNrKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7IGNoaWxkcmVuLCBzaGFwZSA9ICdzcXVhcmUnLCB3aWR0aCwgaGVpZ2h0LCB3YXNoID0gZmFsc2UgfSA9IHByb3BzO1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtjeChzdHlsZXMuTWFzaywgc3R5bGVzW3NoYXBlXSl9IHN0eWxlPXt7IHdpZHRoLCBoZWlnaHQgfX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgICB7d2FzaCAmJiA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLndhc2h9IC8+fVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5NYXNrLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgc2hhcGU6IFByb3BUeXBlcy5vbmVPZihbJ2NpcmNsZScsICdyb3VuZGVkJywgJ3NxdWFyZSddKSxcbiAgd2lkdGg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgd2FzaDogUHJvcFR5cGVzLmJvb2wsXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5qcyc7XG5pbXBvcnQgSW1hZ2UgZnJvbSAnLi9JbWFnZS5qcyc7XG5pbXBvcnQgTWFzayBmcm9tICcuL01hc2suanMnO1xuaW1wb3J0IHR5cG9ncmFwaHkgZnJvbSAnLi9UeXBvZ3JhcGh5LmNzcyc7XG5cbmNvbnN0IFNxdWFyZSA9IChwcm9wczogKikgPT4gKFxuICA8Qm94IHsuLi5wcm9wc30gcG9zaXRpb249XCJyZWxhdGl2ZVwiPlxuICAgIDxCb3hcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3sgX19zdHlsZTogeyBwYWRkaW5nQm90dG9tOiAnMTAwJScgfSB9fVxuICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgLz5cbiAgICA8Qm94IHBvc2l0aW9uPVwiYWJzb2x1dGVcIiB0b3AgbGVmdCBib3R0b20gcmlnaHQ+XG4gICAgICB7cHJvcHMuY2hpbGRyZW59XG4gICAgPC9Cb3g+XG4gIDwvQm94PlxuKTtcblxuY29uc3QgRGVmYXVsdEF2YXRhciA9ICh7IG5hbWUgfTogeyBuYW1lOiBzdHJpbmcgfSkgPT4ge1xuICBjb25zdCBmaXJzdEluaXRpYWwgPSBuYW1lID8gWy4uLm5hbWVdWzBdLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgcmV0dXJuIChcbiAgICA8U3F1YXJlIGNvbG9yPVwiZ3JheVwiIHNoYXBlPVwiY2lyY2xlXCI+XG4gICAgICB7Zmlyc3RJbml0aWFsICYmIChcbiAgICAgICAgPHN2Z1xuICAgICAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgICAgICAgdmlld0JveD1cIi01MCAtNTAgMTAwIDEwMFwiXG4gICAgICAgICAgdmVyc2lvbj1cIjEuMVwiXG4gICAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIlxuICAgICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICA+XG4gICAgICAgICAgPHRpdGxlPntuYW1lfTwvdGl0bGU+XG4gICAgICAgICAgPHRleHRcbiAgICAgICAgICAgIGZvbnRTaXplPVwiNTBweFwiXG4gICAgICAgICAgICBmaWxsPVwiI2ZmZlwiXG4gICAgICAgICAgICBkb21pbmFudEJhc2VsaW5lPVwiY2VudHJhbFwiXG4gICAgICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17W1xuICAgICAgICAgICAgICB0eXBvZ3JhcGh5LmFudGlhbGlhc2VkLFxuICAgICAgICAgICAgICB0eXBvZ3JhcGh5LnNhbnNTZXJpZixcbiAgICAgICAgICAgICAgdHlwb2dyYXBoeS5sZWFkaW5nU21hbGwsXG4gICAgICAgICAgICAgIHR5cG9ncmFwaHkuZm9udFdlaWdodEJvbGQsXG4gICAgICAgICAgICBdLmpvaW4oJyAnKX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7Zmlyc3RJbml0aWFsfVxuICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgPC9zdmc+XG4gICAgICApfVxuICAgIDwvU3F1YXJlPlxuICApO1xufTtcblxudHlwZSBTdGF0ZSA9IHt8IGlzSW1hZ2VMb2FkZWQ6IGJvb2xlYW4gfH07XG5cbnR5cGUgQXZhdGFyUHJvcHMgPSB7fFxuICBuYW1lOiBzdHJpbmcsXG4gIG91dGxpbmU/OiBib29sZWFuLFxuICBzaXplPzogJ3NtJyB8ICdtZCcgfCAnbGcnLFxuICBzcmM/OiBzdHJpbmcsXG4gIHZlcmlmaWVkPzogYm9vbGVhbixcbnx9O1xuXG5jb25zdCBzaXplcyA9IHtcbiAgc206IDI0LFxuICBtZDogNDAsXG4gIGxnOiA3Mixcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF2YXRhciBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8QXZhdGFyUHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIG91dGxpbmU6IFByb3BUeXBlcy5ib29sLFxuICAgIHNyYzogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydzbScsICdtZCcsICdsZyddKSxcbiAgICB2ZXJpZmllZDogUHJvcFR5cGVzLmJvb2wsXG4gIH07XG5cbiAgc3RhdGUgPSB7XG4gICAgaXNJbWFnZUxvYWRlZDogdHJ1ZSxcbiAgfTtcblxuICBoYW5kbGVJbWFnZUVycm9yID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGlzSW1hZ2VMb2FkZWQ6IGZhbHNlIH0pO1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IG5hbWUsIG91dGxpbmUsIHNpemUsIHNyYywgdmVyaWZpZWQgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBpc0ltYWdlTG9hZGVkIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHdpZHRoID0gc2l6ZSA/IHNpemVzW3NpemVdIDogJzEwMCUnO1xuICAgIGNvbnN0IGhlaWdodCA9IHNpemUgPyBzaXplc1tzaXplXSA6ICcnO1xuICAgIHJldHVybiAoXG4gICAgICA8Qm94XG4gICAgICAgIGNvbG9yPVwid2hpdGVcIlxuICAgICAgICB7Li4uKG91dGxpbmVcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZToge1xuICAgICAgICAgICAgICAgIF9fc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgIGJveFNoYWRvdzogJzAgMCAwIDJweCAjZmZmJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDoge30pfVxuICAgICAgICB3aWR0aD17d2lkdGh9XG4gICAgICAgIGhlaWdodD17aGVpZ2h0fVxuICAgICAgICBwb3NpdGlvbj1cInJlbGF0aXZlXCJcbiAgICAgICAgc2hhcGU9XCJjaXJjbGVcIlxuICAgICAgPlxuICAgICAgICB7c3JjICYmIGlzSW1hZ2VMb2FkZWQgPyAoXG4gICAgICAgICAgPE1hc2sgc2hhcGU9XCJjaXJjbGVcIiB3YXNoPlxuICAgICAgICAgICAgPEltYWdlXG4gICAgICAgICAgICAgIGFsdD17bmFtZX1cbiAgICAgICAgICAgICAgY29sb3I9XCIjRUZFRkVGXCJcbiAgICAgICAgICAgICAgbmF0dXJhbEhlaWdodD17MX1cbiAgICAgICAgICAgICAgbmF0dXJhbFdpZHRoPXsxfVxuICAgICAgICAgICAgICBzcmM9e3NyY31cbiAgICAgICAgICAgICAgb25FcnJvcj17dGhpcy5oYW5kbGVJbWFnZUVycm9yfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L01hc2s+XG4gICAgICAgICkgOiAoXG4gICAgICAgICAgPERlZmF1bHRBdmF0YXIgbmFtZT17bmFtZX0gLz5cbiAgICAgICAgKX1cbiAgICAgICAge3ZlcmlmaWVkICYmIChcbiAgICAgICAgICA8Qm94XG4gICAgICAgICAgICBwb3NpdGlvbj1cImFic29sdXRlXCJcbiAgICAgICAgICAgIHdpZHRoPVwiMjAlXCJcbiAgICAgICAgICAgIGhlaWdodD1cIjIwJVwiXG4gICAgICAgICAgICBtaW5XaWR0aD17OH1cbiAgICAgICAgICAgIG1pbkhlaWdodD17OH1cbiAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3tcbiAgICAgICAgICAgICAgX19zdHlsZToge1xuICAgICAgICAgICAgICAgIGJvdHRvbTogJzQlJyxcbiAgICAgICAgICAgICAgICByaWdodDogJzQlJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPEJveFxuICAgICAgICAgICAgICBjb2xvcj1cIndoaXRlXCJcbiAgICAgICAgICAgICAgd2lkdGg9XCIxMDAlXCJcbiAgICAgICAgICAgICAgaGVpZ2h0PVwiMTAwJVwiXG4gICAgICAgICAgICAgIHNoYXBlPVwiY2lyY2xlXCJcbiAgICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17e1xuICAgICAgICAgICAgICAgIF9fc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgIGJveFNoYWRvdzogJzAgMCAwIDJweCAjZmZmJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8SWNvblxuICAgICAgICAgICAgICAgIGNvbG9yPVwicmVkXCJcbiAgICAgICAgICAgICAgICBpY29uPVwiY2hlY2stY2lyY2xlXCJcbiAgICAgICAgICAgICAgICBhY2Nlc3NpYmlsaXR5TGFiZWw9XCJcIlxuICAgICAgICAgICAgICAgIHNpemU9XCIxMDAlXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvQm94PlxuICAgICAgICAgIDwvQm94PlxuICAgICAgICApfVxuICAgICAgPC9Cb3g+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBjb2xvcnMgZnJvbSAnLi9Db2xvcnMuY3NzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9UZXh0LmNzcyc7XG5pbXBvcnQgdHlwb2dyYXBoeSBmcm9tICcuL1R5cG9ncmFwaHkuY3NzJztcblxuY29uc3QgU0laRV9TQ0FMRTogeyBbc2l6ZTogP3N0cmluZ106IG51bWJlciB9ID0ge1xuICB4czogMSxcbiAgc206IDIsXG4gIG1kOiAzLFxuICBsZzogNCxcbiAgeGw6IDUsXG59O1xuXG50eXBlIFByb3BzID0ge3xcbiAgYWxpZ24/OiAnbGVmdCcgfCAncmlnaHQnIHwgJ2NlbnRlcicgfCAnanVzdGlmeScsXG4gIGJvbGQ/OiBib29sZWFuLFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGNvbG9yPzpcbiAgICB8ICdncmVlbidcbiAgICB8ICdwaW5lJ1xuICAgIHwgJ29saXZlJ1xuICAgIHwgJ2JsdWUnXG4gICAgfCAnbmF2eSdcbiAgICB8ICdtaWRuaWdodCdcbiAgICB8ICdwdXJwbGUnXG4gICAgfCAnb3JjaGlkJ1xuICAgIHwgJ2VnZ3BsYW50J1xuICAgIHwgJ21hcm9vbidcbiAgICB8ICd3YXRlcm1lbG9uJ1xuICAgIHwgJ29yYW5nZSdcbiAgICB8ICdkYXJrR3JheSdcbiAgICB8ICdncmF5J1xuICAgIHwgJ2xpZ2h0R3JheSdcbiAgICB8ICdyZWQnXG4gICAgfCAnd2hpdGUnLFxuICBpbmxpbmU/OiBib29sZWFuLFxuICBpdGFsaWM/OiBib29sZWFuLFxuICBvdmVyZmxvdz86ICdub3JtYWwnIHwgJ2JyZWFrV29yZCcsXG4gIHNpemU/OiAneHMnIHwgJ3NtJyB8ICdtZCcgfCAnbGcnIHwgJ3hsJyxcbiAgc21TaXplPzogJ3hzJyB8ICdzbScgfCAnbWQnIHwgJ2xnJyB8ICd4bCcsXG4gIG1kU2l6ZT86ICd4cycgfCAnc20nIHwgJ21kJyB8ICdsZycgfCAneGwnLFxuICBsZ1NpemU/OiAneHMnIHwgJ3NtJyB8ICdtZCcgfCAnbGcnIHwgJ3hsJyxcbiAgbGVhZGluZz86ICd0YWxsJyB8ICdzaG9ydCcsXG4gIHRydW5jYXRlPzogYm9vbGVhbixcbiAgX19kYW5nZXJvdXNseUluY3JlYXNlTGluZUhlaWdodD86IGJvb2xlYW4sXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVGV4dCh7XG4gIGFsaWduID0gJ2xlZnQnLFxuICBib2xkID0gZmFsc2UsXG4gIGNoaWxkcmVuLFxuICBjb2xvciA9ICdkYXJrR3JheScsXG4gIGlubGluZSA9IGZhbHNlLFxuICBpdGFsaWMgPSBmYWxzZSxcbiAgb3ZlcmZsb3cgPSAnYnJlYWtXb3JkJyxcbiAgc2l6ZSA9ICdtZCcsXG4gIHNtU2l6ZSxcbiAgbWRTaXplLFxuICBsZ1NpemUsXG4gIGxlYWRpbmcgPSAnc2hvcnQnLFxuICB0cnVuY2F0ZSA9IGZhbHNlLFxuICBfX2Rhbmdlcm91c2x5SW5jcmVhc2VMaW5lSGVpZ2h0ID0gZmFsc2UsXG59OiBQcm9wcykge1xuICBjb25zdCBzY2FsZSA9IFNJWkVfU0NBTEVbc2l6ZV07XG4gIGNvbnN0IHNtU2NhbGUgPSBTSVpFX1NDQUxFW3NtU2l6ZV07XG4gIGNvbnN0IG1kU2NhbGUgPSBTSVpFX1NDQUxFW21kU2l6ZV07XG4gIGNvbnN0IGxnU2NhbGUgPSBTSVpFX1NDQUxFW2xnU2l6ZV07XG5cbiAgY29uc3QgY3MgPSBjeChcbiAgICBzdHlsZXMuVGV4dCxcbiAgICBzdHlsZXNbYGZvbnRTaXplJHtzY2FsZX1gXSxcbiAgICBsZ1NpemUgJiYgc3R5bGVzW2BsZ0ZvbnRTaXplJHtsZ1NjYWxlfWBdLFxuICAgIG1kU2l6ZSAmJiBzdHlsZXNbYG1kRm9udFNpemUke21kU2NhbGV9YF0sXG4gICAgc21TaXplICYmIHN0eWxlc1tgc21Gb250U2l6ZSR7c21TY2FsZX1gXSxcbiAgICBjb2xvciA9PT0gJ2JsdWUnICYmIGNvbG9ycy5ibHVlLFxuICAgIGNvbG9yID09PSAnZGFya0dyYXknICYmIGNvbG9ycy5kYXJrR3JheSxcbiAgICBjb2xvciA9PT0gJ2VnZ3BsYW50JyAmJiBjb2xvcnMuZWdncGxhbnQsXG4gICAgY29sb3IgPT09ICdncmF5JyAmJiBjb2xvcnMuZ3JheSxcbiAgICBjb2xvciA9PT0gJ2dyZWVuJyAmJiBjb2xvcnMuZ3JlZW4sXG4gICAgY29sb3IgPT09ICdsaWdodEdyYXknICYmIGNvbG9ycy5saWdodEdyYXksXG4gICAgY29sb3IgPT09ICdtYXJvb24nICYmIGNvbG9ycy5tYXJvb24sXG4gICAgY29sb3IgPT09ICdtaWRuaWdodCcgJiYgY29sb3JzLm1pZG5pZ2h0LFxuICAgIGNvbG9yID09PSAnbmF2eScgJiYgY29sb3JzLm5hdnksXG4gICAgY29sb3IgPT09ICdvbGl2ZScgJiYgY29sb3JzLm9saXZlLFxuICAgIGNvbG9yID09PSAnb3JhbmdlJyAmJiBjb2xvcnMub3JhbmdlLFxuICAgIGNvbG9yID09PSAnb3JjaGlkJyAmJiBjb2xvcnMub3JjaGlkLFxuICAgIGNvbG9yID09PSAncGluZScgJiYgY29sb3JzLnBpbmUsXG4gICAgY29sb3IgPT09ICdwdXJwbGUnICYmIGNvbG9ycy5wdXJwbGUsXG4gICAgY29sb3IgPT09ICdyZWQnICYmIGNvbG9ycy5yZWQsXG4gICAgY29sb3IgPT09ICd3YXRlcm1lbG9uJyAmJiBjb2xvcnMud2F0ZXJtZWxvbixcbiAgICBjb2xvciA9PT0gJ3doaXRlJyAmJiBjb2xvcnMud2hpdGUsXG4gICAgbGVhZGluZyA9PT0gJ3Nob3J0JyAmJiB0eXBvZ3JhcGh5LmxlYWRpbmdTaG9ydCxcbiAgICAobGVhZGluZyA9PT0gJ3RhbGwnIHx8IF9fZGFuZ2Vyb3VzbHlJbmNyZWFzZUxpbmVIZWlnaHQpICYmXG4gICAgICB0eXBvZ3JhcGh5LmxlYWRpbmdUYWxsLFxuICAgIGFsaWduID09PSAnY2VudGVyJyAmJiB0eXBvZ3JhcGh5LmFsaWduQ2VudGVyLFxuICAgIGFsaWduID09PSAnanVzdGlmeScgJiYgdHlwb2dyYXBoeS5hbGlnbkp1c3RpZnksXG4gICAgYWxpZ24gPT09ICdsZWZ0JyAmJiB0eXBvZ3JhcGh5LmFsaWduTGVmdCxcbiAgICBhbGlnbiA9PT0gJ3JpZ2h0JyAmJiB0eXBvZ3JhcGh5LmFsaWduUmlnaHQsXG4gICAgb3ZlcmZsb3cgPT09ICdicmVha1dvcmQnICYmIHR5cG9ncmFwaHkuYnJlYWtXb3JkLFxuICAgIGl0YWxpYyAmJiB0eXBvZ3JhcGh5LmZvbnRTdHlsZUl0YWxpYyxcbiAgICAhaXRhbGljICYmIHR5cG9ncmFwaHkuZm9udFN0eWxlTm9ybWFsLFxuICAgIGJvbGQgJiYgdHlwb2dyYXBoeS5mb250V2VpZ2h0Qm9sZCxcbiAgICAhYm9sZCAmJiB0eXBvZ3JhcGh5LmZvbnRXZWlnaHROb3JtYWwsXG4gICAgdHJ1bmNhdGUgJiYgdHlwb2dyYXBoeS50cnVuY2F0ZVxuICApO1xuICBjb25zdCBUYWcgPSBpbmxpbmUgPyAnc3BhbicgOiAnZGl2JztcblxuICByZXR1cm4gKFxuICAgIDxUYWdcbiAgICAgIGNsYXNzTmFtZT17Y3N9XG4gICAgICB7Li4uKHRydW5jYXRlICYmIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZydcbiAgICAgICAgPyB7IHRpdGxlOiBjaGlsZHJlbiB9XG4gICAgICAgIDogbnVsbCl9XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvVGFnPlxuICApO1xufVxuXG5UZXh0LnByb3BUeXBlcyA9IHtcbiAgX19kYW5nZXJvdXNseUluY3JlYXNlTGluZUhlaWdodDogUHJvcFR5cGVzLmJvb2wsXG4gIGFsaWduOiBQcm9wVHlwZXMub25lT2YoWydsZWZ0JywgJ3JpZ2h0JywgJ2NlbnRlcicsICdqdXN0aWZ5J10pLFxuICBib2xkOiBQcm9wVHlwZXMuYm9vbCxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnZ3JlZW4nLFxuICAgICdwaW5lJyxcbiAgICAnb2xpdmUnLFxuICAgICdibHVlJyxcbiAgICAnbmF2eScsXG4gICAgJ21pZG5pZ2h0JyxcbiAgICAncHVycGxlJyxcbiAgICAnb3JjaGlkJyxcbiAgICAnZWdncGxhbnQnLFxuICAgICdtYXJvb24nLFxuICAgICd3YXRlcm1lbG9uJyxcbiAgICAnb3JhbmdlJyxcbiAgICAnZGFya0dyYXknLFxuICAgICdncmF5JyxcbiAgICAnbGlnaHRHcmF5JyxcbiAgICAncmVkJyxcbiAgICAnd2hpdGUnLFxuICBdKSxcbiAgaW5saW5lOiBQcm9wVHlwZXMuYm9vbCxcbiAgaXRhbGljOiBQcm9wVHlwZXMuYm9vbCxcbiAgbGVhZGluZzogUHJvcFR5cGVzLm9uZU9mKFsndGFsbCcsICdzaG9ydCddKSxcbiAgbGdTaXplOiBQcm9wVHlwZXMub25lT2YoWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddKSxcbiAgbWRTaXplOiBQcm9wVHlwZXMub25lT2YoWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddKSxcbiAgb3ZlcmZsb3c6IFByb3BUeXBlcy5vbmVPZihbJ25vcm1hbCcsICdicmVha1dvcmQnXSksXG4gIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ10pLFxuICBzbVNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ10pLFxuICB0cnVuY2F0ZTogUHJvcFR5cGVzLmJvb2wsXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9CdXR0b24uY3NzJztcbmltcG9ydCBUZXh0IGZyb20gJy4vVGV4dC5qcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY2Nlc3NpYmlsaXR5RXhwYW5kZWQ/OiBib29sZWFuLFxuICBhY2Nlc3NpYmlsaXR5SGFzcG9wdXA/OiBib29sZWFuLFxuICBhY2Nlc3NpYmlsaXR5TGFiZWw/OiBzdHJpbmcsXG4gIGNvbG9yPzogJ2dyYXknIHwgJ3JlZCcgfCAnYmx1ZScgfCAndHJhbnNwYXJlbnQnIHwgJ3doaXRlJyxcbiAgZGlzYWJsZWQ/OiBib29sZWFuLFxuICBpbmxpbmU/OiBib29sZWFuLFxuICBuYW1lPzogc3RyaW5nLFxuICBvbkNsaWNrPzogKHsgZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8PiB9KSA9PiB2b2lkLFxuICBzaXplPzogJ3NtJyB8ICdtZCcgfCAnbGcnLFxuICB0ZXh0OiBzdHJpbmcsXG4gIHR5cGU/OiAnc3VibWl0JyB8ICdidXR0b24nLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEJ1dHRvbihwcm9wczogUHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGFjY2Vzc2liaWxpdHlFeHBhbmRlZCxcbiAgICBhY2Nlc3NpYmlsaXR5SGFzcG9wdXAsXG4gICAgYWNjZXNzaWJpbGl0eUxhYmVsLFxuICAgIGNvbG9yID0gJ2dyYXknLFxuICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgaW5saW5lID0gZmFsc2UsXG4gICAgbmFtZSxcbiAgICBvbkNsaWNrLFxuICAgIHNpemUgPSAnbWQnLFxuICAgIHRleHQsXG4gICAgdHlwZSA9ICdidXR0b24nLFxuICB9ID0gcHJvcHM7XG5cbiAgY29uc3QgdGV4dENvbG9yID0ge1xuICAgIGJsdWU6ICd3aGl0ZScsXG4gICAgZ3JheTogJ2RhcmtHcmF5JyxcbiAgICByZWQ6ICd3aGl0ZScsXG4gICAgdHJhbnNwYXJlbnQ6ICd3aGl0ZScsXG4gICAgd2hpdGU6ICdkYXJrR3JheScsXG4gIH07XG5cbiAgY29uc3QgY2xhc3NlcyA9IGNsYXNzbmFtZXMoc3R5bGVzLmJ1dHRvbiwge1xuICAgIFtzdHlsZXMuc21dOiBzaXplID09PSAnc20nLFxuICAgIFtzdHlsZXMubWRdOiBzaXplID09PSAnbWQnLFxuICAgIFtzdHlsZXMubGddOiBzaXplID09PSAnbGcnLFxuICAgIFtzdHlsZXMuc29saWRdOiBjb2xvciAhPT0gJ3RyYW5zcGFyZW50JyxcbiAgICBbc3R5bGVzW2NvbG9yXV06ICFkaXNhYmxlZCxcbiAgICBbc3R5bGVzLmRpc2FibGVkXTogZGlzYWJsZWQsXG4gICAgW3N0eWxlcy5lbmFibGVkXTogIWRpc2FibGVkLFxuICAgIFtzdHlsZXMuaW5saW5lXTogaW5saW5lLFxuICAgIFtzdHlsZXMuYmxvY2tdOiAhaW5saW5lLFxuICB9KTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9idXR0b24taGFzLXR5cGUgKi9cbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uXG4gICAgICBhcmlhLWV4cGFuZGVkPXthY2Nlc3NpYmlsaXR5RXhwYW5kZWR9XG4gICAgICBhcmlhLWhhc3BvcHVwPXthY2Nlc3NpYmlsaXR5SGFzcG9wdXB9XG4gICAgICBhcmlhLWxhYmVsPXthY2Nlc3NpYmlsaXR5TGFiZWx9XG4gICAgICBjbGFzc05hbWU9e2NsYXNzZXN9XG4gICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICBuYW1lPXtuYW1lfVxuICAgICAgb25DbGljaz17ZXZlbnQgPT4gb25DbGljayAmJiBvbkNsaWNrKHsgZXZlbnQgfSl9XG4gICAgICB0eXBlPXt0eXBlfVxuICAgID5cbiAgICAgIDxUZXh0XG4gICAgICAgIGFsaWduPVwiY2VudGVyXCJcbiAgICAgICAgYm9sZFxuICAgICAgICBjb2xvcj17ZGlzYWJsZWQgPyAnZ3JheScgOiB0ZXh0Q29sb3JbY29sb3JdfVxuICAgICAgICBvdmVyZmxvdz1cIm5vcm1hbFwiXG4gICAgICAgIHNpemU9e3NpemV9XG4gICAgICA+XG4gICAgICAgIHt0ZXh0fVxuICAgICAgPC9UZXh0PlxuICAgIDwvYnV0dG9uPlxuICApO1xuICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0L2J1dHRvbi1oYXMtdHlwZSAqL1xufVxuXG5CdXR0b24ucHJvcFR5cGVzID0ge1xuICBhY2Nlc3NpYmlsaXR5RXhwYW5kZWQ6IFByb3BUeXBlcy5ib29sLFxuICBhY2Nlc3NpYmlsaXR5SGFzcG9wdXA6IFByb3BUeXBlcy5ib29sLFxuICBhY2Nlc3NpYmlsaXR5TGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGNvbG9yOiBQcm9wVHlwZXMub25lT2YoWydibHVlJywgJ2dyYXknLCAncmVkJywgJ3RyYW5zcGFyZW50JywgJ3doaXRlJ10pLFxuICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gIGlubGluZTogUHJvcFR5cGVzLmJvb2wsXG4gIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydzbScsICdtZCcsICdsZyddKSxcbiAgdGV4dDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICB0eXBlOiBQcm9wVHlwZXMub25lT2YoWydidXR0b24nLCAnc3VibWl0J10pLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9DYXJkLmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY3RpdmU/OiA/Ym9vbGVhbixcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICBpbWFnZT86IFJlYWN0Lk5vZGUsXG4gIG9uTW91c2VFbnRlcj86ICh7IGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50PiB9KSA9PiB2b2lkLFxuICBvbk1vdXNlTGVhdmU/OiAoeyBldmVudDogU3ludGhldGljTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4gfSkgPT4gdm9pZCxcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgaG92ZXJlZDogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXJkIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGFjdGl2ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAgIGltYWdlOiBQcm9wVHlwZXMubm9kZSxcbiAgICBvbk1vdXNlRW50ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uTW91c2VMZWF2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIH07XG5cbiAgc3RhdGU6IFN0YXRlID0ge1xuICAgIGhvdmVyZWQ6IGZhbHNlLFxuICB9O1xuXG4gIGhhbmRsZU1vdXNlRW50ZXIgPSAoZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyBvbk1vdXNlRW50ZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgIHsgaG92ZXJlZDogdHJ1ZSB9LFxuICAgICAgb25Nb3VzZUVudGVyICYmICgoKSA9PiBvbk1vdXNlRW50ZXIoeyBldmVudCB9KSlcbiAgICApO1xuICB9O1xuXG4gIGhhbmRsZU1vdXNlTGVhdmUgPSAoZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyBvbk1vdXNlTGVhdmUgfSA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgIHsgaG92ZXJlZDogZmFsc2UgfSxcbiAgICAgIG9uTW91c2VMZWF2ZSAmJiAoKCkgPT4gb25Nb3VzZUxlYXZlKHsgZXZlbnQgfSkpXG4gICAgKTtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBhY3RpdmUsIGNoaWxkcmVuLCBpbWFnZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IGhvdmVyZWQgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBjb25zdCBjbGFzc2VzID0gY2xhc3NuYW1lcyhzdHlsZXMuY2FyZCwge1xuICAgICAgLy8gSWYsIGxpa2UgQGNocmlzbGxveWQsIHlvdSBjYW4ndCByZW1lbWJlciBKYXZhc2NyaXB0IGVxdWFsaXR5IHJ1bGVzLFxuICAgICAgLy8gPT0gbnVsbCBjaGVja3MgZm9yIGBudWxsYCBvciBgdW5kZWZpbmVkYCBhbmQgbGVhdmVzIG91dCBgZmFsc2VgLlxuICAgICAgW3N0eWxlcy5ob3Zlcl06IGFjdGl2ZSB8fCAoYWN0aXZlID09IG51bGwgJiYgaG92ZXJlZCksXG4gICAgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEJveFxuICAgICAgICBvbk1vdXNlRW50ZXI9e3RoaXMuaGFuZGxlTW91c2VFbnRlcn1cbiAgICAgICAgb25Nb3VzZUxlYXZlPXt0aGlzLmhhbmRsZU1vdXNlTGVhdmV9XG4gICAgICAgIHBvc2l0aW9uPVwicmVsYXRpdmVcIlxuICAgICAgPlxuICAgICAgICB7aW1hZ2UgJiYgPEJveCBtYXJnaW5Cb3R0b209ezF9PntpbWFnZX08L0JveD59XG4gICAgICAgIDxCb3g+e2NoaWxkcmVufTwvQm94PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlc30gLz5cbiAgICAgIDwvQm94PlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgY29sb3JzIGZyb20gJy4vQ29sb3JzLmNzcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vQ2hlY2tib3guY3NzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi9JY29uLmpzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoZWNrZWQ/OiBib29sZWFuLFxuICBkaXNhYmxlZD86IGJvb2xlYW4sXG4gIGhhc0Vycm9yPzogYm9vbGVhbixcbiAgaWQ6IHN0cmluZyxcbiAgaW5kZXRlcm1pbmF0ZT86IGJvb2xlYW4sXG4gIG5hbWU/OiBzdHJpbmcsXG4gIG9uQ2hhbmdlOiAoeyBldmVudDogU3ludGhldGljSW5wdXRFdmVudDw+LCBjaGVja2VkOiBib29sZWFuIH0pID0+IHZvaWQsXG4gIHNpemU/OiAnc20nIHwgJ21kJyxcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgZm9jdXNlZDogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGVja2JveCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBjaGVja2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgaGFzRXJyb3I6IFByb3BUeXBlcy5ib29sLFxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgaW5kZXRlcm1pbmF0ZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydzbScsICdtZCddKSxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGNoZWNrZWQ6IGZhbHNlLFxuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBoYXNFcnJvcjogZmFsc2UsXG4gICAgaW5kZXRlcm1pbmF0ZTogZmFsc2UsXG4gICAgc2l6ZTogJ21kJyxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBmb2N1c2VkOiBmYWxzZSxcbiAgfTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5pbmRldGVybWluYXRlKSB7XG4gICAgICB0aGlzLnNldEluZGV0ZXJtaW5hdGUoISF0aGlzLnByb3BzLmluZGV0ZXJtaW5hdGUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2aW91c1Byb3BzOiBQcm9wcykge1xuICAgIGlmIChwcmV2aW91c1Byb3BzLmluZGV0ZXJtaW5hdGUgIT09IHRoaXMucHJvcHMuaW5kZXRlcm1pbmF0ZSkge1xuICAgICAgdGhpcy5zZXRJbmRldGVybWluYXRlKCEhdGhpcy5wcm9wcy5pbmRldGVybWluYXRlKTtcbiAgICB9XG4gIH1cblxuICBzZXRJbmRldGVybWluYXRlKGluZGV0ZXJtaW5hdGU6IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5pbnB1dCkge1xuICAgICAgdGhpcy5pbnB1dC5pbmRldGVybWluYXRlID0gaW5kZXRlcm1pbmF0ZTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVDaGFuZ2UgPSAoZXZlbnQ6IFN5bnRoZXRpY0lucHV0RXZlbnQ8PikgPT4ge1xuICAgIGNvbnN0IHsgY2hlY2tlZCB9ID0gZXZlbnQudGFyZ2V0O1xuICAgIHRoaXMucHJvcHMub25DaGFuZ2UoeyBldmVudCwgY2hlY2tlZCB9KTtcbiAgfTtcblxuICBoYW5kbGVCbHVyID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWQ6IGZhbHNlIH0pO1xuXG4gIGhhbmRsZUZvY3VzID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWQ6IHRydWUgfSk7XG5cbiAgaW5wdXQ6ID9IVE1MSW5wdXRFbGVtZW50O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjaGVja2VkLFxuICAgICAgZGlzYWJsZWQsXG4gICAgICBoYXNFcnJvcixcbiAgICAgIGlkLFxuICAgICAgaW5kZXRlcm1pbmF0ZSxcbiAgICAgIG5hbWUsXG4gICAgICBzaXplLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgbGV0IGJvcmRlclN0eWxlID0gc3R5bGVzLmJvcmRlcjtcbiAgICBpZiAoIWRpc2FibGVkICYmIChjaGVja2VkIHx8IGluZGV0ZXJtaW5hdGUpKSB7XG4gICAgICBib3JkZXJTdHlsZSA9IHN0eWxlcy5ib3JkZXJEYXJrO1xuICAgIH0gZWxzZSBpZiAoaGFzRXJyb3IpIHtcbiAgICAgIGJvcmRlclN0eWxlID0gc3R5bGVzLmJvcmRlckVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8Qm94IHBvc2l0aW9uPVwicmVsYXRpdmVcIj5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cbiAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoc3R5bGVzLmlucHV0LCB7XG4gICAgICAgICAgICBbc3R5bGVzLmlucHV0RW5hYmxlZF06ICFkaXNhYmxlZCxcbiAgICAgICAgICAgIFtzdHlsZXMuaW5kZXRlcm1pbmF0ZV06IGluZGV0ZXJtaW5hdGUsXG4gICAgICAgICAgICBbc3R5bGVzLmlucHV0U21dOiBzaXplID09PSAnc20nLFxuICAgICAgICAgICAgW3N0eWxlcy5pbnB1dE1kXTogc2l6ZSA9PT0gJ21kJyxcbiAgICAgICAgICB9KX1cbiAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgaWQ9e2lkfVxuICAgICAgICAgIG5hbWU9e25hbWV9XG4gICAgICAgICAgb25CbHVyPXt0aGlzLmhhbmRsZUJsdXJ9XG4gICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlfVxuICAgICAgICAgIG9uRm9jdXM9e3RoaXMuaGFuZGxlRm9jdXN9XG4gICAgICAgICAgcmVmPXtlbCA9PiB7XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gZWw7XG4gICAgICAgICAgfX1cbiAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAvPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKFxuICAgICAgICAgICAgYm9yZGVyU3R5bGUsXG4gICAgICAgICAgICBzdHlsZXMuY2hlY2ssXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIGRpc2FibGVkXG4gICAgICAgICAgICAgID8gY2hlY2tlZCB8fCBpbmRldGVybWluYXRlXG4gICAgICAgICAgICAgICAgPyBjb2xvcnMuZ3JheUJnXG4gICAgICAgICAgICAgICAgOiBjb2xvcnMubGlnaHRHcmF5QmdcbiAgICAgICAgICAgICAgOiBjaGVja2VkIHx8IGluZGV0ZXJtaW5hdGVcbiAgICAgICAgICAgICAgICA/IGNvbG9ycy5kYXJrR3JheUJnXG4gICAgICAgICAgICAgICAgOiBjb2xvcnMud2hpdGVCZyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgW3N0eWxlcy5jaGVja0VuYWJsZWRdOiAhZGlzYWJsZWQsXG4gICAgICAgICAgICAgIFtzdHlsZXMuY2hlY2tGb2N1c2VkXTogdGhpcy5zdGF0ZS5mb2N1c2VkLFxuICAgICAgICAgICAgICBbc3R5bGVzLmNoZWNrTWRdOiBzaXplID09PSAnbWQnLFxuICAgICAgICAgICAgICBbc3R5bGVzLmNoZWNrU21dOiBzaXplID09PSAnc20nLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICl9XG4gICAgICAgID5cbiAgICAgICAgICB7KGNoZWNrZWQgfHwgaW5kZXRlcm1pbmF0ZSkgJiYgKFxuICAgICAgICAgICAgPEljb25cbiAgICAgICAgICAgICAgYWNjZXNzaWJpbGl0eUxhYmVsPVwiXCJcbiAgICAgICAgICAgICAgY29sb3I9XCJ3aGl0ZVwiXG4gICAgICAgICAgICAgIGljb249e2luZGV0ZXJtaW5hdGUgPyAnZGFzaCcgOiAnY2hlY2snfVxuICAgICAgICAgICAgICBzaXplPXtzaXplID09PSAnc20nID8gOCA6IDEyfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvQm94PlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG4vKlxuICAjIENvbGxlY3Rpb25cblxuICBDb2xsZWN0aW9uIGlzIGNvbXBvbmVudCB0aGF0IGNhbiBhYnNvbHV0ZWx5IHBvc2l0aW9uIGFuZCB2aXJ0dWFsaXplIGl0ZW1zLiBJdCdzIG1lYW50IHRvIGJlIGFuIGV4dGVyZW1seSBzaW1wbGUgd29ya2hvcnNlIHRvIHJlLWltcGxlbWVudCBjdXN0b20gbGF5b3V0cy4gSXQncyBub3QgcGVyZmVjdCBmb3IgYWxsIHNpdHVhdGlvbnMgYnV0IGl0IGRvZXMgaGF2ZSBhIGNsb3NlZCBBUEkgYW5kIGlzIHByZXR0eSBwZXJmb3JtYW50LlxuXG4gICMjIEhvdyBpdCB3b3Jrc1xuXG4gIFRoZXJlIGFyZSB0d28gY2VudHJhbCBjb25jZXB0cyB0byBDb2xsZWN0aW9uIC0gdGhlIGNvbnRlbnQgbGF5ZXIgYW5kIHRoZSB2aWV3cG9ydCBsYXllci5cblxuICBDb250ZW50IGxheWVyICAgICAgICAgICAgICAgVmlld3BvcnQgICAgICAgICAgICAgICAgICAgQ29tcG9zaXRlIGxheWVyXG5cbiAgKy0tLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLStcbiAgfCAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgIHxcbiAgfCArLS0rICstLSsgKy0tKyB8ICAgICAgICAgIHwgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgIHxcbiAgfCB8ICB8IHwgIHwgfCAgfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgIHxcbiAgfCB8ICB8IHwgIHwgfCAgfCB8ICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLSsgfCAgICAgICAgICB8ICstLS0tLS0tLS0tLS0rIHxcbiAgfCArLS0rIHwgIHwgfCAgfCB8ICAgICAgICAgIHwgfCAgICAgICAgICAgIHwgfCAgICAgICAgICB8IHwtLSsgfCAgfCB8ICB8IHxcbiAgfCAgICAgIHwgIHwgKy0tKyB8ICAgICAgICAgIHwgfCAgICAgICAgICAgIHwgfCAgICAgICAgICB8IHwgICAgfCAgfCArLS18IHxcbiAgfCArLS0rICstLSsgICAgICB8ICAgICAgICAgIHwgfCAgICAgICAgICAgIHwgfCAgICAgICAgICB8IHwtLSsgKy0tKyAgICB8IHxcbiAgfCB8ICB8ICAgICAgKy0tKyB8ICstLS0tLS0+IHwgfCAgICAgICAgICAgIHwgfCArLS0tLS0tPiB8IHwgIHwgICAgICArLS18IHxcbiAgfCArLS0rICstLSsgfCAgfCB8ICAgICAgICAgIHwgfCAgICAgICAgICAgIHwgfCAgICAgICAgICB8IHwtLSsgKy0tKyB8ICB8IHxcbiAgfCAgICAgIHwgIHwgfCAgfCB8ICAgICAgICAgIHwgfCAgICAgICAgICAgIHwgfCAgICAgICAgICB8IHwgICAgfCAgfCB8ICB8IHxcbiAgfCArLS0rIHwgIHwgKy0tKyB8ICAgICAgICAgIHwgfCAgICAgICAgICAgIHwgfCAgICAgICAgICB8IHwtLSsgfCAgfCArLS18IHxcbiAgfCB8ICB8IHwgIHwgICAgICB8ICAgICAgICAgIHwgfCAgICAgICAgICAgIHwgfCAgICAgICAgICB8IHwgIHwgfCAgfCAgICB8IHxcbiAgfCB8ICB8IHwgIHwgKy0tKyB8ICAgICAgICAgIHwgKy0tLS0tLS0tLS0tLSsgfCAgICAgICAgICB8ICstLS0tLS0tLS0tLS0rIHxcbiAgfCB8ICB8IHwgIHwgfCAgfCB8ICAgICAgICAgIHwgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgIHxcbiAgfCArLS0rICstLSsgKy0tKyB8ICAgICAgICAgIHwgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgIHxcbiAgfCAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgICAgICAgIHxcbiAgKy0tLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLStcblxuICBZb3UgcG9zaXRpb24geW91ciBpdGVtcyBpbiB0aGUgdmlydHVhbCBjb250ZW50IGxheWVyLCB0aGVuIHlvdSBkZWZpbmUgdGhlIHZpZXdwb3J0IGxheWVyIChieSBkZWZhdWx0IHRoaXMgaXMgdGhlIGZ1bGwgc2l6ZSBvZiB0aGUgY29udGVudCBsYXllcikuIENvbGxlY3Rpb24gdGhlbiB0YWtlcyB0aG9zZSBpdGVtcywgYW5kIHRoZSB2aWV3cG9ydCByZW5kZXJpbmcgdGhlIGNvbnRlbnQgbGF5ZXIgd2l0aCBvbmx5IHRoZSBpdGVtcyB0aGF0IGZpdCBpbnNpZGUgdGhlIHZpZXdwb3J0LlxuXG4gICMjIEFzc3VtcHRpb25zXG5cbiAgMS4gWW91ciBsYXlvdXQgaXMgcHJlLWNhbGN1bGF0ZWQuIENvbGxlY3Rpb24gZXhwZWN0cyBsYXlvdXQgdG8gYmUgcGFzc2VkIGluIGFzIGEgcHJvcGVydHkuIElmIHlvdXIgbGF5b3V0IGlzbid0IHJlYWR5IChpLmUuIHNvbWV0aGluZyBuZWVkcyB0byBiZSBtZWFzdXJlZCkgdGhlIGNhbGxlciBuZWVkcyB0byBmaWd1cmUgdGhhdCBvdXQuXG4gIDIuIFBhc3NlZCBpbiBJdGVtIGFyZSBzb21ld2hhdCBwdXJlIC0gdGhleSBjYW4gYmUgbW91bnRlZCBhbmQgdW5tb3VudGVkIGF0IGFueXRpbWUgc28gSXRlbSdzIGxpZmVjeWNsZSBtZXRob2RzIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhhdC5cbiAgMy4gUGFzc2VkIGluIEl0ZW1zIGFyZSBib3VuZCB0byB0aGVpciBkYXRhLXNvdXJjZSBzZXBlcmF0ZWx5LiBBbGwgdGhleSByZWNlaXZlIGlzIGFuIGluZGV4LCBzbyB0aGV5IG5lZWQgdG8gaGF2ZSBhbnkgZXh0ZXJuYWwgZGF0YSBzb3VyY2VzIGluIHNjb3BlLlxuICA0LiBUaGUgdmlld3BvcnQgY2FuIGJlIGFueSBzaXplLiBNb3N0IHdpbmRvd2luZy9yZWN5Y2xpbmcgc29sdXRpb25zIGltcGxlbWVudCBzb21lIHNvcnQgb2Ygb3ZlcnNjYW5uaW5nLCBob3dldmVyIENvbGxlY3Rpb24gbGVhdmVzIHRoaXMgdXAgdGhlIHRoZSBwYXJlbnQuXG5cbiovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGxheW91dFN0eWxlcyBmcm9tICcuL0xheW91dC5jc3MnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgSXRlbTogKHsgaWR4OiBudW1iZXIgfSkgPT4gUmVhY3QuTm9kZSxcbiAgbGF5b3V0OiBBcnJheTx7fFxuICAgIHRvcDogbnVtYmVyLFxuICAgIGxlZnQ6IG51bWJlcixcbiAgICB3aWR0aDogbnVtYmVyLFxuICAgIGhlaWdodDogbnVtYmVyLFxuICB8fT4sXG4gIHZpZXdwb3J0VG9wPzogbnVtYmVyLFxuICB2aWV3cG9ydExlZnQ/OiBudW1iZXIsXG4gIHZpZXdwb3J0V2lkdGg/OiBudW1iZXIsXG4gIHZpZXdwb3J0SGVpZ2h0PzogbnVtYmVyLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbGxlY3Rpb24gZXh0ZW5kcyBSZWFjdC5QdXJlQ29tcG9uZW50PFByb3BzLCB2b2lkPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2ZvcmJpZC1wcm9wLXR5cGVzXG4gICAgSXRlbTogUHJvcFR5cGVzLmFueSxcbiAgICBsYXlvdXQ6IFByb3BUeXBlcy5hcnJheU9mKFxuICAgICAgUHJvcFR5cGVzLmV4YWN0KHtcbiAgICAgICAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgICAgIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICAgICAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICAgICAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgICB9KS5pc1JlcXVpcmVkXG4gICAgKSxcbiAgICB2aWV3cG9ydEhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcbiAgICB2aWV3cG9ydExlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgdmlld3BvcnRUb3A6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgdmlld3BvcnRXaWR0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGxheW91dDogW10sXG4gICAgdmlld3BvcnRMZWZ0OiAwLFxuICAgIHZpZXdwb3J0VG9wOiAwLFxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IEl0ZW0sIGxheW91dCwgdmlld3BvcnRUb3AgPSAwLCB2aWV3cG9ydExlZnQgPSAwIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBmdWxsIGRpbWVuc2lvbnMgb2YgdGhlIGl0ZW0gbGF5ZXJcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgubWF4KC4uLmxheW91dC5tYXAoaXRlbSA9PiBpdGVtLmxlZnQgKyBpdGVtLndpZHRoKSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgoLi4ubGF5b3V0Lm1hcChpdGVtID0+IGl0ZW0udG9wICsgaXRlbS5oZWlnaHQpKTtcblxuICAgIC8vIERlZmF1bHQgdGhlIHZpZXdwb3J0IHRvIGJlaW5nIHRoZSBmdWxsIHdpZHRoIG9mIHRoZSBjb250ZW50IGxheWVyXG4gICAgY29uc3QgeyB2aWV3cG9ydFdpZHRoID0gd2lkdGgsIHZpZXdwb3J0SGVpZ2h0ID0gaGVpZ2h0IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gQ2FsY3VsYXRlcyB3aGljaCBpdGVtcyBmcm9tIHRoZSBpdGVtIGxheWVyIHRvIHJlbmRlciBpbiB0aGUgdmlld3BvcnRcbiAgICAvLyBsYXllci5cbiAgICBjb25zdCBpdGVtcyA9IGxheW91dC5yZWR1Y2UoKGFjYywgcG9zaXRpb24sIGlkeCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBwb3NpdGlvbi50b3AgKyBwb3NpdGlvbi5oZWlnaHQgPiB2aWV3cG9ydFRvcCAmJlxuICAgICAgICBwb3NpdGlvbi50b3AgPCB2aWV3cG9ydEhlaWdodCArIHZpZXdwb3J0VG9wICYmXG4gICAgICAgIHBvc2l0aW9uLmxlZnQgPCB2aWV3cG9ydFdpZHRoICsgdmlld3BvcnRMZWZ0ICYmXG4gICAgICAgIHBvc2l0aW9uLmxlZnQgKyBwb3NpdGlvbi53aWR0aCA+IHZpZXdwb3J0TGVmdFxuICAgICAgKSB7XG4gICAgICAgIGFjYy5wdXNoKHsgaWR4LCAuLi5wb3NpdGlvbiB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtsYXlvdXRTdHlsZXMucmVsYXRpdmV9IHN0eWxlPXt7IHdpZHRoLCBoZWlnaHQgfX0+XG4gICAgICAgIHtpdGVtcy5tYXAoKHsgaWR4LCAuLi5zdHlsZSB9KSA9PiAoXG4gICAgICAgICAgPGRpdiBrZXk9e2lkeH0gY2xhc3NOYW1lPXtsYXlvdXRTdHlsZXMuYWJzb2x1dGV9IHN0eWxlPXtzdHlsZX0+XG4gICAgICAgICAgICA8SXRlbSBpZHg9e2lkeH0gLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBDb2xsZWN0aW9uIGZyb20gJy4vQ29sbGVjdGlvbi5qcyc7XG5cbnR5cGUgQ29sdW1uID0gMiB8IDMgfCA0O1xuXG4vKlxuXG5UaGlzIGZ1bmN0aW9uIGp1c3QgaW1wbGVtZW50cyB0aGUgZGVzaWduIGNvbnN0cmFpbnRzIGZvciBhc3ltZXRyaWNhbCBjb2x1bW5zIGluXG5hIHZlcnkgc2ltcGxlIHdheS4gSXQncyBub3QgcGVyZmVjdCwgYnV0IGl0J3MgdmVyeSBwcmVkaWN0aWJsZS4gSWYgeW91IGRvXG5hbnl0aGluZywgaW1wcm92ZSBpdCBzbyB0aGF0IGl0IHRha2VzIHRoZXNlIGNvbnN0cmFpbnRzIGFuZCBnZW5lcmF0ZXMgdGhlbVxuZm9yIG4gPiA0LlxuXG4xICsgbiBjb2x1bW5zOlxuICBmaXJzdCBjb2x1bW4gaXMgNTAvNTBcbiAgY2FuJ3QgaGF2ZSAzIGNvbHVtbnMgaW4gYSByb3cgYmUgNTAvNTBcblxuKi9cbmNvbnN0IFVQID0gWzAuNzUsIDAuMjVdO1xuY29uc3QgRE9XTiA9IFswLjI1LCAwLjc1XTtcbmNvbnN0IE1JRCA9IFswLjUsIDAuNV07XG5jb25zdCBjb2x1bW5MYXlvdXQgPSAobnVtT2ZDb2x1bW5zOiAxIHwgQ29sdW1uKSA9PiB7XG4gIHN3aXRjaCAobnVtT2ZDb2x1bW5zKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIFtbTUlEXSwgW1VQXSwgW0RPV05dXTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gW1tVUCwgTUlEXSwgW0RPV04sIE1JRF0sIFtNSUQsIFVQXSwgW01JRCwgRE9XTl1dO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFtNSUQsIFVQLCBNSUQsIE1JRF0sXG4gICAgICAgIFtNSUQsIERPV04sIE1JRCwgTUlEXSxcbiAgICAgICAgW01JRCwgTUlELCBVUCwgTUlEXSxcbiAgICAgICAgW01JRCwgTUlELCBET1dOLCBNSURdLFxuICAgICAgICBbTUlELCBVUCwgTUlELCBET1dOXSxcbiAgICAgICAgW01JRCwgRE9XTiwgTUlELCBVUF0sXG4gICAgICBdO1xuICAgIGNhc2UgMzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgW01JRCwgVVAsIE1JRF0sXG4gICAgICAgIFtNSUQsIERPV04sIE1JRF0sXG4gICAgICAgIFtNSUQsIE1JRCwgVVBdLFxuICAgICAgICBbTUlELCBNSUQsIERPV05dLFxuICAgICAgXTtcbiAgfVxufTtcblxuY29uc3QgcGFkZGluZ0FsbCA9IChndXR0ZXIsIHBvc2l0aW9ucykgPT5cbiAgcG9zaXRpb25zLm1hcCgoeyB0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQgfSkgPT4gKHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICB3aWR0aDogd2lkdGggLSBndXR0ZXIsXG4gICAgaGVpZ2h0OiBoZWlnaHQgLSBndXR0ZXIsXG4gIH0pKTtcblxuY29uc3QgbWluZGV4ID0gYXJyID0+XG4gIGFyci5yZWR1Y2UoKG1pbkluZGV4LCBpdGVtLCBpKSA9PiAoaXRlbSA8IGFyclttaW5JbmRleF0gPyBpIDogbWluSW5kZXgpLCAwKTtcblxuY29uc3QgY29sdW1uc0ZvckNvbGxhZ2VXaXRoQ292ZXIgPSAobnVtT2ZDb2x1bW5zOiBDb2x1bW4pID0+XG4gIG51bU9mQ29sdW1ucyA9PT0gNCA/IDIgOiAxO1xuXG5mdW5jdGlvbiBnZXRDb2xsYWdlTGF5b3V0KHtcbiAgZ3V0dGVyLFxuICBjb3ZlcixcbiAgY29sdW1uczogbnVtQ29scyxcbiAgaGVpZ2h0OiBoLFxuICB3aWR0aDogdyxcbiAgbGF5b3V0S2V5LFxufToge1xuICBndXR0ZXI6IG51bWJlcixcbiAgY292ZXI6IGJvb2xlYW4sXG4gIGNvbHVtbnM6IENvbHVtbixcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIHdpZHRoOiBudW1iZXIsXG4gIGxheW91dEtleTogbnVtYmVyLFxufSkge1xuICBsZXQgcG9zaXRpb25zID0gW107XG4gIGNvbnN0IHdpZHRoID0gdyArIGd1dHRlcjtcbiAgY29uc3QgaGVpZ2h0ID0gaCArIGd1dHRlcjtcblxuICAvLyBJZiB0aGVyZSdzIGEgY292ZXIgaW1hZ2UsIHdlJ2xsIGFkZCB0aGF0IGxhdGVyLiBJdCBzaG91bGQgYmUgYSBsaXR0bGVcbiAgLy8gbGVzcyB0aGFuIGhhbGYgdGhlIHdpZHRoIG9mIHRoZSBjb2xsYWdlLiBXZSBkbyB0aGlzIG5vdyAoYW5kIG5vdCBsYXRlclxuICAvLyB3aGVuIHdlIGFkZCB0aGUgY292ZXIgaW1hZ2UpIGJlY2F1c2Ugb2YgYGNvbHVtbkxheW91dGAncyBjb25zdHJhaW50c1xuICAvLyBuZWVkaW5nIHRoZSBleGFjdCBudW1iZXIgb2YgY29sdW1ucyB0aGF0IGFyZSBkaXNwbGF5ZWQuXG4gIGNvbnN0IGdyaWRDb2xzID0gY292ZXIgPyBjb2x1bW5zRm9yQ29sbGFnZVdpdGhDb3ZlcihudW1Db2xzKSA6IG51bUNvbHM7XG5cbiAgLy8gU2VsZWN0cyB0aGUgbGF5b3V0IHRoYXQgd2UncmUgZ29pbmcgdG8gdXNlIGZvciB0aGUgZ3JpZFxuICBjb25zdCBjb2x1bW5zID0gY29sdW1uTGF5b3V0KGdyaWRDb2xzKTtcbiAgY29uc3QgbGF5b3V0SWR4ID0gbGF5b3V0S2V5ICUgY29sdW1ucy5sZW5ndGg7XG4gIGNvbnN0IGxheW91dCA9IGNvbHVtbnNbbGF5b3V0SWR4XTtcblxuICAvLyBUaGlzIGRvZXMgYSByZWFsbHkgc2ltcGxlIHZlcnNpb24gb2Ygb3VyIG1hc29ucnkgbGF5b3V0LiBXaHkgcmVwbGljYXRlXG4gIC8vIHRoYXQgaGVyZT8gYS4pIGZld2VyIGRlcGVuZGVuY2llcyBhbmQgYi4pIHdlIG5lZWQgdGhlIGFsZ29yaXRobSB0b1xuICAvLyByb3VnaGx5IHByZXNlcnZlIHRoZSBvcmRlciBvZiB0aGUgY29sbGFnZXMgZnJvbSB3aGVuIHRoZXkgd2VyZSBvcmRlcmVkXG4gIC8vIGJ5IE1hc29ucnkuXG4gIGNvbnN0IGNvbEhlaWdodHMgPSBuZXcgQXJyYXkoZ3JpZENvbHMpLmZpbGwoMCk7XG4gIGNvbnN0IGNvbENvdW50cyA9IG5ldyBBcnJheShncmlkQ29scykuZmlsbCgwKTtcblxuICAvLyBXZSBpdGVyYXRlIG92ZXIgZXZlcnkgcG9zaXRpb24gdGhhdCB3ZSB0aGluayB3ZSBjb3VsZCBfcG90ZW50aWFsbHlfIGhhdmVcbiAgLy8gc28gdGhhdCB3ZSBjYW4gZmlsbCB0aGVtIHdpdGggZW1wdHkgc2VjdGlvbnMgaWYgbmVlZCBiZS5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAyICogZ3JpZENvbHM7IGkgKz0gMSkge1xuICAgIGNvbnN0IGNvbCA9IG1pbmRleChjb2xIZWlnaHRzKTtcbiAgICBjb25zdCBjb2xJZHggPSBjb2xDb3VudHNbY29sXTtcbiAgICBjb25zdCBpdGVtSGVpZ2h0ID0gbGF5b3V0W2NvbF1bY29sSWR4XSAqIGhlaWdodDtcblxuICAgIHBvc2l0aW9ucy5wdXNoKHtcbiAgICAgIHRvcDogY29sSGVpZ2h0c1tjb2xdLFxuICAgICAgbGVmdDogY29sICogKHdpZHRoIC8gbnVtQ29scyksXG4gICAgICB3aWR0aDogd2lkdGggLyBudW1Db2xzLFxuICAgICAgaGVpZ2h0OiBpdGVtSGVpZ2h0LFxuICAgIH0pO1xuXG4gICAgY29sSGVpZ2h0c1tjb2xdICs9IGl0ZW1IZWlnaHQ7XG4gICAgY29sQ291bnRzW2NvbF0gKz0gMTtcbiAgfVxuXG4gIC8vIElmIHdlIGhhdmUgYSBjb3ZlciBpbWFnZSwgZmlndXJlIG91dCBob3cgYmlnIGl0IGlzLCB0aGVuIG1vdmUgYWxsIHRoZVxuICAvLyBleGlzdGluZyBjb2x1bW5zIG92ZXIuXG4gIGlmIChjb3Zlcikge1xuICAgIGNvbnN0IGNvdmVySW1hZ2VXaWR0aCA9IE1hdGguY2VpbChudW1Db2xzIC8gMikgKiAod2lkdGggLyBudW1Db2xzKTtcbiAgICBwb3NpdGlvbnMgPSBwb3NpdGlvbnMubWFwKHBvc2l0aW9uID0+ICh7XG4gICAgICAuLi5wb3NpdGlvbixcbiAgICAgIGxlZnQ6IGNvdmVySW1hZ2VXaWR0aCArIHBvc2l0aW9uLmxlZnQsXG4gICAgfSkpO1xuICAgIHBvc2l0aW9ucy51bnNoaWZ0KHsgdG9wOiAwLCBsZWZ0OiAwLCB3aWR0aDogY292ZXJJbWFnZVdpZHRoLCBoZWlnaHQgfSk7XG4gIH1cblxuICAvLyBUaGlzIGFkZHMgdGhlIHNwYWNlIGJldHdlZW4gYW55IGl0ZW1zIHRoYXQgd2UgaGF2ZS4gSXQncyBuaWNlIHRvIGRvXG4gIC8vIHRoaXMgYXMgYSBzZXBhcmF0ZSBwYXNzIGFmdGVyIGV2ZXJ5dGhpbmcgZWxzZSwgYmVjYXVzZSB0aGUgbWF0aCBlYXJsaWVyXG4gIC8vIGJlY29tZXMgZWFzaWVyIGFuZCBpdCdzIGxlc3MgYnJpdHRsZSB0byBjaGFuZ2UuXG4gIGlmIChndXR0ZXIpIHtcbiAgICBwb3NpdGlvbnMgPSBwYWRkaW5nQWxsKGd1dHRlciwgcG9zaXRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBwb3NpdGlvbnM7XG59XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjb2x1bW5zOiBDb2x1bW4sXG4gIGNvdmVyPzogYm9vbGVhbixcbiAgZ3V0dGVyPzogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgbGF5b3V0S2V5PzogbnVtYmVyLFxuICByZW5kZXJJbWFnZTogKHt8XG4gICAgd2lkdGg6IG51bWJlcixcbiAgICBoZWlnaHQ6IG51bWJlcixcbiAgICBpbmRleDogbnVtYmVyLFxuICB8fSkgPT4gUmVhY3QuTm9kZSxcbiAgd2lkdGg6IG51bWJlcixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb2xsYWdlKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7XG4gICAgY29sdW1ucyxcbiAgICBjb3ZlcixcbiAgICBndXR0ZXIsXG4gICAgaGVpZ2h0LFxuICAgIGxheW91dEtleSxcbiAgICByZW5kZXJJbWFnZSxcbiAgICB3aWR0aCxcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwb3NpdGlvbnMgPSBnZXRDb2xsYWdlTGF5b3V0KHtcbiAgICBjb2x1bW5zLFxuICAgIGNvdmVyOiAhIWNvdmVyLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBndXR0ZXI6IGd1dHRlciB8fCAwLFxuICAgIGxheW91dEtleTogbGF5b3V0S2V5IHx8IDAsXG4gIH0pO1xuICByZXR1cm4gKFxuICAgIDxDb2xsZWN0aW9uXG4gICAgICBJdGVtPXsoeyBpZHg6IGluZGV4IH0pID0+XG4gICAgICAgIHJlbmRlckltYWdlKHtcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICB3aWR0aDogcG9zaXRpb25zW2luZGV4XS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHBvc2l0aW9uc1tpbmRleF0uaGVpZ2h0LFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgbGF5b3V0PXtwb3NpdGlvbnN9XG4gICAgLz5cbiAgKTtcbn1cblxuQ29sbGFnZS5wcm9wVHlwZXMgPSB7XG4gIGNvbHVtbnM6IFByb3BUeXBlcy5vbmVPZihbMiwgMywgNF0pLmlzUmVxdWlyZWQsXG4gIGNvdmVyOiBQcm9wVHlwZXMuYm9vbCxcbiAgZ3V0dGVyOiBQcm9wVHlwZXMubnVtYmVyLFxuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgbGF5b3V0S2V5OiBQcm9wVHlwZXMubnVtYmVyLFxuICByZW5kZXJJbWFnZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbn07XG4iLCIvKiBAZmxvdyAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0NvbHVtbkNvbHVtbi5jc3MnO1xuXG50eXBlIERlcHJlY2F0ZWRDb2x1bW5zID0gMSB8IDIgfCAzIHwgNCB8IDUgfCA2IHwgNyB8IDggfCA5IHwgMTAgfCAxMSB8IDEyO1xudHlwZSBDb2x1bW5zID0gMCB8IDEgfCAyIHwgMyB8IDQgfCA1IHwgNiB8IDcgfCA4IHwgOSB8IDEwIHwgMTEgfCAxMjtcblxudHlwZSBDb2x1bW5Qcm9wcyA9XG4gIHwge3xcbiAgICAgIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgICAgIHNwYW46IENvbHVtbnMsXG4gICAgICBzbVNwYW4/OiBDb2x1bW5zLFxuICAgICAgbWRTcGFuPzogQ29sdW1ucyxcbiAgICAgIGxnU3Bhbj86IENvbHVtbnMsXG4gICAgfH1cbiAgfCB7fFxuICAgICAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICAgICAgeHM/OiBEZXByZWNhdGVkQ29sdW1ucyxcbiAgICAgIHNtPzogRGVwcmVjYXRlZENvbHVtbnMsXG4gICAgICBtZD86IERlcHJlY2F0ZWRDb2x1bW5zLFxuICAgICAgbGc/OiBEZXByZWNhdGVkQ29sdW1ucyxcbiAgICB8fTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29sdW1uKHByb3BzOiBDb2x1bW5Qcm9wcykge1xuICBjb25zdCB7IGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgY29uc3QgY3MgPSBjbGFzc25hbWVzKFxuICAgIChwcm9wcy54cyAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICBwcm9wcy5zbSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICBwcm9wcy5tZCAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICBwcm9wcy5sZyAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgc3R5bGVzLmRlcHJlY2F0ZWRDb2x1bW4sXG4gICAgcHJvcHMueHMgJiYgc3R5bGVzW2B4c0NvbCR7cHJvcHMueHN9YF0sXG4gICAgcHJvcHMuc20gJiYgc3R5bGVzW2BzbUNvbCR7cHJvcHMuc219YF0sXG4gICAgcHJvcHMubWQgJiYgc3R5bGVzW2BtZENvbCR7cHJvcHMubWR9YF0sXG4gICAgcHJvcHMubGcgJiYgc3R5bGVzW2BsZ0NvbCR7cHJvcHMubGd9YF0sXG4gICAgcHJvcHMuc3BhbiAhPSBudWxsICYmIHN0eWxlc1tgeHNDb2wke3Byb3BzLnNwYW59YF0sXG4gICAgcHJvcHMuc21TcGFuICE9IG51bGwgJiYgc3R5bGVzW2BzbUNvbCR7cHJvcHMuc21TcGFufWBdLFxuICAgIHByb3BzLm1kU3BhbiAhPSBudWxsICYmIHN0eWxlc1tgbWRDb2wke3Byb3BzLm1kU3Bhbn1gXSxcbiAgICBwcm9wcy5sZ1NwYW4gIT0gbnVsbCAmJiBzdHlsZXNbYGxnQ29sJHtwcm9wcy5sZ1NwYW59YF1cbiAgKTtcbiAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPXtjc30+e2NoaWxkcmVufTwvZGl2Pjtcbn1cblxuQ29sdW1uLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICB4czogUHJvcFR5cGVzLm51bWJlcixcbiAgc206IFByb3BUeXBlcy5udW1iZXIsXG4gIG1kOiBQcm9wVHlwZXMubnVtYmVyLFxuICBsZzogUHJvcFR5cGVzLm51bWJlcixcbiAgc3BhbjogUHJvcFR5cGVzLm51bWJlcixcbiAgc21TcGFuOiBQcm9wVHlwZXMubnVtYmVyLFxuICBtZFNwYW46IFByb3BUeXBlcy5udW1iZXIsXG4gIGxnU3BhbjogUHJvcFR5cGVzLm51bWJlcixcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvbnRhaW5lcihwcm9wczogUHJvcHMpIHtcbiAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPEJveCBqdXN0aWZ5Q29udGVudD1cImNlbnRlclwiIGRpc3BsYXk9XCJmbGV4XCI+XG4gICAgICA8Qm94IG1heFdpZHRoPXs4MDB9IHdpZHRoPVwiMTAwJVwiPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L0JveD5cbiAgICA8L0JveD5cbiAgKTtcbn1cblxuQ29udGFpbmVyLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vRGl2aWRlci5jc3MnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBEaXZpZGVyKCkge1xuICByZXR1cm4gPGhyIGNsYXNzTmFtZT17c3R5bGVzLmRpdmlkZXJ9IC8+O1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIGRpcmVjdGlvbj86ID8ndXAnIHwgJ3JpZ2h0JyB8ICdkb3duJyB8ICdsZWZ0Jyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENhcmV0KHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7IGRpcmVjdGlvbiB9ID0gcHJvcHM7XG4gIGxldCBwYXRoO1xuICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgJ3VwJzpcbiAgICAgIHBhdGggPSAnTTAgMCBMMTIgMTIgTDI0IDAnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgcGF0aCA9ICdNMjQgMCBMMTIgMTIgTDI0IDI0JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgcGF0aCA9ICdNMCAyNCBMMTIgMTIgTDI0IDI0JztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgcGF0aCA9ICdNMCAwIEwxMiAxMiBMMCAyNCc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8c3ZnIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiPlxuICAgICAgPHBhdGggZD17cGF0aH0gLz5cbiAgICA8L3N2Zz5cbiAgKTtcbn1cblxuQ2FyZXQucHJvcFR5cGVzID0ge1xuICBkaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ3VwJywgJ3JpZ2h0JywgJ2Rvd24nLCAnbGVmdCddKSxcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IENhcmV0IGZyb20gJy4vQ2FyZXQuanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0NvbnRlbnRzLmNzcyc7XG5pbXBvcnQgY29sb3JzIGZyb20gJy4vQ29sb3JzLmNzcyc7XG5cbi8qIE5lZWRlZCB1bnRpbCB0aGlzIEZsb3cgaXNzdWUgaXMgZml4ZWQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8zODAgKi9cbi8qIGVzbGludCBxdW90ZS1wcm9wczogMCAqL1xuY29uc3QgU1BBQ0VTX0lOREVYX01BUCA9IHtcbiAgJzAnOiAndXAnLFxuICAnMSc6ICdyaWdodCcsXG4gICcyJzogJ2Rvd24nLFxuICAnMyc6ICdsZWZ0Jyxcbn07XG5cbmNvbnN0IERJUl9JTkRFWF9NQVAgPSB7XG4gIHVwOiAwLFxuICByaWdodDogMSxcbiAgZG93bjogMixcbiAgbGVmdDogMyxcbn07XG5cbmNvbnN0IE1BUkdJTiA9IDI0O1xuZXhwb3J0IGNvbnN0IENBUkVUX0hFSUdIVCA9IDI0O1xuY29uc3QgQ0FSRVRfT0ZGU0VUX0ZST01fU0lERSA9IDI0O1xuZXhwb3J0IGNvbnN0IEJPUkRFUl9SQURJVVMgPSA4O1xuXG50eXBlIE1haW5EaXIgPSA/KCd1cCcgfCAncmlnaHQnIHwgJ2Rvd24nIHwgJ2xlZnQnKTtcbnR5cGUgU3ViRGlyID0gJ3VwJyB8ICdyaWdodCcgfCAnZG93bicgfCAnbGVmdCcgfCAnbWlkZGxlJztcblxudHlwZSBDbGllbnRSZWN0ID0ge1xuICBib3R0b206IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIGxlZnQ6IG51bWJlcixcbiAgcmlnaHQ6IG51bWJlcixcbiAgdG9wOiBudW1iZXIsXG4gIHdpZHRoOiBudW1iZXIsXG59O1xuXG50eXBlIFdpbmRvdyA9IHtcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIHdpZHRoOiBudW1iZXIsXG4gIHNjcm9sbFk6IG51bWJlcixcbiAgc2Nyb2xsWDogbnVtYmVyLFxufTtcblxudHlwZSBGbHlvdXQgPSB7IGhlaWdodDogbnVtYmVyLCB3aWR0aDogbnVtYmVyIH07XG5cbnR5cGUgU2hpZnQgPSB7IHg6IG51bWJlciwgeTogbnVtYmVyIH07XG5cbnR5cGUgRWRnZVNoaWZ0ID0geyBjYXJldDogU2hpZnQsIGZseW91dDogU2hpZnQgfTtcblxudHlwZSBQcm9wcyA9IHt8XG4gIGJnQ29sb3I6ICdibHVlJyB8ICdkYXJrR3JheScgfCAnb3JhbmdlJyB8ICd3aGl0ZScsXG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgaWRlYWxEaXJlY3Rpb24/OiAndXAnIHwgJ3JpZ2h0JyB8ICdkb3duJyB8ICdsZWZ0JyxcbiAgb25LZXlEb3duOiAoZXZlbnQ6IHsga2V5Q29kZTogbnVtYmVyIH0pID0+IHZvaWQsXG4gIG9uUmVzaXplOiAoKSA9PiB2b2lkLFxuICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3I/OiBib29sZWFuLFxuICByZWxhdGl2ZU9mZnNldDoge1xuICAgIHg6IG51bWJlcixcbiAgICB5OiBudW1iZXIsXG4gIH0sXG4gIHNob3VsZEZvY3VzPzogYm9vbGVhbixcbiAgdHJpZ2dlclJlY3Q6IENsaWVudFJlY3QsXG4gIHdpZHRoOiBudW1iZXIsXG58fTtcblxudHlwZSBTdGF0ZSA9IHtcbiAgZmx5b3V0T2Zmc2V0OiB7XG4gICAgdG9wOiA/bnVtYmVyLFxuICAgIGxlZnQ6ID9udW1iZXIsXG4gIH0sXG4gIGNhcmV0T2Zmc2V0OiB7XG4gICAgdG9wOiA/bnVtYmVyLFxuICAgIHJpZ2h0OiA/bnVtYmVyLFxuICAgIGJvdHRvbTogP251bWJlcixcbiAgICBsZWZ0OiA/bnVtYmVyLFxuICB9LFxuICBtYWluRGlyOiA/TWFpbkRpcixcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbWFpbiBkaXJlY3Rpb24gdGhlIGZseW91dCBvcGVuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWFpbkRpcihcbiAgZmx5b3V0U2l6ZTogRmx5b3V0LFxuICBpZGVhbERpcmVjdGlvbjogTWFpbkRpcixcbiAgdHJpZ2dlclJlY3Q6IENsaWVudFJlY3QsXG4gIHdpbmRvd1NpemU6IFdpbmRvd1xuKSB7XG4gIC8vIENhbGN1bGF0ZXMgdGhlIGF2YWlsYWJsZSBzcGFjZSBpZiB3ZSB3ZXJlIHRvIHBsYWNlIHRoZSBmbHlvdXQgaW4gdGhlIDQgbWFpbiBkaXJlY3Rpb25zXG4gIC8vIHRvIGRldGVybWluZSB3aGljaCAncXVhZHJhbnQnIHRvIHBvc2l0aW9uIHRoZSBmbHlvdXQgaW5zaWRlIG9mXG4gIGxldCB1cCA9IHRyaWdnZXJSZWN0LnRvcCAtIGZseW91dFNpemUuaGVpZ2h0IC0gQ0FSRVRfSEVJR0hUO1xuICBsZXQgcmlnaHQgPVxuICAgIHdpbmRvd1NpemUud2lkdGggLSBmbHlvdXRTaXplLndpZHRoIC0gQ0FSRVRfSEVJR0hUIC0gdHJpZ2dlclJlY3QucmlnaHQ7XG4gIGxldCBkb3duID1cbiAgICB3aW5kb3dTaXplLmhlaWdodCAtIGZseW91dFNpemUuaGVpZ2h0IC0gQ0FSRVRfSEVJR0hUIC0gdHJpZ2dlclJlY3QuYm90dG9tO1xuICBsZXQgbGVmdCA9IHRyaWdnZXJSZWN0LmxlZnQgLSBmbHlvdXRTaXplLndpZHRoIC0gQ0FSRVRfSEVJR0hUO1xuXG4gIC8vIG92ZXJyaWRlcyBhdmFpbGFibGUgc3BhY2Ugd2hlbiB0aGUgdHJpZ2dlciBpcyBjbG9zZSB0byB0aGUgZWRnZSBvZiB0aGUgc2NyZWVuXG4gIC8vIHRyaWdnZXIgaXMgdG9vIGNsb3NlIHRvIHRvcC9ib3R0b20gb2Ygc2NyZWVuIGZvciBsZWZ0ICYgcmlnaHQgZmx5b3V0c1xuICBpZiAoXG4gICAgdHJpZ2dlclJlY3QudG9wIDwgQk9SREVSX1JBRElVUyB8fFxuICAgIHdpbmRvd1NpemUuaGVpZ2h0IC0gdHJpZ2dlclJlY3QuYm90dG9tIDwgQk9SREVSX1JBRElVU1xuICApIHtcbiAgICBsZWZ0ID0gMDtcbiAgICByaWdodCA9IDA7XG4gIH1cblxuICAvLyB0cmlnZ2VyIGlzIHRvbyBjbG9zZSB0byB0aGUgbGVmdC9yaWdodCBvZiBzY3JlZW4gZm9yIHVwICYgZG93biBmbHlvdXRzXG4gIGlmIChcbiAgICB0cmlnZ2VyUmVjdC5sZWZ0IDwgQk9SREVSX1JBRElVUyB8fFxuICAgIHdpbmRvd1NpemUud2lkdGggLSB0cmlnZ2VyUmVjdC5yaWdodCA8IEJPUkRFUl9SQURJVVNcbiAgKSB7XG4gICAgdXAgPSAwO1xuICAgIGRvd24gPSAwO1xuICB9XG5cbiAgY29uc3Qgc3BhY2VzID0gW3VwLCByaWdodCwgZG93biwgbGVmdF07XG5cbiAgLy8gSWRlbnRpZnkgYmVzdCBkaXJlY3Rpb24gb2YgYXZhaWxhYmxlIHNwYWNlc1xuICBjb25zdCBtYXggPSBNYXRoLm1heCguLi5zcGFjZXMpO1xuXG4gIC8vIENob3NlIHRoZSBtYWluIGRpcmVjdGlvbiBmb3IgdGhlIGZseW91dCBiYXNlZCBvbiBhdmFpbGFibGUgc3BhY2VzICYgdXNlciBwcmVmZXJlbmNlXG4gIGxldCBtYWluRGlyO1xuICBpZiAoaWRlYWxEaXJlY3Rpb24gJiYgc3BhY2VzW0RJUl9JTkRFWF9NQVBbaWRlYWxEaXJlY3Rpb25dXSA+IDApIHtcbiAgICAvLyB1c2VyIHByZWZcbiAgICBtYWluRGlyID0gaWRlYWxEaXJlY3Rpb247XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgbm8gZGlyZWN0aW9uIHByZWYsIGNob3NlIHRoZSBkaXJlY3Rpb24gaW4gd2hpY2ggdGhlcmUgaXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlXG4gICAgbWFpbkRpciA9IFNQQUNFU19JTkRFWF9NQVBbc3BhY2VzLmluZGV4T2YobWF4KV07XG4gIH1cbiAgcmV0dXJuIG1haW5EaXI7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgc3ViIGRpcmVjdGlvbiBvZiBob3cgdGhlIGZseW91dCBpcyBwb3NpdGlvbmVkIHdpdGhpbiB0aGUgbWFpbiBkaXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN1YkRpcihcbiAgZmx5b3V0U2l6ZTogRmx5b3V0LFxuICBtYWluRGlyOiBNYWluRGlyLFxuICB0cmlnZ2VyUmVjdDogQ2xpZW50UmVjdCxcbiAgd2luZG93U2l6ZTogV2luZG93XG4pIHtcbiAgLy8gTm93IHRoYXQgd2UgaGF2ZSB0aGUgbWFpbiBkaXJlY3Rpb24sIGNob3NlIGZyb20gMyBjYXJldCBwbGFjZW1lbnRzIGZvciB0aGF0IGRpcmVjdGlvblxuICBsZXQgb2Zmc2V0O1xuICBsZXQgdHJpZ2dlck1pZDtcbiAgbGV0IHdpbmRvd1NwYWNlQXZhaWxhYmxlO1xuXG4gIGlmIChtYWluRGlyID09PSAncmlnaHQnIHx8IG1haW5EaXIgPT09ICdsZWZ0Jykge1xuICAgIG9mZnNldCA9IGZseW91dFNpemUuaGVpZ2h0IC8gMjtcbiAgICB0cmlnZ2VyTWlkID0gdHJpZ2dlclJlY3QudG9wICsgKHRyaWdnZXJSZWN0LmJvdHRvbSAtIHRyaWdnZXJSZWN0LnRvcCkgLyAyO1xuICAgIHdpbmRvd1NwYWNlQXZhaWxhYmxlID0gd2luZG93U2l6ZS5oZWlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gKG1haW5EaXIgPT09ICd1cCcgfHwgbWFpbkRpciA9PT0gJ2Rvd24nKVxuICAgIG9mZnNldCA9IGZseW91dFNpemUud2lkdGggLyAyO1xuICAgIHRyaWdnZXJNaWQgPSB0cmlnZ2VyUmVjdC5sZWZ0ICsgKHRyaWdnZXJSZWN0LnJpZ2h0IC0gdHJpZ2dlclJlY3QubGVmdCkgLyAyO1xuICAgIHdpbmRvd1NwYWNlQXZhaWxhYmxlID0gd2luZG93U2l6ZS53aWR0aDtcbiAgfVxuXG4gIGNvbnN0IGFib3ZlT3JMZWZ0ID0gdHJpZ2dlck1pZCAtIG9mZnNldCAtIE1BUkdJTjtcbiAgY29uc3QgYmVsb3dPclJpZ2h0ID0gd2luZG93U3BhY2VBdmFpbGFibGUgLSB0cmlnZ2VyTWlkIC0gb2Zmc2V0IC0gTUFSR0lOO1xuICBsZXQgc3ViRGlyO1xuICBpZiAoYWJvdmVPckxlZnQgPiAwICYmIGJlbG93T3JSaWdodCA+IDApIHtcbiAgICAvLyBjYXJldCBzaG91bGQgZ28gaW4gbWlkZGxlIGIvYyBpdCBjYW5cbiAgICBzdWJEaXIgPSAnbWlkZGxlJztcbiAgfSBlbHNlIGlmIChiZWxvd09yUmlnaHQgPiAwKSB7XG4gICAgLy8gY2FyZXQgc2hvdWxkIGdvIGF0IHRvcCBmb3IgbGVmdC9yaWdodCBhbmQgbGVmdCBmb3IgdXAvZG93blxuICAgIHN1YkRpciA9IG1haW5EaXIgPT09ICdsZWZ0JyB8fCBtYWluRGlyID09PSAncmlnaHQnID8gJ3VwJyA6ICdsZWZ0JztcbiAgfSBlbHNlIHtcbiAgICAvLyBjYXJldCBzaG91bGQgZ28gYXQgYm90dG9tIGZvciBsZWZ0L3JpZ2h0IGFuZCByaWdodCBmb3IgdXAvZG93blxuICAgIHN1YkRpciA9IG1haW5EaXIgPT09ICdsZWZ0JyB8fCBtYWluRGlyID09PSAncmlnaHQnID8gJ2Rvd24nIDogJ3JpZ2h0JztcbiAgfVxuICByZXR1cm4gc3ViRGlyO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFtb3VudCB0aGUgZmx5b3V0ICYgY2FyZXQgbmVlZCB0byBzaGlmdCBvdmVyIHRvIGFsaWduIHdpdGggZGVzaWduc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY2FsY0VkZ2VTaGlmdHMoXG4gIHN1YkRpcjogU3ViRGlyLFxuICB0cmlnZ2VyUmVjdDogQ2xpZW50UmVjdCxcbiAgd2luZG93U2l6ZTogV2luZG93XG4pIHtcbiAgLy8gVGFyZ2V0IHZhbHVlcyBmb3IgZmx5b3V0IGFuZCBjYXJldCBzaGlmdHNcbiAgbGV0IGZseW91dFZlcnRpY2FsU2hpZnQgPVxuICAgIENBUkVUX09GRlNFVF9GUk9NX1NJREUgLSAodHJpZ2dlclJlY3QuaGVpZ2h0IC0gQ0FSRVRfSEVJR0hUKSAvIDI7XG4gIGxldCBmbHlvdXRIb3Jpem9udGFsU2hpZnQgPVxuICAgIENBUkVUX09GRlNFVF9GUk9NX1NJREUgLSAodHJpZ2dlclJlY3Qud2lkdGggLSBDQVJFVF9IRUlHSFQpIC8gMjtcbiAgbGV0IGNhcmV0VmVydGljYWxTaGlmdCA9IENBUkVUX0hFSUdIVDtcbiAgbGV0IGNhcmV0SG9yaXpvbnRhbFNoaWZ0ID0gQ0FSRVRfSEVJR0hUO1xuXG4gIC8vIENvdmVycyBlZGdlIGNhc2Ugd2hlcmUgdHJpZ2dlciBpcyBpbiBhIGNvcm5lciBhbmQgd2UgbmVlZCB0byBhZGp1c3QgdGhlIG9mZnNldCBvZiB0aGUgY2FyZXRcbiAgLy8gdG8gc29tZXRoaW5nIHNtYWxsZXIgdGhhbiBub3JtYWwgaW4gb3JkZXJcbiAgY29uc3QgaXNDbG9zZVZlcnRpY2FsbHkgPVxuICAgIHRyaWdnZXJSZWN0LnRvcCAtIGZseW91dFZlcnRpY2FsU2hpZnQgPCAwIHx8XG4gICAgdHJpZ2dlclJlY3QuYm90dG9tICsgZmx5b3V0VmVydGljYWxTaGlmdCA+IHdpbmRvd1NpemUuaGVpZ2h0O1xuICBjb25zdCBpc0Nsb3NlSG9yaXpvbnRhbGx5ID1cbiAgICB0cmlnZ2VyUmVjdC5sZWZ0IC0gZmx5b3V0SG9yaXpvbnRhbFNoaWZ0IDwgMCB8fFxuICAgIHRyaWdnZXJSZWN0LnJpZ2h0ICsgZmx5b3V0SG9yaXpvbnRhbFNoaWZ0ID4gd2luZG93U2l6ZS53aWR0aDtcbiAgaWYgKGlzQ2xvc2VWZXJ0aWNhbGx5KSB7XG4gICAgZmx5b3V0VmVydGljYWxTaGlmdCA9XG4gICAgICBCT1JERVJfUkFESVVTIC0gKHRyaWdnZXJSZWN0LmhlaWdodCAtIENBUkVUX0hFSUdIVCkgLyAyO1xuICAgIGNhcmV0VmVydGljYWxTaGlmdCA9IEJPUkRFUl9SQURJVVM7XG4gIH1cbiAgaWYgKGlzQ2xvc2VIb3Jpem9udGFsbHkpIHtcbiAgICBmbHlvdXRIb3Jpem9udGFsU2hpZnQgPVxuICAgICAgQk9SREVSX1JBRElVUyAtICh0cmlnZ2VyUmVjdC53aWR0aCAtIENBUkVUX0hFSUdIVCkgLyAyO1xuICAgIGNhcmV0SG9yaXpvbnRhbFNoaWZ0ID0gQk9SREVSX1JBRElVUztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZmx5b3V0OiB7XG4gICAgICB4OiBmbHlvdXRIb3Jpem9udGFsU2hpZnQsXG4gICAgICB5OiBmbHlvdXRWZXJ0aWNhbFNoaWZ0LFxuICAgIH0sXG4gICAgY2FyZXQ6IHtcbiAgICAgIHg6IGNhcmV0SG9yaXpvbnRhbFNoaWZ0LFxuICAgICAgeTogY2FyZXRWZXJ0aWNhbFNoaWZ0LFxuICAgIH0sXG4gIH07XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBmbHlvdXQgYW5kIGNhcmV0IG9mZnNldHMgZm9yIHN0eWxpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkanVzdE9mZnNldHMoXG4gIGJhc2U6IHsgdG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciB9LFxuICBlZGdlU2hpZnQ6IEVkZ2VTaGlmdCxcbiAgZmx5b3V0U2l6ZTogRmx5b3V0LFxuICBtYWluRGlyOiBNYWluRGlyLFxuICBzdWJEaXI6IFN1YkRpcixcbiAgdHJpZ2dlclJlY3Q6IENsaWVudFJlY3Rcbikge1xuICBsZXQgZmx5b3V0TGVmdCA9IGJhc2UubGVmdDtcbiAgbGV0IGZseW91dFRvcCA9IGJhc2UudG9wO1xuXG4gIGxldCBjYXJldFRvcCA9IG1haW5EaXIgPT09ICdkb3duJyA/IC1DQVJFVF9IRUlHSFQgOiBudWxsO1xuICBsZXQgY2FyZXRSaWdodCA9IG1haW5EaXIgPT09ICdsZWZ0JyA/IC1DQVJFVF9IRUlHSFQgOiBudWxsO1xuICBsZXQgY2FyZXRCb3R0b20gPSBudWxsO1xuICBsZXQgY2FyZXRMZWZ0ID0gbWFpbkRpciA9PT0gJ3JpZ2h0JyA/IC1DQVJFVF9IRUlHSFQgOiBudWxsO1xuXG4gIGlmIChzdWJEaXIgPT09ICd1cCcpIHtcbiAgICBmbHlvdXRUb3AgPSBiYXNlLnRvcCAtIGVkZ2VTaGlmdC5mbHlvdXQueTtcbiAgICBjYXJldFRvcCA9IGVkZ2VTaGlmdC5jYXJldC55O1xuICB9IGVsc2UgaWYgKHN1YkRpciA9PT0gJ2Rvd24nKSB7XG4gICAgZmx5b3V0VG9wID1cbiAgICAgIGJhc2UudG9wIC0gZmx5b3V0U2l6ZS5oZWlnaHQgKyB0cmlnZ2VyUmVjdC5oZWlnaHQgKyBlZGdlU2hpZnQuZmx5b3V0Lnk7XG4gICAgY2FyZXRCb3R0b20gPSBlZGdlU2hpZnQuY2FyZXQueTtcbiAgfSBlbHNlIGlmIChzdWJEaXIgPT09ICdsZWZ0Jykge1xuICAgIGZseW91dExlZnQgPSBiYXNlLmxlZnQgLSBlZGdlU2hpZnQuZmx5b3V0Lng7XG4gICAgY2FyZXRMZWZ0ID0gZWRnZVNoaWZ0LmNhcmV0Lng7XG4gIH0gZWxzZSBpZiAoc3ViRGlyID09PSAncmlnaHQnKSB7XG4gICAgZmx5b3V0TGVmdCA9XG4gICAgICBiYXNlLmxlZnQgLSBmbHlvdXRTaXplLndpZHRoICsgdHJpZ2dlclJlY3Qud2lkdGggKyBlZGdlU2hpZnQuZmx5b3V0Lng7XG4gICAgY2FyZXRSaWdodCA9IGVkZ2VTaGlmdC5jYXJldC54O1xuICB9IGVsc2UgaWYgKHN1YkRpciA9PT0gJ21pZGRsZScpIHtcbiAgICBpZiAobWFpbkRpciA9PT0gJ2xlZnQnIHx8IG1haW5EaXIgPT09ICdyaWdodCcpIHtcbiAgICAgIGNvbnN0IHRyaWdnZXJNaWQgPSBmbHlvdXRUb3AgKyB0cmlnZ2VyUmVjdC5oZWlnaHQgLyAyO1xuICAgICAgZmx5b3V0VG9wID0gdHJpZ2dlck1pZCAtIGZseW91dFNpemUuaGVpZ2h0IC8gMjtcbiAgICAgIGNhcmV0VG9wID0gKGZseW91dFNpemUuaGVpZ2h0IC0gQ0FSRVRfSEVJR0hUKSAvIDI7XG4gICAgfVxuICAgIGlmIChtYWluRGlyID09PSAndXAnIHx8IG1haW5EaXIgPT09ICdkb3duJykge1xuICAgICAgY29uc3QgdHJpZ2dlck1pZCA9IGZseW91dExlZnQgKyB0cmlnZ2VyUmVjdC53aWR0aCAvIDI7XG4gICAgICBmbHlvdXRMZWZ0ID0gdHJpZ2dlck1pZCAtIGZseW91dFNpemUud2lkdGggLyAyO1xuICAgICAgY2FyZXRMZWZ0ID0gKGZseW91dFNpemUud2lkdGggLSBDQVJFVF9IRUlHSFQpIC8gMjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZseW91dE9mZnNldDoge1xuICAgICAgdG9wOiBmbHlvdXRUb3AsXG4gICAgICBsZWZ0OiBmbHlvdXRMZWZ0LFxuICAgIH0sXG4gICAgY2FyZXRPZmZzZXQ6IHtcbiAgICAgIHRvcDogY2FyZXRUb3AsXG4gICAgICByaWdodDogY2FyZXRSaWdodCxcbiAgICAgIGJvdHRvbTogY2FyZXRCb3R0b20sXG4gICAgICBsZWZ0OiBjYXJldExlZnQsXG4gICAgfSxcbiAgfTtcbn1cblxuLyogQ2FsY3VsYXRlcyBiYXNlbGluZSB0b3AgYW5kIGxlZnQgb2Zmc2V0IGZvciBmbHlvdXQgKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlT2Zmc2V0cyhcbiAgcmVsYXRpdmVPZmZzZXQ6IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfSxcbiAgZmx5b3V0U2l6ZTogRmx5b3V0LFxuICBtYWluRGlyOiBNYWluRGlyLFxuICB0cmlnZ2VyUmVjdDogQ2xpZW50UmVjdCxcbiAgd2luZG93U2l6ZTogV2luZG93XG4pIHtcbiAgY29uc3QgSEFMRl9DQVJFVCA9IENBUkVUX0hFSUdIVCAvIDI7XG4gIC8vIFRPUCBPRkZTRVRcbiAgbGV0IHRvcDtcbiAgaWYgKG1haW5EaXIgPT09ICdkb3duJykge1xuICAgIHRvcCA9IHdpbmRvd1NpemUuc2Nyb2xsWSArIHRyaWdnZXJSZWN0LmJvdHRvbSArIEhBTEZfQ0FSRVQ7XG4gIH0gZWxzZSBpZiAobWFpbkRpciA9PT0gJ3VwJykge1xuICAgIHRvcCA9XG4gICAgICB3aW5kb3dTaXplLnNjcm9sbFkgKyAodHJpZ2dlclJlY3QudG9wIC0gZmx5b3V0U2l6ZS5oZWlnaHQgLSBIQUxGX0NBUkVUKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBsZWZ0IGFuZCByaWdodFxuICAgIHRvcCA9IHdpbmRvd1NpemUuc2Nyb2xsWSArIHRyaWdnZXJSZWN0LnRvcDtcbiAgfVxuXG4gIC8vIExFRlQgT0ZGU0VUXG4gIGxldCBsZWZ0O1xuICBpZiAobWFpbkRpciA9PT0gJ2xlZnQnKSB7XG4gICAgbGVmdCA9XG4gICAgICB3aW5kb3dTaXplLnNjcm9sbFggKyAodHJpZ2dlclJlY3QubGVmdCAtIGZseW91dFNpemUud2lkdGggLSBIQUxGX0NBUkVUKTtcbiAgfSBlbHNlIGlmIChtYWluRGlyID09PSAncmlnaHQnKSB7XG4gICAgbGVmdCA9IHdpbmRvd1NpemUuc2Nyb2xsWCArIHRyaWdnZXJSZWN0LnJpZ2h0ICsgSEFMRl9DQVJFVDtcbiAgfSBlbHNlIHtcbiAgICAvLyBkb3duIGFuZCB1cFxuICAgIGxlZnQgPSB3aW5kb3dTaXplLnNjcm9sbFggKyB0cmlnZ2VyUmVjdC5sZWZ0O1xuICB9XG5cbiAgLy8gQWRqdXN0cyBmb3IgdGhlIHJlbGF0aXZlIHBhcmVudCBjb250YWluZXJcbiAgdG9wIC09IHJlbGF0aXZlT2Zmc2V0Lnk7XG4gIGxlZnQgLT0gcmVsYXRpdmVPZmZzZXQueDtcbiAgcmV0dXJuIHsgdG9wLCBsZWZ0IH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRlbnRzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0ZTogU3RhdGUgPSB7XG4gICAgZmx5b3V0T2Zmc2V0OiB7XG4gICAgICB0b3A6IHVuZGVmaW5lZCxcbiAgICAgIHJpZ2h0OiB1bmRlZmluZWQsXG4gICAgICBib3R0b206IHVuZGVmaW5lZCxcbiAgICAgIGxlZnQ6IHVuZGVmaW5lZCxcbiAgICB9LFxuICAgIGNhcmV0T2Zmc2V0OiB7XG4gICAgICB0b3A6IHVuZGVmaW5lZCxcbiAgICAgIHJpZ2h0OiB1bmRlZmluZWQsXG4gICAgICBib3R0b206IHVuZGVmaW5lZCxcbiAgICAgIGxlZnQ6IHVuZGVmaW5lZCxcbiAgICB9LFxuICAgIG1haW5EaXI6IG51bGwsXG4gIH07XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5zZXRGbHlvdXRQb3NpdGlvbih0aGlzLnByb3BzKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnByb3BzLnNob3VsZEZvY3VzICYmIHRoaXMuZmx5b3V0KSB7XG4gICAgICAgIHRoaXMuZmx5b3V0LmZvY3VzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucHJvcHMub25SZXNpemUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5wcm9wcy5vbktleURvd24pO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHM6IFByb3BzKSB7XG4gICAgdGhpcy5zZXRGbHlvdXRQb3NpdGlvbihuZXh0UHJvcHMpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucHJvcHMub25SZXNpemUpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5wcm9wcy5vbktleURvd24pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIG1haW4gZGlyZWNpdG9uLCBzdWIgZGlyZWN0aW9uLCBhbmQgY29ycmVzcG9uZGluZyBvZmZzZXRzIG5lZWRlZFxuICAgKiB0byBjb3JyZWN0bHkgcG9zaXRpb24gdGhlIG9mZnNldFxuICAgKi9cbiAgc2V0Rmx5b3V0UG9zaXRpb24gPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcmVsYXRpdmVPZmZzZXQsXG4gICAgICBpZGVhbERpcmVjdGlvbixcbiAgICAgIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcixcbiAgICAgIHRyaWdnZXJSZWN0LFxuICAgICAgd2lkdGgsXG4gICAgfSA9IHByb3BzO1xuXG4gICAgLy8gU2Nyb2xsIG5vdCBuZWVkZWQgZm9yIHJlbGF0aXZlIGVsZW1lbnRzXG4gICAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5zY3JvbGxYIC8gd2luZG93LnNjcm9sbFkgc2luY2UgaXQncyBub3Qgc3VwcG9ydGVkIGJ5IElFMTFcbiAgICBjb25zdCBzY3JvbGxYID0gcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yXG4gICAgICA/IDBcbiAgICAgIDogd2luZG93LnBhZ2VYT2Zmc2V0IHx8XG4gICAgICAgIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQpIHx8XG4gICAgICAgIDA7XG4gICAgY29uc3Qgc2Nyb2xsWSA9IHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvclxuICAgICAgPyAwXG4gICAgICA6IHdpbmRvdy5wYWdlWU9mZnNldCB8fFxuICAgICAgICAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApIHx8XG4gICAgICAgIDA7XG5cbiAgICBjb25zdCB3aW5kb3dTaXplID0ge1xuICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICBzY3JvbGxYLFxuICAgICAgc2Nyb2xsWSxcbiAgICB9O1xuXG4gICAgY29uc3QgZmx5b3V0U2l6ZSA9IHtcbiAgICAgIGhlaWdodDogdGhpcy5mbHlvdXQgPyB0aGlzLmZseW91dC5jbGllbnRIZWlnaHQgOiAwLFxuICAgICAgd2lkdGgsXG4gICAgfTtcblxuICAgIC8vIEZpcnN0IGNob29zZSBvbmUgb2YgNCBtYWluIGRpcmVjdGlvblxuICAgIGNvbnN0IG1haW5EaXIgPSBnZXRNYWluRGlyKFxuICAgICAgZmx5b3V0U2l6ZSxcbiAgICAgIGlkZWFsRGlyZWN0aW9uLFxuICAgICAgdHJpZ2dlclJlY3QsXG4gICAgICB3aW5kb3dTaXplXG4gICAgKTtcblxuICAgIC8vIE5vdyB0aGF0IHdlIGhhdmUgdGhlIG1haW4gZGlyZWN0aW9uLCBjaG9zZSBmcm9tIDMgY2FyZXQgcGxhY2VtZW50cyBmb3IgdGhhdCBkaXJlY3Rpb25cbiAgICBjb25zdCBzdWJEaXIgPSBnZXRTdWJEaXIoZmx5b3V0U2l6ZSwgbWFpbkRpciwgdHJpZ2dlclJlY3QsIHdpbmRvd1NpemUpO1xuXG4gICAgLy8gR2V0cyB0aGUgYmFzZSBvZmZzZXQgdGhhdCBwb3NpdGlvbnMgdGhlIGZseW91dCBiYXNlZCBvbiB0aGUgbWFpbiBkaXJlY3Rpb24gb25seVxuICAgIGNvbnN0IGJhc2UgPSBiYXNlT2Zmc2V0cyhcbiAgICAgIHJlbGF0aXZlT2Zmc2V0LFxuICAgICAgZmx5b3V0U2l6ZSxcbiAgICAgIG1haW5EaXIsXG4gICAgICB0cmlnZ2VyUmVjdCxcbiAgICAgIHdpbmRvd1NpemVcbiAgICApO1xuXG4gICAgLy8gR2V0cyB0aGUgZWRnZSBzaGlmdHMgZm9yIHRoZSBmbHlvdXRcbiAgICBjb25zdCBlZGdlU2hpZnRzID0gY2FsY0VkZ2VTaGlmdHMoc3ViRGlyLCB0cmlnZ2VyUmVjdCwgd2luZG93U2l6ZSk7XG5cbiAgICAvLyBBZGp1c3RzIGZvciB0aGUgc3ViZGlyZWN0aW9uIG9mIHRoZSBjYXJldFxuICAgIGNvbnN0IHsgZmx5b3V0T2Zmc2V0LCBjYXJldE9mZnNldCB9ID0gYWRqdXN0T2Zmc2V0cyhcbiAgICAgIGJhc2UsXG4gICAgICBlZGdlU2hpZnRzLFxuICAgICAgZmx5b3V0U2l6ZSxcbiAgICAgIG1haW5EaXIsXG4gICAgICBzdWJEaXIsXG4gICAgICB0cmlnZ2VyUmVjdFxuICAgICk7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGNhcmV0T2Zmc2V0LFxuICAgICAgZmx5b3V0T2Zmc2V0LFxuICAgICAgbWFpbkRpcixcbiAgICB9KTtcbiAgfTtcblxuICBmbHlvdXQ6ID9IVE1MRWxlbWVudDtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBiZ0NvbG9yLCBjaGlsZHJlbiwgd2lkdGggfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBOZWVkZWQgdG8gcHJldmVudCBVSSB0aHJhc2hpbmdcbiAgICBjb25zdCB2aXNpYmlsaXR5ID0gdGhpcy5zdGF0ZS5tYWluRGlyID09PSBudWxsID8gJ2hpZGRlbicgOiAndmlzaWJsZSc7XG4gICAgY29uc3QgYmFja2dyb3VuZCA9IGAke2JnQ29sb3J9QmdgO1xuICAgIGNvbnN0IHN0cm9rZSA9IGJnQ29sb3IgPT09ICd3aGl0ZScgPyAnI2VmZWZlZicgOiBudWxsO1xuICAgIGNvbnN0IGJvcmRlckNvbG9yID0gYmdDb2xvciA9PT0gJ3doaXRlJyA/ICdsaWdodEdyYXknIDogYmdDb2xvcjtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmNvbnRhaW5lcn1cbiAgICAgICAgc3R5bGU9e3sgc3Ryb2tlLCB2aXNpYmlsaXR5LCAuLi50aGlzLnN0YXRlLmZseW91dE9mZnNldCB9fVxuICAgICAgPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKFxuICAgICAgICAgICAgY29sb3JzW2JhY2tncm91bmRdLFxuICAgICAgICAgICAgY29sb3JzW2JvcmRlckNvbG9yXSxcbiAgICAgICAgICAgIHN0eWxlcy5kaW1lbnNpb25zLFxuICAgICAgICAgICAgc3R5bGVzLmNvbnRlbnRzXG4gICAgICAgICAgKX1cbiAgICAgICAgICByZWY9e2MgPT4ge1xuICAgICAgICAgICAgdGhpcy5mbHlvdXQgPSBjO1xuICAgICAgICAgIH19XG4gICAgICAgICAgdGFiSW5kZXg9ey0xfVxuICAgICAgICA+XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKHN0eWxlcy5kaW1lbnNpb25zLCBzdHlsZXMuaW5uZXJDb250ZW50cyl9XG4gICAgICAgICAgICBzdHlsZT17eyB3aWR0aCB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzbmFtZXMoY29sb3JzW2JnQ29sb3JdLCBzdHlsZXMuY2FyZXQpfVxuICAgICAgICAgICAgc3R5bGU9e3sgLi4udGhpcy5zdGF0ZS5jYXJldE9mZnNldCB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxDYXJldCBkaXJlY3Rpb249e3RoaXMuc3RhdGUubWFpbkRpcn0gLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cbi8qIGVzbGludCByZWFjdC9uby11bnVzZWQtcHJvcC10eXBlczogMCAqL1xuQ29udGVudHMucHJvcFR5cGVzID0ge1xuICBiZ0NvbG9yOiBQcm9wVHlwZXMub25lT2YoWydibHVlJywgJ2RhcmtHcmF5JywgJ29yYW5nZScsICd3aGl0ZSddKSxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBpZGVhbERpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsndXAnLCAncmlnaHQnLCAnZG93bicsICdsZWZ0J10pLFxuICBvbktleURvd246IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIG9uUmVzaXplOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICByZWxhdGl2ZU9mZnNldDogUHJvcFR5cGVzLmV4YWN0KHsgeDogUHJvcFR5cGVzLm51bWJlciwgeTogUHJvcFR5cGVzLm51bWJlciB9KSxcbiAgcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2hvdWxkRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuICB0cmlnZ2VyUmVjdDogUHJvcFR5cGVzLmV4YWN0KHtcbiAgICBib3R0b206IFByb3BUeXBlcy5udW1iZXIsXG4gICAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGxlZnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgcmlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgdG9wOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuICB9KSxcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZpbmRET01Ob2RlIH0gZnJvbSAncmVhY3QtZG9tJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgb25DbGljaz86IChldmVudDogTW91c2VFdmVudCkgPT4gdm9pZCxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPdXRzaWRlRXZlbnRCZWhhdmlvciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcz4ge1xuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tFdmVudCwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja0V2ZW50LCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgaGFuZGxlQ2xpY2tFdmVudCA9IChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1maW5kLWRvbS1ub2RlXG4gICAgY29uc3QgZWwgPSBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgICBpZiAoXG4gICAgICAhdGhpcy5wcm9wcy5vbkNsaWNrIHx8XG4gICAgICAhZWwgfHxcbiAgICAgIChldmVudC50YXJnZXQgaW5zdGFuY2VvZiBOb2RlICYmIGVsLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucHJvcHMub25DbGljayhldmVudCk7XG4gIH07XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBDb250ZW50cyBmcm9tICcuL0NvbnRlbnRzLmpzJztcbmltcG9ydCBPdXRzaWRlRXZlbnRCZWhhdmlvciBmcm9tICcuL2JlaGF2aW9ycy9PdXRzaWRlRXZlbnRCZWhhdmlvci5qcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhbmNob3I6ID9IVE1MRWxlbWVudCxcbiAgYmdDb2xvcjogJ2JsdWUnIHwgJ2RhcmtHcmF5JyB8ICdvcmFuZ2UnIHwgJ3doaXRlJyxcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICBpZGVhbERpcmVjdGlvbj86ICd1cCcgfCAncmlnaHQnIHwgJ2Rvd24nIHwgJ2xlZnQnLFxuICBvbkRpc21pc3M6ICgpID0+IHZvaWQsXG4gIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcjogYm9vbGVhbixcbiAgc2hvdWxkRm9jdXM/OiBib29sZWFuLFxuICBzaXplPzogJ3hzJyB8ICdzbScgfCAnbWQnIHwgJ2xnJyB8ICd4bCcgfCBudW1iZXIsXG58fTtcblxuY29uc3QgU0laRV9XSURUSF9NQVAgPSB7XG4gIHhzOiAxODUsXG4gIHNtOiAyMzAsXG4gIG1kOiAyODQsXG4gIGxnOiAzMjAsXG4gIHhsOiAzNzUsXG59O1xuXG5jb25zdCBFU0NBUEVfS0VZX0NPREUgPSAyNztcblxudHlwZSBDbGllbnRSZWN0ID0ge1xuICBib3R0b206IG51bWJlcixcbiAgaGVpZ2h0OiBudW1iZXIsXG4gIGxlZnQ6IG51bWJlcixcbiAgcmlnaHQ6IG51bWJlcixcbiAgdG9wOiBudW1iZXIsXG4gIHdpZHRoOiBudW1iZXIsXG59O1xuXG50eXBlIFN0YXRlID0ge1xuICByZWxhdGl2ZU9mZnNldDoge1xuICAgIHg6IG51bWJlcixcbiAgICB5OiBudW1iZXIsXG4gIH0sXG4gIHRyaWdnZXJCb3VuZGluZ1JlY3Q6IENsaWVudFJlY3QsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250cm9sbGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0ZTogU3RhdGUgPSB7XG4gICAgcmVsYXRpdmVPZmZzZXQ6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgIH0sXG4gICAgdHJpZ2dlckJvdW5kaW5nUmVjdDoge1xuICAgICAgYm90dG9tOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgd2lkdGg6IDAsXG4gICAgfSxcbiAgfTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnVwZGF0ZVRyaWdnZXJSZWN0KHRoaXMucHJvcHMpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHM6IFByb3BzKSB7XG4gICAgdGhpcy51cGRhdGVUcmlnZ2VyUmVjdChuZXh0UHJvcHMpO1xuICB9XG5cbiAgaGFuZGxlS2V5RG93biA9IChldmVudDogeyBrZXlDb2RlOiBudW1iZXIgfSkgPT4ge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSBFU0NBUEVfS0VZX0NPREUpIHtcbiAgICAgIHRoaXMucHJvcHMub25EaXNtaXNzKCk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZVBhZ2VDbGljayA9IChldmVudDogRXZlbnQpID0+IHtcbiAgICBpZiAoXG4gICAgICBldmVudC50YXJnZXQgaW5zdGFuY2VvZiBOb2RlICYmXG4gICAgICB0aGlzLnByb3BzLmFuY2hvciAmJlxuICAgICAgIXRoaXMucHJvcHMuYW5jaG9yLmNvbnRhaW5zKGV2ZW50LnRhcmdldClcbiAgICApIHtcbiAgICAgIHRoaXMucHJvcHMub25EaXNtaXNzKCk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICB0aGlzLnVwZGF0ZVRyaWdnZXJSZWN0KHRoaXMucHJvcHMpO1xuICB9O1xuXG4gIHVwZGF0ZVRyaWdnZXJSZWN0ID0gKHByb3BzOiBQcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgYW5jaG9yLCBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3IgfSA9IHByb3BzO1xuICAgIGxldCB0cmlnZ2VyQm91bmRpbmdSZWN0O1xuICAgIGxldCByZWxhdGl2ZU9mZnNldDtcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICB0cmlnZ2VyQm91bmRpbmdSZWN0ID0gYW5jaG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAvLyBOZWVkZWQgZm9yIGNvcnJlY3QgcG9zaXRpb25pbmcgd2l0aGluIENvbnRlbnRzLmpzXG4gICAgICByZWxhdGl2ZU9mZnNldCA9IHtcbiAgICAgICAgeDogcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yXG4gICAgICAgICAgPyB0cmlnZ2VyQm91bmRpbmdSZWN0LmxlZnQgLSBhbmNob3Iub2Zmc2V0TGVmdFxuICAgICAgICAgIDogMCxcbiAgICAgICAgeTogcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yXG4gICAgICAgICAgPyB0cmlnZ2VyQm91bmRpbmdSZWN0LnRvcCAtIGFuY2hvci5vZmZzZXRUb3BcbiAgICAgICAgICA6IDAsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuc2V0U3RhdGUoeyByZWxhdGl2ZU9mZnNldCwgdHJpZ2dlckJvdW5kaW5nUmVjdCB9KTtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYW5jaG9yLFxuICAgICAgYmdDb2xvcixcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgaWRlYWxEaXJlY3Rpb24sXG4gICAgICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3IsXG4gICAgICBzaG91bGRGb2N1cyxcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIWFuY2hvcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNpemUgPSB0aGlzLnByb3BzLnNpemUgPyB0aGlzLnByb3BzLnNpemUgOiAnc20nO1xuICAgIGNvbnN0IHdpZHRoID0gdHlwZW9mIHNpemUgPT09ICdzdHJpbmcnID8gU0laRV9XSURUSF9NQVBbc2l6ZV0gOiBzaXplO1xuICAgIHJldHVybiAoXG4gICAgICA8T3V0c2lkZUV2ZW50QmVoYXZpb3Igb25DbGljaz17dGhpcy5oYW5kbGVQYWdlQ2xpY2t9PlxuICAgICAgICA8Q29udGVudHNcbiAgICAgICAgICBiZ0NvbG9yPXtiZ0NvbG9yfVxuICAgICAgICAgIGlkZWFsRGlyZWN0aW9uPXtpZGVhbERpcmVjdGlvbn1cbiAgICAgICAgICBvbktleURvd249e3RoaXMuaGFuZGxlS2V5RG93bn1cbiAgICAgICAgICBvblJlc2l6ZT17dGhpcy5oYW5kbGVSZXNpemV9XG4gICAgICAgICAgcG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yPXtwb3NpdGlvblJlbGF0aXZlVG9BbmNob3J9XG4gICAgICAgICAgcmVsYXRpdmVPZmZzZXQ9e3RoaXMuc3RhdGUucmVsYXRpdmVPZmZzZXR9XG4gICAgICAgICAgc2hvdWxkRm9jdXM9e3Nob3VsZEZvY3VzfVxuICAgICAgICAgIHRyaWdnZXJSZWN0PXt0aGlzLnN0YXRlLnRyaWdnZXJCb3VuZGluZ1JlY3R9XG4gICAgICAgICAgd2lkdGg9e3dpZHRofVxuICAgICAgICA+XG4gICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L0NvbnRlbnRzPlxuICAgICAgPC9PdXRzaWRlRXZlbnRCZWhhdmlvcj5cbiAgICApO1xuICB9XG59XG5cbkNvbnRyb2xsZXIucHJvcFR5cGVzID0ge1xuICBhbmNob3I6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgY29udGFpbnM6IFByb3BUeXBlcy5mdW5jLFxuICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogUHJvcFR5cGVzLmZ1bmMsXG4gIH0pLFxuICBiZ0NvbG9yOiBQcm9wVHlwZXMub25lT2YoWydibHVlJywgJ2RhcmtHcmF5JywgJ29yYW5nZScsICd3aGl0ZSddKSxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBpZGVhbERpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsndXAnLCAncmlnaHQnLCAnZG93bicsICdsZWZ0J10pLFxuICBvbkRpc21pc3M6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcjogUHJvcFR5cGVzLmJvb2wsXG4gIHNob3VsZEZvY3VzOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgUHJvcFR5cGVzLm51bWJlcixcbiAgICBQcm9wVHlwZXMub25lT2YoWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddKSwgLy8gZGVmYXVsdDogc21cbiAgXSksXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQ29udHJvbGxlciBmcm9tICcuL0NvbnRyb2xsZXIuanMnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgYW5jaG9yOiA/SFRNTEVsZW1lbnQsXG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgaWRlYWxEaXJlY3Rpb24/OiAndXAnIHwgJ3JpZ2h0JyB8ICdkb3duJyB8ICdsZWZ0JyxcbiAgb25EaXNtaXNzOiAoKSA9PiB2b2lkLFxuICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3I/OiBib29sZWFuLFxuICBjb2xvcj86ICdibHVlJyB8ICdvcmFuZ2UnIHwgJ3doaXRlJyxcbiAgc2hvdWxkRm9jdXM/OiBib29sZWFuLFxuICBzaXplPzogJ3hzJyB8ICdzbScgfCAnbWQnIHwgJ2xnJyB8ICd4bCcgfCBudW1iZXIsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmx5b3V0KHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7XG4gICAgYW5jaG9yLFxuICAgIGNoaWxkcmVuLFxuICAgIGlkZWFsRGlyZWN0aW9uLFxuICAgIG9uRGlzbWlzcyxcbiAgICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3IgPSB0cnVlLFxuICAgIGNvbG9yID0gJ3doaXRlJyxcbiAgICBzaG91bGRGb2N1cyA9IHRydWUsXG4gICAgc2l6ZSxcbiAgfSA9IHByb3BzO1xuXG4gIGlmICghYW5jaG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxDb250cm9sbGVyXG4gICAgICBhbmNob3I9e2FuY2hvcn1cbiAgICAgIGJnQ29sb3I9e2NvbG9yfVxuICAgICAgaWRlYWxEaXJlY3Rpb249e2lkZWFsRGlyZWN0aW9ufVxuICAgICAgb25EaXNtaXNzPXtvbkRpc21pc3N9XG4gICAgICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3I9e3Bvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcn1cbiAgICAgIHNob3VsZEZvY3VzPXtzaG91bGRGb2N1c31cbiAgICAgIHNpemU9e3NpemV9XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQ29udHJvbGxlcj5cbiAgKTtcbn1cblxuRmx5b3V0LnByb3BUeXBlcyA9IHtcbiAgYW5jaG9yOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGNvbnRhaW5zOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IFByb3BUeXBlcy5mdW5jLFxuICB9KSxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBpZGVhbERpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsndXAnLCAncmlnaHQnLCAnZG93bicsICdsZWZ0J10pLFxuICBvbkRpc21pc3M6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcjogUHJvcFR5cGVzLmJvb2wsXG4gIGNvbG9yOiBQcm9wVHlwZXMub25lT2YoWydibHVlJywgJ29yYW5nZScsICd3aGl0ZSddKSxcbiAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgUHJvcFR5cGVzLm51bWJlcixcbiAgICBQcm9wVHlwZXMub25lT2YoWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddKSwgLy8gZGVmYXVsdDogc21cbiAgXSksXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vR3JvdXBBdmF0YXIuY3NzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IEltYWdlIGZyb20gJy4vSW1hZ2UuanMnO1xuaW1wb3J0IHR5cG9ncmFwaHkgZnJvbSAnLi9UeXBvZ3JhcGh5LmNzcyc7XG5cbmZ1bmN0aW9uIHppcChhLCBiKSB7XG4gIHJldHVybiBhLm1hcCgoaXRlbSwgaWR4KSA9PiBbaXRlbSwgYltpZHhdXSk7XG59XG5cbmNvbnN0IEJPUkRFUl9XSURUSCA9IDI7XG5cbmNvbnN0IEFWQVRBUl9TSVpFUyA9IHtcbiAgc206IDI0LFxuICBtZDogNDAsXG4gIGxnOiA3Mixcbn07XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjb2xsYWJvcmF0b3JzOiBBcnJheTx7fFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICBzcmM/OiBzdHJpbmcsXG4gIHx9PixcbiAgb3V0bGluZT86IGJvb2xlYW4sXG4gIHNpemU/OiAnc20nIHwgJ21kJyB8ICdsZycsXG58fTtcblxuY29uc3QgYXZhdGFyTGF5b3V0ID0gKG4sIHNpemUpID0+IHtcbiAgc3dpdGNoIChuKSB7XG4gICAgY2FzZSAwOlxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHsgdG9wOiAwLCBsZWZ0OiAwLCB3aWR0aDogc2l6ZSwgaGVpZ2h0OiBzaXplLCB0ZXh0TGF5b3V0OiAnY2VudGVyJyB9LFxuICAgICAgXTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgd2lkdGg6IGBjYWxjKDUwJSAtICR7Qk9SREVSX1dJRFRIIC8gMn1weClgLFxuICAgICAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgICAgICB0ZXh0TGF5b3V0OiAnY2VudGVyJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiBgY2FsYyg1MCUgKyAke0JPUkRFUl9XSURUSCAvIDJ9cHgpYCxcbiAgICAgICAgICB3aWR0aDogYGNhbGMoNTAlIC0gJHtCT1JERVJfV0lEVEggLyAyfXB4KWAsXG4gICAgICAgICAgaGVpZ2h0OiBzaXplLFxuICAgICAgICAgIHRleHRMYXlvdXQ6ICdjZW50ZXInLFxuICAgICAgICB9LFxuICAgICAgXTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHdpZHRoOiBgY2FsYyg1MCUgLSAke0JPUkRFUl9XSURUSCAvIDJ9cHgpYCxcbiAgICAgICAgICBoZWlnaHQ6IHNpemUsXG4gICAgICAgICAgdGV4dExheW91dDogJ2NlbnRlcicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogYGNhbGMoNTAlICsgJHtCT1JERVJfV0lEVEggLyAyfXB4KWAsXG4gICAgICAgICAgd2lkdGg6ICdjYWxjKDUwJSknLFxuICAgICAgICAgIGhlaWdodDogYGNhbGMoNTAlIC0gJHtCT1JERVJfV0lEVEggLyAyfXB4KWAsXG4gICAgICAgICAgdGV4dExheW91dDogJ3RvcExlZnQnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdG9wOiBgY2FsYyg1MCUgKyAke0JPUkRFUl9XSURUSCAvIDJ9cHgpYCxcbiAgICAgICAgICBsZWZ0OiBgY2FsYyg1MCUgKyAke0JPUkRFUl9XSURUSCAvIDJ9cHgpYCxcbiAgICAgICAgICB3aWR0aDogJ2NhbGMoNTAlKScsXG4gICAgICAgICAgaGVpZ2h0OiBgY2FsYyg1MCUgLSAke0JPUkRFUl9XSURUSCAvIDJ9cHgpYCxcbiAgICAgICAgICB0ZXh0TGF5b3V0OiAnYm90dG9tTGVmdCcsXG4gICAgICAgIH0sXG4gICAgICBdO1xuICB9XG59O1xuXG5jb25zdCBkZWdUb1JhZCA9IGRlZyA9PiBkZWcgKiAoTWF0aC5QSSAvIDE4MCk7XG5cbmNvbnN0IERlZmF1bHRBdmF0YXIgPSAocHJvcHM6IHt8XG4gIHNpemU6IHN0cmluZyB8IG51bWJlcixcbiAgbmFtZTogc3RyaW5nLFxuICB0ZXh0TGF5b3V0OiAnY2VudGVyJyB8ICd0b3BMZWZ0JyB8ICdib3R0b21MZWZ0Jyxcbnx9KSA9PiB7XG4gIGNvbnN0IHsgc2l6ZSwgbmFtZSwgdGV4dExheW91dCB9ID0gcHJvcHM7XG5cbiAgY29uc3QgcXVhcnRlclBhZGRpbmcgPSBgY2FsYygke01hdGguc2luKGRlZ1RvUmFkKDQ1KSl9ICogKCR7c2l6ZX0pIC8gMilgO1xuXG4gIGNvbnN0IGluaXRpYWwgPSAoXG4gICAgPHN2Z1xuICAgICAgd2lkdGg9XCIxMDAlXCJcbiAgICAgIHZpZXdCb3g9XCItNTAgLTUwIDEwMCAxMDBcIlxuICAgICAgdmVyc2lvbj1cIjEuMVwiXG4gICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVwieE1pZFlNaWQgbWVldFwiXG4gICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICA+XG4gICAgICA8dGl0bGU+e25hbWV9PC90aXRsZT5cbiAgICAgIDx0ZXh0XG4gICAgICAgIGZvbnRTaXplPVwiNTBweFwiXG4gICAgICAgIGZpbGw9XCIjZmZmXCJcbiAgICAgICAgZG9taW5hbnRCYXNlbGluZT1cImNlbnRyYWxcIlxuICAgICAgICB0ZXh0QW5jaG9yPVwibWlkZGxlXCJcbiAgICAgICAgY2xhc3NOYW1lPXtbXG4gICAgICAgICAgdHlwb2dyYXBoeS5hbnRpYWxpYXNlZCxcbiAgICAgICAgICB0eXBvZ3JhcGh5LnNhbnNTZXJpZixcbiAgICAgICAgICB0eXBvZ3JhcGh5LmxlYWRpbmdTbWFsbCxcbiAgICAgICAgICB0eXBvZ3JhcGh5LmZvbnRXZWlnaHRCb2xkLFxuICAgICAgICBdLmpvaW4oJyAnKX1cbiAgICAgID5cbiAgICAgICAge25hbWUgPyBbLi4ubmFtZV1bMF0udG9VcHBlckNhc2UoKSA6ICcnfVxuICAgICAgPC90ZXh0PlxuICAgIDwvc3ZnPlxuICApO1xuICBzd2l0Y2ggKHRleHRMYXlvdXQpIHtcbiAgICBjYXNlICdib3R0b21MZWZ0JzpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxCb3hcbiAgICAgICAgICBhcmlhLWxhYmVsPXtuYW1lfVxuICAgICAgICAgIGNvbG9yPVwiZ3JheVwiXG4gICAgICAgICAgaGVpZ2h0PVwiMTAwJVwiXG4gICAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICAgIGFsaWduSXRlbXM9XCJlbmRcIlxuICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3tcbiAgICAgICAgICAgIF9fc3R5bGU6IHtcbiAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogcXVhcnRlclBhZGRpbmcsXG4gICAgICAgICAgICAgIHBhZGRpbmdSaWdodDogcXVhcnRlclBhZGRpbmcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH19XG4gICAgICAgID5cbiAgICAgICAgICB7aW5pdGlhbH1cbiAgICAgICAgPC9Cb3g+XG4gICAgICApO1xuICAgIGNhc2UgJ3RvcExlZnQnOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPEJveFxuICAgICAgICAgIGFyaWEtbGFiZWw9e25hbWV9XG4gICAgICAgICAgY29sb3I9XCJncmF5XCJcbiAgICAgICAgICBoZWlnaHQ9XCIxMDAlXCJcbiAgICAgICAgICBkaXNwbGF5PVwiZmxleFwiXG4gICAgICAgICAgYWxpZ25JdGVtcz1cInN0YXJ0XCJcbiAgICAgICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7XG4gICAgICAgICAgICBfX3N0eWxlOiB7XG4gICAgICAgICAgICAgIHBhZGRpbmdUb3A6IHF1YXJ0ZXJQYWRkaW5nLFxuICAgICAgICAgICAgICBwYWRkaW5nUmlnaHQ6IHF1YXJ0ZXJQYWRkaW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAge2luaXRpYWx9XG4gICAgICAgIDwvQm94PlxuICAgICAgKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPEJveFxuICAgICAgICAgIGFyaWEtbGFiZWw9e25hbWV9XG4gICAgICAgICAgY29sb3I9XCJncmF5XCJcbiAgICAgICAgICBoZWlnaHQ9XCIxMDAlXCJcbiAgICAgICAgICBkaXNwbGF5PVwiZmxleFwiXG4gICAgICAgICAgYWxpZ25JdGVtcz1cImNlbnRlclwiXG4gICAgICAgICAganVzdGlmeUNvbnRlbnQ9XCJjZW50ZXJcIlxuICAgICAgICA+XG4gICAgICAgICAge2luaXRpYWx9XG4gICAgICAgIDwvQm94PlxuICAgICAgKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gR3JvdXBBdmF0YXIocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHsgY29sbGFib3JhdG9ycywgb3V0bGluZSwgc2l6ZSB9ID0gcHJvcHM7XG4gIGNvbnN0IGF2YXRhcldpZHRoID0gc2l6ZSA/IEFWQVRBUl9TSVpFU1tzaXplXSA6ICcxMDAlJztcbiAgY29uc3QgYXZhdGFySGVpZ2h0ID0gc2l6ZSA/IEFWQVRBUl9TSVpFU1tzaXplXSA6ICcnO1xuICBjb25zdCBwb3NpdGlvbnMgPSBhdmF0YXJMYXlvdXQoY29sbGFib3JhdG9ycy5sZW5ndGgsIGF2YXRhcldpZHRoKTtcbiAgcmV0dXJuIChcbiAgICA8Qm94XG4gICAgICBjb2xvcj1cIndoaXRlXCJcbiAgICAgIG92ZXJmbG93PVwiaGlkZGVuXCJcbiAgICAgIHNoYXBlPVwiY2lyY2xlXCJcbiAgICAgIHdpZHRoPXthdmF0YXJXaWR0aH1cbiAgICAgIGhlaWdodD17YXZhdGFySGVpZ2h0fVxuICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7XG4gICAgICAgIF9fc3R5bGU6IHtcbiAgICAgICAgICAuLi4ob3V0bGluZSA/IHsgYm94U2hhZG93OiAnMCAwIDAgMnB4ICNmZmYnIH0gOiB7fSksXG4gICAgICAgICAgLy8gd2lsbENoYW5nZTogdHJhbnNmb3JtIGZpeGVzIGEgc3RyYW5nZSBiZWhhdmlvciB3aGVyZSB0aGUgYm9yZGVyIG9mIHRoZSBjaGlsZHJlblxuICAgICAgICAgIC8vIGFyZSBub3QgcHJvcGVybHkgdHJpbW1lZCBldmVuIHRob3VnaCBvdmVyZmxvdzogaGlkZGVuIGlzIHNldFxuICAgICAgICAgIHdpbGxDaGFuZ2U6ICd0cmFuc2Zvcm0nLFxuICAgICAgICB9LFxuICAgICAgfX1cbiAgICA+XG4gICAgICA8Qm94IGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3sgX19zdHlsZTogeyBwYWRkaW5nQm90dG9tOiAnMTAwJScgfSB9fSAvPlxuICAgICAge3ppcChwb3NpdGlvbnMsIGNvbGxhYm9yYXRvcnMpLm1hcChcbiAgICAgICAgKFtwb3NpdGlvbiwgY29sbGFib3JhdG9yID0geyBuYW1lOiAnJywgc3JjOiB1bmRlZmluZWQgfV0sIGlkeCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgdG9wLCBsZWZ0LCB0ZXh0TGF5b3V0IH0gPSBwb3NpdGlvbjtcbiAgICAgICAgICBjb25zdCB7IG5hbWUsIHNyYyB9ID0gY29sbGFib3JhdG9yO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8Qm94XG4gICAgICAgICAgICAgIGtleT17aWR4fVxuICAgICAgICAgICAgICBwb3NpdGlvbj1cImFic29sdXRlXCJcbiAgICAgICAgICAgICAgd2lkdGg9e3dpZHRofVxuICAgICAgICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17eyBfX3N0eWxlOiB7IHRvcCwgbGVmdCB9IH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtzcmMgPyAoXG4gICAgICAgICAgICAgICAgPEltYWdlXG4gICAgICAgICAgICAgICAgICBhbHQ9e25hbWV9XG4gICAgICAgICAgICAgICAgICBjb2xvcj1cIiNFRkVGRUZcIlxuICAgICAgICAgICAgICAgICAgc3JjPXtzcmN9XG4gICAgICAgICAgICAgICAgICBuYXR1cmFsV2lkdGg9ezF9XG4gICAgICAgICAgICAgICAgICBuYXR1cmFsSGVpZ2h0PXsxfVxuICAgICAgICAgICAgICAgICAgZml0PVwiY292ZXJcIlxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgPERlZmF1bHRBdmF0YXJcbiAgICAgICAgICAgICAgICAgIG5hbWU9e25hbWV9XG4gICAgICAgICAgICAgICAgICB0ZXh0TGF5b3V0PXt0ZXh0TGF5b3V0fVxuICAgICAgICAgICAgICAgICAgc2l6ZT17aGVpZ2h0fVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMud2FzaH0gLz5cbiAgICAgICAgICAgIDwvQm94PlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICl9XG4gICAgPC9Cb3g+XG4gICk7XG59XG5cbkdyb3VwQXZhdGFyLnByb3BUeXBlcyA9IHtcbiAgY29sbGFib3JhdG9yczogUHJvcFR5cGVzLmFycmF5T2YoXG4gICAgUHJvcFR5cGVzLmV4YWN0KHtcbiAgICAgIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICAgIHNyYzogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB9KVxuICApLmlzUmVxdWlyZWQsXG4gIG91dGxpbmU6IFByb3BUeXBlcy5ib29sLFxuICBzaXplOiBQcm9wVHlwZXMub25lT2YoWydzbScsICdtZCcsICdsZyddKSxcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjeCBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBjb2xvcnMgZnJvbSAnLi9Db2xvcnMuY3NzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9IZWFkaW5nLmNzcyc7XG5pbXBvcnQgdHlwb2dyYXBoeSBmcm9tICcuL1R5cG9ncmFwaHkuY3NzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGFjY2Vzc2liaWxpdHlMZXZlbD86IDEgfCAyIHwgMyB8IDQgfCA1IHwgNixcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICBjb2xvcj86XG4gICAgfCAnYmx1ZSdcbiAgICB8ICdkYXJrR3JheSdcbiAgICB8ICdlZ2dwbGFudCdcbiAgICB8ICdncmF5J1xuICAgIHwgJ2dyZWVuJ1xuICAgIHwgJ2xpZ2h0R3JheSdcbiAgICB8ICdtYXJvb24nXG4gICAgfCAnbWlkbmlnaHQnXG4gICAgfCAnbmF2eSdcbiAgICB8ICdvbGl2ZSdcbiAgICB8ICdvcmFuZ2UnXG4gICAgfCAnb3JjaGlkJ1xuICAgIHwgJ3BpbmUnXG4gICAgfCAncHVycGxlJ1xuICAgIHwgJ3JlZCdcbiAgICB8ICd3YXRlcm1lbG9uJ1xuICAgIHwgJ3doaXRlJyxcbiAgaWQ/OiBzdHJpbmcsXG4gIGxnU2l6ZT86ICd4cycgfCAnc20nIHwgJ21kJyB8ICdsZycgfCAneGwnLFxuICBtZFNpemU/OiAneHMnIHwgJ3NtJyB8ICdtZCcgfCAnbGcnIHwgJ3hsJyxcbiAgb3ZlcmZsb3c/OiAnbm9ybWFsJyB8ICdicmVha1dvcmQnLFxuICBzaXplPzogJ3hzJyB8ICdzbScgfCAnbWQnIHwgJ2xnJyB8ICd4bCcsXG4gIHNtU2l6ZT86ICd4cycgfCAnc20nIHwgJ21kJyB8ICdsZycgfCAneGwnLFxuICB0cnVuY2F0ZT86IGJvb2xlYW4sXG58fTtcblxuY29uc3QgZGVmYXVsdEhlYWRpbmdMZXZlbHMgPSB7XG4gIHhzOiA1LFxuICBzbTogNCxcbiAgbWQ6IDMsXG4gIGxnOiAyLFxuICB4bDogMSxcbn07XG5cbmNvbnN0IFNJWkVfU0NBTEU6IHsgW3NpemU6ID9zdHJpbmddOiBudW1iZXIgfSA9IHtcbiAgeHM6IDEsXG4gIHNtOiAyLFxuICBtZDogMyxcbiAgbGc6IDQsXG4gIHhsOiA1LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSGVhZGluZyhwcm9wczogUHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGFjY2Vzc2liaWxpdHlMZXZlbCxcbiAgICBjaGlsZHJlbixcbiAgICBjb2xvciA9ICdkYXJrR3JheScsXG4gICAgaWQgPSBudWxsLFxuICAgIGxnU2l6ZSxcbiAgICBtZFNpemUsXG4gICAgb3ZlcmZsb3cgPSAnYnJlYWtXb3JkJyxcbiAgICBzaXplID0gJ21kJyxcbiAgICBzbVNpemUsXG4gICAgdHJ1bmNhdGUgPSBmYWxzZSxcbiAgfSA9IHByb3BzO1xuXG4gIGNvbnN0IGNzID0gY3goXG4gICAgc3R5bGVzLkhlYWRpbmcsXG4gICAgc3R5bGVzW2Bmb250U2l6ZSR7U0laRV9TQ0FMRVtzaXplXX1gXSxcbiAgICBzbVNpemUgJiYgc3R5bGVzW2BzbUZvbnRTaXplJHtTSVpFX1NDQUxFW3NtU2l6ZV19YF0sXG4gICAgbWRTaXplICYmIHN0eWxlc1tgbWRGb250U2l6ZSR7U0laRV9TQ0FMRVttZFNpemVdfWBdLFxuICAgIGxnU2l6ZSAmJiBzdHlsZXNbYGxnRm9udFNpemUke1NJWkVfU0NBTEVbbGdTaXplXX1gXSxcbiAgICBjb2xvcnNbY29sb3JdLFxuICAgIG92ZXJmbG93ID09PSAnYnJlYWtXb3JkJyAmJiB0eXBvZ3JhcGh5LmJyZWFrV29yZCxcbiAgICB0cnVuY2F0ZSAmJiB0eXBvZ3JhcGh5LnRydW5jYXRlXG4gICk7XG5cbiAgY29uc3QgaGVhZGluZ0xldmVsID0gYWNjZXNzaWJpbGl0eUxldmVsIHx8IGRlZmF1bHRIZWFkaW5nTGV2ZWxzW3NpemVdO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBgaCR7aGVhZGluZ0xldmVsfWAsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBjcyxcbiAgICAgIGlkLFxuICAgICAgLi4uKHRydW5jYXRlICYmIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZydcbiAgICAgICAgPyB7IHRpdGxlOiBjaGlsZHJlbiB9XG4gICAgICAgIDogbnVsbCksXG4gICAgfSxcbiAgICBjaGlsZHJlblxuICApO1xufVxuXG5IZWFkaW5nLnByb3BUeXBlcyA9IHtcbiAgYWNjZXNzaWJpbGl0eUxldmVsOiBQcm9wVHlwZXMub25lT2YoWzEsIDIsIDMsIDQsIDUsIDZdKSxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnYmx1ZScsXG4gICAgJ2RhcmtHcmF5JyxcbiAgICAnZWdncGxhbnQnLFxuICAgICdncmF5JyxcbiAgICAnZ3JlZW4nLFxuICAgICdsaWdodEdyYXknLFxuICAgICdtYXJvb24nLFxuICAgICdtaWRuaWdodCcsXG4gICAgJ25hdnknLFxuICAgICdvbGl2ZScsXG4gICAgJ29yYW5nZScsXG4gICAgJ29yY2hpZCcsXG4gICAgJ3BpbmUnLFxuICAgICdwdXJwbGUnLFxuICAgICdyZWQnLFxuICAgICd3YXRlcm1lbG9uJyxcbiAgICAnd2hpdGUnLFxuICBdKSxcbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIG92ZXJmbG93OiBQcm9wVHlwZXMub25lT2YoWydub3JtYWwnLCAnYnJlYWtXb3JkJ10pLFxuICBzaXplOiBQcm9wVHlwZXMub25lT2YoWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddKSxcbiAgc21TaXplOiBQcm9wVHlwZXMub25lT2YoWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddKSxcbiAgbWRTaXplOiBQcm9wVHlwZXMub25lT2YoWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddKSxcbiAgbGdTaXplOiBQcm9wVHlwZXMub25lT2YoWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddKSxcbiAgdHJ1bmNhdGU6IFByb3BUeXBlcy5ib29sLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5qcyc7XG5pbXBvcnQgaWNvbnMgZnJvbSAnLi9pY29ucy9pbmRleC5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vUG9nLmNzcyc7XG5cbmNvbnN0IFNJWkVfTkFNRV9UT19QSVhFTCA9IHtcbiAgeHM6IDI0LFxuICBzbTogMzIsXG4gIG1kOiA0MCxcbiAgbGc6IDQ4LFxuICB4bDogNTYsXG59O1xuXG50eXBlIFByb3BzID0ge3xcbiAgYWN0aXZlPzogYm9vbGVhbixcbiAgYmdDb2xvcj86ICd0cmFuc3BhcmVudCcgfCAnbGlnaHRHcmF5JyB8ICd3aGl0ZScsXG4gIGZvY3VzZWQ/OiBib29sZWFuLFxuICBob3ZlcmVkPzogYm9vbGVhbixcbiAgaWNvbkNvbG9yPzogJ2dyYXknIHwgJ2RhcmtHcmF5JyB8ICdyZWQnIHwgJ2JsdWUnIHwgJ3doaXRlJyxcbiAgaWNvbjogJEtleXM8dHlwZW9mIGljb25zPixcbiAgc2l6ZT86ICRLZXlzPHR5cGVvZiBTSVpFX05BTUVfVE9fUElYRUw+LFxufH07XG5cbmNvbnN0IGRlZmF1bHRJY29uQnV0dG9uSWNvbkNvbG9ycyA9IHtcbiAgdHJhbnNwYXJlbnQ6ICdncmF5JyxcbiAgbGlnaHRHcmF5OiAnZ3JheScsXG4gIHdoaXRlOiAnZ3JheScsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQb2cocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBhY3RpdmUgPSBmYWxzZSxcbiAgICBiZ0NvbG9yID0gJ3RyYW5zcGFyZW50JyxcbiAgICBmb2N1c2VkID0gZmFsc2UsXG4gICAgaG92ZXJlZCA9IGZhbHNlLFxuICAgIGljb25Db2xvciA9IGRlZmF1bHRJY29uQnV0dG9uSWNvbkNvbG9yc1tiZ0NvbG9yXSxcbiAgICBpY29uLFxuICAgIHNpemUgPSAnbWQnLFxuICB9ID0gcHJvcHM7XG5cbiAgY29uc3QgaWNvblNpemUgPSBTSVpFX05BTUVfVE9fUElYRUxbc2l6ZV0gLyAyO1xuXG4gIGNvbnN0IGlubGluZVN0eWxlID0ge1xuICAgIGhlaWdodDogU0laRV9OQU1FX1RPX1BJWEVMW3NpemVdLFxuICAgIHdpZHRoOiBTSVpFX05BTUVfVE9fUElYRUxbc2l6ZV0sXG4gIH07XG5cbiAgY29uc3QgY2xhc3NlcyA9IGNsYXNzbmFtZXMoc3R5bGVzLnBvZywgc3R5bGVzW2JnQ29sb3JdLCB7XG4gICAgW3N0eWxlcy5hY3RpdmVdOiBhY3RpdmUsXG4gICAgW3N0eWxlcy5mb2N1c2VkXTogZm9jdXNlZCxcbiAgICBbc3R5bGVzLmhvdmVyZWRdOiBob3ZlcmVkICYmICFmb2N1c2VkICYmICFhY3RpdmUsXG4gIH0pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzZXN9IHN0eWxlPXtpbmxpbmVTdHlsZX0+XG4gICAgICA8Qm94IHNoYXBlPVwiY2lyY2xlXCI+XG4gICAgICAgIHsvKlxuICAgICAgICAgIFdlJ3JlIGV4cGxpY2l0bHkgc2V0dGluZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSBsYWJlbCBvbiB0aGUgSWNvbiBzaW5jZSB3ZVxuICAgICAgICAgIGFscmVhZHkgaGF2ZSBhbiBhcmlhLWxhYmVsIG9uIHRoZSBidXR0b24gY29udGFpbmVyLlxuICAgICAgICAgIFRoaXMgaXMgc2ltaWxhciB0byBoYXZpbmcgZW1wdHkgYGFsdGAgYXR0cmlidXRlczpcbiAgICAgICAgICBodHRwczovL2Rhdmlkd2Fsc2gubmFtZS9hY2Nlc3NpYmlsaXR5LXRpcC1lbXB0eS1hbHQtYXR0cmlidXRlc1xuICAgICAgICAqL31cbiAgICAgICAgPEljb25cbiAgICAgICAgICBjb2xvcj17aWNvbkNvbG9yfVxuICAgICAgICAgIGljb249e2ljb259XG4gICAgICAgICAgc2l6ZT17aWNvblNpemV9XG4gICAgICAgICAgYWNjZXNzaWJpbGl0eUxhYmVsPVwiXCJcbiAgICAgICAgLz5cbiAgICAgIDwvQm94PlxuICAgIDwvZGl2PlxuICApO1xufVxuXG5Qb2cucHJvcFR5cGVzID0ge1xuICBhY3RpdmU6IFByb3BUeXBlcy5ib29sLFxuICBiZ0NvbG9yOiBQcm9wVHlwZXMub25lT2YoWyd0cmFuc3BhcmVudCcsICdsaWdodEdyYXknLCAnd2hpdGUnXSksXG4gIGZvY3VzZWQ6IFByb3BUeXBlcy5ib29sLFxuICBob3ZlcmVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgaWNvbkNvbG9yOiBQcm9wVHlwZXMub25lT2YoWydncmF5JywgJ2RhcmtHcmF5JywgJ3JlZCcsICdibHVlJywgJ3doaXRlJ10pLFxuICBpY29uOiBQcm9wVHlwZXMub25lT2YoT2JqZWN0LmtleXMoaWNvbnMpKS5pc1JlcXVpcmVkLFxuICBzaXplOiBQcm9wVHlwZXMub25lT2YoT2JqZWN0LmtleXMoU0laRV9OQU1FX1RPX1BJWEVMKSksXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vSWNvbkJ1dHRvbi5jc3MnO1xuaW1wb3J0IGljb25zIGZyb20gJy4vaWNvbnMvaW5kZXguanMnO1xuaW1wb3J0IFBvZyBmcm9tICcuL1BvZy5qcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY2Nlc3NpYmlsaXR5RXhwYW5kZWQ/OiBib29sZWFuLFxuICBhY2Nlc3NpYmlsaXR5SGFzcG9wdXA/OiBib29sZWFuLFxuICBhY2Nlc3NpYmlsaXR5TGFiZWw6IHN0cmluZyxcbiAgYmdDb2xvcj86ICd0cmFuc3BhcmVudCcgfCAnbGlnaHRHcmF5JyB8ICd3aGl0ZScsXG4gIGljb25Db2xvcj86ICdncmF5JyB8ICdkYXJrR3JheScgfCAncmVkJyB8ICdibHVlJyB8ICd3aGl0ZScsXG4gIGljb246ICRLZXlzPHR5cGVvZiBpY29ucz4sXG4gIG9uQ2xpY2s/OiAoeyBldmVudDogU3ludGhldGljTW91c2VFdmVudDw+IH0pID0+IHZvaWQsXG4gIHNpemU/OiAneHMnIHwgJ3NtJyB8ICdtZCcgfCAnbGcnIHwgJ3hsJyxcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgYWN0aXZlOiBib29sZWFuLFxuICBmb2N1c2VkOiBib29sZWFuLFxuICBob3ZlcmVkOiBib29sZWFuLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEljb25CdXR0b24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgYWNjZXNzaWJpbGl0eUV4cGFuZGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBhY2Nlc3NpYmlsaXR5SGFzcG9wdXA6IFByb3BUeXBlcy5ib29sLFxuICAgIGFjY2Vzc2liaWxpdHlMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGJnQ29sb3I6IFByb3BUeXBlcy5vbmVPZihbJ3RyYW5zcGFyZW50JywgJ2xpZ2h0R3JheScsICd3aGl0ZSddKSxcbiAgICBpY29uOiBQcm9wVHlwZXMub25lT2YoT2JqZWN0LmtleXMoaWNvbnMpKS5pc1JlcXVpcmVkLFxuICAgIGljb25Db2xvcjogUHJvcFR5cGVzLm9uZU9mKFsnZ3JheScsICdkYXJrR3JheScsICdyZWQnLCAnYmx1ZScsICd3aGl0ZSddKSxcbiAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBzaXplOiBQcm9wVHlwZXMub25lT2YoWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddKSxcbiAgfTtcblxuICBzdGF0ZTogU3RhdGUgPSB7XG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBmb2N1c2VkOiBmYWxzZSxcbiAgICBob3ZlcmVkOiBmYWxzZSxcbiAgfTtcblxuICBoYW5kbGVCbHVyID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWQ6IGZhbHNlIH0pO1xuXG4gIGhhbmRsZUZvY3VzID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBmb2N1c2VkOiB0cnVlIH0pO1xuICB9O1xuXG4gIGhhbmRsZU1vdXNlRG93biA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHsgYWN0aXZlOiB0cnVlIH0pO1xuICB9O1xuXG4gIGhhbmRsZU1vdXNlRW50ZXIgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGhvdmVyZWQ6IHRydWUgfSk7XG4gIH07XG5cbiAgaGFuZGxlTW91c2VMZWF2ZSA9ICgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICBob3ZlcmVkOiBmYWxzZSxcbiAgICB9KTtcbiAgfTtcblxuICBoYW5kbGVNb3VzZVVwID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBhY3RpdmU6IGZhbHNlIH0pO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBhY2Nlc3NpYmlsaXR5RXhwYW5kZWQsXG4gICAgICBhY2Nlc3NpYmlsaXR5SGFzcG9wdXAsXG4gICAgICBhY2Nlc3NpYmlsaXR5TGFiZWwsXG4gICAgICBiZ0NvbG9yLFxuICAgICAgaWNvbkNvbG9yLFxuICAgICAgaWNvbixcbiAgICAgIHNpemUsXG4gICAgICBvbkNsaWNrLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgeyBhY3RpdmUsIGZvY3VzZWQsIGhvdmVyZWQgfSA9IHRoaXMuc3RhdGU7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGJ1dHRvblxuICAgICAgICBhcmlhLWV4cGFuZGVkPXthY2Nlc3NpYmlsaXR5RXhwYW5kZWR9XG4gICAgICAgIGFyaWEtaGFzcG9wdXA9e2FjY2Vzc2liaWxpdHlIYXNwb3B1cH1cbiAgICAgICAgYXJpYS1sYWJlbD17YWNjZXNzaWJpbGl0eUxhYmVsfVxuICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5idXR0b259XG4gICAgICAgIG9uQmx1cj17dGhpcy5oYW5kbGVCbHVyfVxuICAgICAgICBvbkNsaWNrPXtldmVudCA9PiBvbkNsaWNrICYmIG9uQ2xpY2soeyBldmVudCB9KX1cbiAgICAgICAgb25Gb2N1cz17dGhpcy5oYW5kbGVGb2N1c31cbiAgICAgICAgb25Nb3VzZURvd249e3RoaXMuaGFuZGxlTW91c2VEb3dufVxuICAgICAgICBvbk1vdXNlRW50ZXI9e3RoaXMuaGFuZGxlTW91c2VFbnRlcn1cbiAgICAgICAgb25Nb3VzZUxlYXZlPXt0aGlzLmhhbmRsZU1vdXNlTGVhdmV9XG4gICAgICAgIG9uTW91c2VVcD17dGhpcy5oYW5kbGVNb3VzZVVwfVxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgID5cbiAgICAgICAgPFBvZ1xuICAgICAgICAgIGFjdGl2ZT17YWN0aXZlfVxuICAgICAgICAgIGJnQ29sb3I9e2JnQ29sb3J9XG4gICAgICAgICAgZm9jdXNlZD17Zm9jdXNlZH1cbiAgICAgICAgICBob3ZlcmVkPXtob3ZlcmVkfVxuICAgICAgICAgIGljb25Db2xvcj17aWNvbkNvbG9yfVxuICAgICAgICAgIGljb249e2ljb259XG4gICAgICAgICAgc2l6ZT17c2l6ZX1cbiAgICAgICAgLz5cbiAgICAgIDwvYnV0dG9uPlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL0xhYmVsLmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG4gIGh0bWxGb3I6IHN0cmluZyxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMYWJlbChwcm9wczogUHJvcHMpIHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgaHRtbEZvciB9ID0gcHJvcHM7XG5cbiAgcmV0dXJuIChcbiAgICA8bGFiZWwgY2xhc3NOYW1lPXtzdHlsZXMubGFiZWx9IGh0bWxGb3I9e2h0bWxGb3J9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvbGFiZWw+XG4gICk7XG59XG5cbkxhYmVsLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBodG1sRm9yOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHM+IHtcbiAgY29uc3RydWN0b3IocHJvcHM6IFByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZWwpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgIH1cbiAgfVxuXG4gIGVsOiBIVE1MRGl2RWxlbWVudDtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wcztcbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCB0aGlzLmVsKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgTWFzayBmcm9tICcuL01hc2suanMnO1xuXG4vKlxuICBNdWNoIG9mIHRoZSBtYXRoIGFuZCB1bmRlcnN0YW5kaW5nIGFib3V0IHRoaXMgY29tcG9uZW50IGNvbWVzIGZyb20gQHZqZWF1eCdzXG4gIGV4Y2VsbGVudCBibG9nIHBvc3Qgb24gaW1hZ2UgcmVzaXppbmcuXG5cbiAgaHR0cDovL2Jsb2cudmpldXguY29tLzIwMTMvaW1hZ2UvY3NzLWNvbnRhaW5lci1hbmQtY292ZXIuaHRtbFxuXG4gIEkgaGlnaGx5IHJlY29tbWVuZCB5b3UgcmVhZCB0aGF0IGZpcnN0IGJlZm9yZSBjb250aW51aW5nIG9uIHJlYWRpbmcuXG4qL1xuXG5jb25zdCBhc3BlY3RSYXRpbyA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB3aWR0aCAvIGhlaWdodDtcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgY29udGVudEFzcGVjdFJhdGlvOiBudW1iZXIsXG4gIGhlaWdodDogbnVtYmVyLFxuICB3aWR0aDogbnVtYmVyLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExldHRlcmJveCh7XG4gIGNoaWxkcmVuLFxuICBjb250ZW50QXNwZWN0UmF0aW8sXG4gIGhlaWdodCxcbiAgd2lkdGgsXG59OiBQcm9wcykge1xuICBjb25zdCB2aWV3cG9ydEFzcGVjdFJhdGlvID0gYXNwZWN0UmF0aW8od2lkdGgsIGhlaWdodCk7XG5cbiAgbGV0IGNvbnRlbnRIZWlnaHQ7XG4gIGxldCBjb250ZW50V2lkdGg7XG5cbiAgaWYgKGNvbnRlbnRBc3BlY3RSYXRpbyA8IHZpZXdwb3J0QXNwZWN0UmF0aW8pIHtcbiAgICBjb250ZW50V2lkdGggPSB3aWR0aDtcbiAgICBjb250ZW50SGVpZ2h0ID0gd2lkdGggLyBjb250ZW50QXNwZWN0UmF0aW87XG4gIH0gZWxzZSB7XG4gICAgY29udGVudFdpZHRoID0gaGVpZ2h0ICogY29udGVudEFzcGVjdFJhdGlvO1xuICAgIGNvbnRlbnRIZWlnaHQgPSBoZWlnaHQ7XG4gIH1cblxuICBjb25zdCBvZmZzZXRUb3AgPSAoY29udGVudEhlaWdodCAtIGhlaWdodCkgLyAtMjtcbiAgY29uc3Qgb2Zmc2V0TGVmdCA9IChjb250ZW50V2lkdGggLSB3aWR0aCkgLyAtMjtcblxuICByZXR1cm4gKFxuICAgIDxNYXNrIHdpZHRoPXt3aWR0aH0gaGVpZ2h0PXtoZWlnaHR9PlxuICAgICAgPGRpdiBzdHlsZT17eyBtYXJnaW5Ub3A6IG9mZnNldFRvcCwgbWFyZ2luTGVmdDogb2Zmc2V0TGVmdCB9fT5cbiAgICAgICAgPE1hc2sgd2lkdGg9e2NvbnRlbnRXaWR0aH0gaGVpZ2h0PXtjb250ZW50SGVpZ2h0fT5cbiAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvTWFzaz5cbiAgICAgIDwvZGl2PlxuICAgIDwvTWFzaz5cbiAgKTtcbn1cblxuTGV0dGVyYm94LnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBjb250ZW50QXNwZWN0UmF0aW86IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vTGluay5jc3MnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICBocmVmOiBzdHJpbmcsXG4gIGlubGluZT86IGJvb2xlYW4sXG4gIG9uQ2xpY2s/OiAoeyBldmVudDogU3ludGhldGljTW91c2VFdmVudDw+IH0pID0+IHZvaWQsXG4gIHRhcmdldD86IG51bGwgfCAnc2VsZicgfCAnYmxhbmsnLFxufH07XG5cbnR5cGUgU3RhdGUgPSB7fFxuICBlbmFibGVGb2N1c1N0eWxlczogYm9vbGVhbixcbnx9O1xuXG5jb25zdCBUQUJfS0VZX0NPREUgPSA5O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5rIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZS5pc1JlcXVpcmVkLFxuICAgIGhyZWY6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBpbmxpbmU6IFByb3BUeXBlcy5ib29sLFxuICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jLFxuICAgIHRhcmdldDogUHJvcFR5cGVzLm9uZU9mKFtudWxsLCAnc2VsZicsICdibGFuayddKSxcbiAgfTtcblxuICBzdGF0ZTogU3RhdGUgPSB7XG4gICAgZW5hYmxlRm9jdXNTdHlsZXM6IHRydWUsXG4gIH07XG5cbiAgaGFuZGxlQ2xpY2sgPSAoZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8PikgPT4ge1xuICAgIGNvbnN0IHsgaHJlZiwgb25DbGljayB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAob25DbGljayAmJiBocmVmKSB7XG4gICAgICBvbkNsaWNrKHsgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZU1vdXNlRG93biA9ICgpID0+IHtcbiAgICBjb25zdCB7IGhyZWYsIHRhcmdldCB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAodGFyZ2V0ID09PSAnYmxhbmsnICYmIGhyZWYpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBlbmFibGVGb2N1c1N0eWxlczogZmFsc2UgfSk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZUtleVVwID0gKGV2ZW50OiBTeW50aGV0aWNLZXlib2FyZEV2ZW50PD4pID0+IHtcbiAgICBjb25zdCB7IGhyZWYsIHRhcmdldCB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAodGFyZ2V0ID09PSAnYmxhbmsnICYmIGV2ZW50LmtleUNvZGUgPT09IFRBQl9LRVlfQ09ERSAmJiBocmVmKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZW5hYmxlRm9jdXNTdHlsZXM6IHRydWUgfSk7XG4gICAgfVxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBpbmxpbmUgPSBmYWxzZSwgdGFyZ2V0ID0gbnVsbCwgaHJlZiB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCByZWwgPSB0YXJnZXQgPT09ICdibGFuaycgPyAnbm9vcGVuZXIgbm9yZWZlcnJlcicgOiBudWxsO1xuICAgIGNvbnN0IGxpbmtUYXJnZXQgPSB0YXJnZXQgPyBgXyR7dGFyZ2V0fWAgOiBudWxsO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxhXG4gICAgICAgIGNsYXNzTmFtZT17Y3goXG4gICAgICAgICAgc3R5bGVzLmxpbmssXG4gICAgICAgICAgdGhpcy5zdGF0ZS5lbmFibGVGb2N1c1N0eWxlcyA/IHN0eWxlcy5hY2Nlc3NpYmxlRm9jdXNTdHlsZSA6ICcnLFxuICAgICAgICAgIGlubGluZSA/ICcnIDogc3R5bGVzLmJsb2NrXG4gICAgICAgICl9XG4gICAgICAgIGhyZWY9e2hyZWZ9XG4gICAgICAgIG9uTW91c2VEb3duPXt0aGlzLmhhbmRsZU1vdXNlRG93bn1cbiAgICAgICAgb25LZXlVcD17dGhpcy5oYW5kbGVLZXlVcH1cbiAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja31cbiAgICAgICAgcmVsPXtyZWx9XG4gICAgICAgIHRhcmdldD17bGlua1RhcmdldH1cbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9hPlxuICAgICk7XG4gIH1cbn1cbiIsIi8qKlxuICogZGVib3VuY2UgcHJldmVudHMgYSBwYXJ0aWN1bGFyIGZ1bmN0aW9uIGZyb20gYmVpbmcgY2FsbGVkIHVudGlsIGFmdGVyIGEgZ2l2ZW5cbiAqIGNvb2xkb3duIHBlcmlvZCAoZGVmYXVsdCAxMDBtcykuIEV2ZXJ5IHRpbWUgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCwgaXQgcmVzZXRzXG4gKiB0aGUgY29vbGRvd24uXG4gKi9cblxuLy8gQGZsb3dcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlYm91bmNlKFxuICBmbjogKC4uLmFyZ3M6ICopID0+IHZvaWQsXG4gIHRocmVzaGhvbGQ6IG51bWJlciA9IDEwMFxuKSB7XG4gIGxldCBkZWZlclRpbWVyOiBUaW1lb3V0SUQgfCBudWxsID0gbnVsbDtcblxuICBjb25zdCBkZWJvdW5jZWQgPSAoLi4uYXJnczogKikgPT4ge1xuICAgIGlmIChkZWZlclRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZGVmZXJUaW1lcik7XG4gICAgfVxuXG4gICAgZGVmZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZGVmZXJUaW1lciA9IG51bGw7XG4gICAgICBmbiguLi5hcmdzKTtcbiAgICB9LCB0aHJlc2hob2xkKTtcbiAgfTtcblxuICBkZWJvdW5jZWQuY2xlYXJUaW1lb3V0ID0gKCkgPT4ge1xuICAgIGlmIChkZWZlclRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZGVmZXJUaW1lcik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG4iLCIvKipcbiAqIEZldGNoSXRlbXMgaXMgYSBsb2dpYyBjb21wb25lbnQgdGhhdCByZW5kZXJzIG5vIGNvbnRlbnQgaXRzZWxmLiBJdHMgam9iXG4gKiBpcyB0byBtYW5hZ2Ugd2hlbiB0aGUgZ2l2ZW4gZmV0Y2hNb3JlIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGJhc2VkIG9uXG4gKiB0aGUgZ2l2ZW4gc2Nyb2xsL3NpemUgcHJvcHMuXG4gKlxuICogV2hpbGUgbm8gZWxlbWVudCBpcyBhY3R1YWxseSBwYXNzZWQgdG8gRmV0Y2hJdGVtcywgaXQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZFxuICogaW4gY29uanVuY3Rpb24gd2l0aCBhIGxhcmdlIHNjcm9sbCBjb250YWluZXIgdGhhdCB1c2VzIGFzeW5jIGZldGNoaW5nIHRvXG4gKiBsb2FkIGFuZCByZW5kZXIgYWRkaXRpb25hbCBkYXRhLiBCYXNlZCBvbiB0aGUgaGVpZ2h0IG9mIHRoaXMgY29udGFpbmVyIGFuZFxuICogaXRzIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uLCBGZXRjaEl0ZW1zIGlzIHJlc3BvbnNpYmxlIGZvciB0cmlnZ2VyaW5nIGZ1dHVyZVxuICogZmV0Y2ggY2FsbHMuXG4gKi9cblxuLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIGNvbnRhaW5lckhlaWdodDogbnVtYmVyLFxuICBpc0F0RW5kPzogYm9vbGVhbixcbiAgaXNGZXRjaGluZzogYm9vbGVhbixcbiAgZmV0Y2hNb3JlPzogKCkgPT4gdm9pZCxcbiAgc2Nyb2xsSGVpZ2h0OiBudW1iZXIsXG4gIHNjcm9sbFRvcDogbnVtYmVyLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmV0Y2hJdGVtcyBleHRlbmRzIFJlYWN0LlB1cmVDb21wb25lbnQ8UHJvcHM+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBjb250YWluZXJIZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICBpc0F0RW5kOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBpc0ZldGNoaW5nOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAgIGZldGNoTW9yZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgc2Nyb2xsSGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgc2Nyb2xsVG9wOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIH07XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgc2V0VGltZW91dCh0aGlzLmNoZWNrKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB0aGlzLmNoZWNrKCk7XG4gIH1cblxuICBjaGVjayA9ICgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXJIZWlnaHQsXG4gICAgICBpc0F0RW5kLFxuICAgICAgaXNGZXRjaGluZyxcbiAgICAgIGZldGNoTW9yZSxcbiAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgIHNjcm9sbFRvcCxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChpc0F0RW5kIHx8IGlzRmV0Y2hpbmcgfHwgIWZldGNoTW9yZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzY3JvbGxCdWZmZXIgPSBjb250YWluZXJIZWlnaHQgKiAzO1xuXG4gICAgaWYgKHNjcm9sbFRvcCArIHNjcm9sbEJ1ZmZlciA+IHNjcm9sbEhlaWdodCkge1xuICAgICAgZmV0Y2hNb3JlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuIiwiLyoqXG4gKiBTY3JvbGxDb250YWluZXIgaXMgYSBwYXNzLXRocm91Z2ggY29tcG9uZW50IHRoYXQgc2ltcGx5IHNldHMgdXAgYW4gb25TY3JvbGxcbiAqIGhhbmRsZXIgb24gdGhlIGdpdmVuIHNjcm9sbENvbnRhaW5lciBlbGVtZW50IChvciB0aGUgZWxlbWVudCB0aGF0IGlzXG4gKiByZXR1cm5lZCBhcyByZXN1bHQgb2YgY2FsbGluZyB0aGUgc2Nyb2xsQ29udGFpbmVyIG1ldGhvZCkuIFRoaXMgYWxsb3dzIGZvclxuICogdGhlIGV2ZW50IGxpc3RlbmVyIHN1YnNjcmlwdGlvbiBvZiB0aGUgc2Nyb2xsQ29udGFpbmVyIHRvIGJlIG1hbmFnZWQgaW5zaWRlXG4gKiB0aGUgUmVhY3QgbGlmZWN5Y2xlIHdpdGhvdXQgYWRkaW5nIGJsb2F0IHRvIE1hc29ucnkgb3Igb3RoZXIgb25TY3JvbGxcbiAqIHN1YnNjcmliZXJzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIENvbXBvbmVudCByZW5kZXJzIGl0cyBjaGlsZHJlbiB3aXRob3V0IGNyZWF0aW5nIGFueVxuICogYWRkaXRpb25hbCBjb250ZW50LiBBbHNvIG5vdGUgdGhhdCwgd2hpbGUgdGhlIGNvbXBvbmVudCBpcyBidWlsdCB0byBtYW5hZ2VcbiAqIG9uU2Nyb2xsIGluc2lkZSBvZiB0aGUgUmVhY3QgbGlmZWN5Y2xlLCBpdCBkb2Vzbid0IGNoYW5nZSBvblNjcm9sbCBldmVudHNcbiAqIG9yIHRoZSBBUEkgYXQgYWxsLCBzbyBpdCBjb3VsZCBlYXNpbHkgYmUgYWRhcHRlZCB0byBvdGhlciBldmVudCB0eXBlcy5cbiAqL1xuXG4vLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgb25TY3JvbGw6IChldmVudDogRXZlbnQpID0+IHZvaWQsXG4gIHNjcm9sbENvbnRhaW5lcjogP0hUTUxFbGVtZW50IHwgKCgpID0+ID9IVE1MRWxlbWVudCksXG58fTtcblxuZnVuY3Rpb24gZ2V0U2Nyb2xsQ29udGFpbmVyKHNjcm9sbENvbnRhaW5lcikge1xuICByZXR1cm4gdHlwZW9mIHNjcm9sbENvbnRhaW5lciA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2Nyb2xsQ29udGFpbmVyKClcbiAgICA6IHNjcm9sbENvbnRhaW5lcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsQ29udGFpbmVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLmlzUmVxdWlyZWQsXG4gICAgb25TY3JvbGw6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgc2Nyb2xsQ29udGFpbmVyOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuZnVuY10pXG4gICAgICAuaXNSZXF1aXJlZCxcbiAgfTtcblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBjb25zdCBzY3JvbGxDb250YWluZXIgPSBnZXRTY3JvbGxDb250YWluZXIodGhpcy5wcm9wcy5zY3JvbGxDb250YWluZXIpO1xuICAgIGlmIChzY3JvbGxDb250YWluZXIpIHtcbiAgICAgIHRoaXMudXBkYXRlU2Nyb2xsQ29udGFpbmVyKHNjcm9sbENvbnRhaW5lcik7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIGNvbnN0IG5leHRTY3JvbGxDb250YWluZXIgPSBnZXRTY3JvbGxDb250YWluZXIodGhpcy5wcm9wcy5zY3JvbGxDb250YWluZXIpO1xuICAgIGlmIChuZXh0U2Nyb2xsQ29udGFpbmVyICYmIG5leHRTY3JvbGxDb250YWluZXIgIT09IHRoaXMuc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLnVwZGF0ZVNjcm9sbENvbnRhaW5lcihuZXh0U2Nyb2xsQ29udGFpbmVyKTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5zY3JvbGxDb250YWluZXIpIHtcbiAgICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgICB9XG4gIH1cblxuICBnZXRTY3JvbGxDb250YWluZXJSZWYgPSAoKSA9PiB0aGlzLnNjcm9sbENvbnRhaW5lcjtcblxuICBoYW5kbGVTY3JvbGwgPSAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgdGhpcy5wcm9wcy5vblNjcm9sbChldmVudCk7XG4gIH07XG5cbiAgdXBkYXRlU2Nyb2xsQ29udGFpbmVyKHNjcm9sbENvbnRhaW5lcjogSFRNTEVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5zY3JvbGxDb250YWluZXIpIHtcbiAgICAgIC8vIGNsZWFudXAgZXhpc3Rpbmcgc2Nyb2xsIGNvbnRhaW5lciBpZiBpdCBleGlzdHNcbiAgICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgICB9XG4gICAgdGhpcy5zY3JvbGxDb250YWluZXIgPSBzY3JvbGxDb250YWluZXI7XG4gICAgdGhpcy5zY3JvbGxDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwpO1xuICB9XG5cbiAgc2Nyb2xsQ29udGFpbmVyOiA/SFRNTEVsZW1lbnQ7XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9XG59XG4iLCIvKipcbiAqIHRocm90dGxlIGxpbWl0cyB0aGUgbnVtYmVyIG9mIHRpbWVzIGEgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCB0byBhXG4gKiBnaXZlbiB0aHJlc2hob2xkICgxMDBtcyBieSBkZWZhdWx0KS4gVGhlIGZ1bmN0aW9uIGlzIGFsd2F5cyBjYWxsZWRcbiAqIG9uIHRoZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBlZGdlLlxuICovXG5cbi8vIEBmbG93XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0aHJvdHRsZShcbiAgZm46ICguLi5hcmdzOiAqKSA9PiB2b2lkLFxuICB0aHJlc2hob2xkOiBudW1iZXIgPSAxMDBcbikge1xuICBsZXQgbGFzdDogbnVtYmVyIHwgdm9pZDtcbiAgbGV0IGRlZmVyVGltZXI6IFRpbWVvdXRJRCB8IHZvaWQ7XG4gIGNvbnN0IHRocm90dGxlZCA9ICguLi5hcmdzOiAqKSA9PiB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAobGFzdCAhPT0gdW5kZWZpbmVkICYmIG5vdyAtIGxhc3QgPCB0aHJlc2hob2xkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZGVmZXJUaW1lcik7XG4gICAgICBkZWZlclRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGxhc3QgPSBub3c7XG4gICAgICAgIGZuKC4uLmFyZ3MpO1xuICAgICAgfSwgdGhyZXNoaG9sZCAtIChub3cgLSBsYXN0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBub3c7XG4gICAgICBmbiguLi5hcmdzKTtcbiAgICB9XG4gIH07XG5cbiAgdGhyb3R0bGVkLmNsZWFyVGltZW91dCA9ICgpID0+IHtcbiAgICBpZiAoZGVmZXJUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KGRlZmVyVGltZXIpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhyb3R0bGVkO1xufVxuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgQ2FjaGUgfSBmcm9tICcuL0NhY2hlLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVhc3VyZW1lbnRTdG9yZTxULCBWPiBpbXBsZW1lbnRzIENhY2hlPFQsIFY+IHtcbiAgbWFwOiBXZWFrTWFwPFQsIFY+ID0gbmV3IFdlYWtNYXAoKTtcblxuICBnZXQoa2V5OiBUKTogP1Yge1xuICAgIHJldHVybiB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgfVxuXG4gIGhhcyhrZXk6IFQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzKGtleSk7XG4gIH1cblxuICBzZXQoa2V5OiBULCB2YWx1ZTogVik6IHZvaWQge1xuICAgIHRoaXMubWFwLnNldChrZXksIHZhbHVlKTtcbiAgfVxuXG4gIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMubWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBNZWFzdXJpbmcgc2Nyb2xsIHBvc2l0aW9ucywgZWxlbWVudCBoZWlnaHRzLCBldGMgaXMgZGlmZmVyZW50IGJldHdlZW5cbiAqIGRpZmZlcmVudCBicm93c2VycyBhbmQgdGhlIHdpbmRvdyBvYmplY3QgdnMgb3RoZXIgRE9NIG5vZGVzLiBUaGVzZVxuICogdXRpbHMgYWJzdHJhY3QgYXdheSB0aGVzZSBkaWZmZXJlbmNlcy5cbiAqL1xuXG4vLyBAZmxvd1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnRIZWlnaHQoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBudW1iZXIge1xuICByZXR1cm4gZWxlbWVudCA9PT0gd2luZG93ID8gd2luZG93LmlubmVySGVpZ2h0IDogZWxlbWVudC5jbGllbnRIZWlnaHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxQb3MoKSB7XG4gIGlmICh3aW5kb3cuc2Nyb2xsWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gTW9kZXJuIGJyb3dzZXJcbiAgICByZXR1cm4gd2luZG93LnNjcm9sbFk7XG4gIH1cbiAgaWYgKFxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJlxuICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICAvLyBJRSBzdXBwb3J0LlxuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVsYXRpdmVTY3JvbGxUb3AoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBudW1iZXIge1xuICByZXR1cm4gZWxlbWVudCA9PT0gd2luZG93XG4gICAgPyBnZXRXaW5kb3dTY3JvbGxQb3MoKVxuICAgIDogZWxlbWVudC5zY3JvbGxUb3AgLSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjcm9sbEhlaWdodChlbGVtZW50OiBIVE1MRWxlbWVudCk6IG51bWJlciB7XG4gIHJldHVybiBlbGVtZW50ID09PSB3aW5kb3cgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG4gICAgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0XG4gICAgOiBlbGVtZW50LnNjcm9sbEhlaWdodDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjcm9sbFBvcyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IG51bWJlciB7XG4gIHJldHVybiBlbGVtZW50ID09PSB3aW5kb3cgPyBnZXRXaW5kb3dTY3JvbGxQb3MoKSA6IGVsZW1lbnQuc2Nyb2xsVG9wO1xufVxuIiwiLy8gQGZsb3dcbmV4cG9ydCBjb25zdCBEZWZhdWx0TGF5b3V0U3ltYm9sID0gU3ltYm9sKCdkZWZhdWx0Jyk7XG5leHBvcnQgY29uc3QgVW5pZm9ybVJvd0xheW91dFN5bWJvbCA9IFN5bWJvbCgndW5pZm9ybVJvdycpO1xuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgQ2FjaGUgfSBmcm9tICcuL0NhY2hlLmpzJztcblxudHlwZSBQb3NpdGlvbiA9IHsgdG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfTtcblxuY29uc3QgbWluZGV4ID0gYXJyID0+IHtcbiAgbGV0IGlkeCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGFycltpXSA8IGFycltpZHhdKSB7XG4gICAgICBpZHggPSBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaWR4O1xufTtcblxuY29uc3Qgb2Zmc2NyZWVuID0gKHdpZHRoLCBoZWlnaHQgPSBJbmZpbml0eSkgPT4gKHtcbiAgdG9wOiAtOTk5OSxcbiAgbGVmdDogLTk5OTksXG4gIHdpZHRoLFxuICBoZWlnaHQsXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgPFQ+KHtcbiAgY2FjaGUsXG4gIGNvbHVtbldpZHRoID0gMjM2LFxuICBndXR0ZXIgPSAxNCxcbiAgbWluQ29scyA9IDIsXG4gIHdpZHRoLFxufToge3xcbiAgY29sdW1uV2lkdGg/OiBudW1iZXIsXG4gIGd1dHRlcj86IG51bWJlcixcbiAgY2FjaGU6IENhY2hlPFQsIG51bWJlcj4sXG4gIG1pbkNvbHM/OiBudW1iZXIsXG4gIHdpZHRoPzogP251bWJlcixcbnx9KSA9PiAoaXRlbXM6IEFycmF5PCo+KTogQXJyYXk8UG9zaXRpb24+ID0+IHtcbiAgaWYgKHdpZHRoID09IG51bGwpIHtcbiAgICByZXR1cm4gaXRlbXMubWFwKCgpID0+IG9mZnNjcmVlbihjb2x1bW5XaWR0aCkpO1xuICB9XG5cbiAgY29uc3QgY29sdW1uV2lkdGhBbmRHdXR0ZXIgPSBjb2x1bW5XaWR0aCArIGd1dHRlcjtcbiAgY29uc3QgY29sdW1uQ291bnQgPSBNYXRoLm1heChcbiAgICBNYXRoLmZsb29yKCh3aWR0aCArIGd1dHRlcikgLyBjb2x1bW5XaWR0aEFuZEd1dHRlciksXG4gICAgbWluQ29sc1xuICApO1xuICAvLyB0aGUgdG90YWwgaGVpZ2h0IG9mIGVhY2ggY29sdW1uXG4gIGNvbnN0IGhlaWdodHMgPSBuZXcgQXJyYXkoY29sdW1uQ291bnQpLmZpbGwoMCk7XG4gIGNvbnN0IGNlbnRlck9mZnNldCA9IE1hdGgubWF4KFxuICAgIE1hdGguZmxvb3IoKHdpZHRoIC0gY29sdW1uV2lkdGhBbmRHdXR0ZXIgKiBjb2x1bW5Db3VudCArIGd1dHRlcikgLyAyKSxcbiAgICAwXG4gICk7XG5cbiAgcmV0dXJuIGl0ZW1zLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgY29uc3QgcG9zaXRpb25zID0gYWNjO1xuICAgIC8vICRGbG93Rml4TWVcbiAgICBjb25zdCBoZWlnaHQgPSBjYWNoZS5nZXQoaXRlbSk7XG4gICAgbGV0IHBvc2l0aW9uO1xuXG4gICAgaWYgKGhlaWdodCA9PSBudWxsKSB7XG4gICAgICBwb3NpdGlvbiA9IG9mZnNjcmVlbihjb2x1bW5XaWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlaWdodEFuZEd1dHRlciA9IGhlaWdodCArIGd1dHRlcjtcbiAgICAgIGNvbnN0IGNvbCA9IG1pbmRleChoZWlnaHRzKTtcbiAgICAgIGNvbnN0IHRvcCA9IGhlaWdodHNbY29sXTtcbiAgICAgIGNvbnN0IGxlZnQgPSBjb2wgKiBjb2x1bW5XaWR0aEFuZEd1dHRlciArIGNlbnRlck9mZnNldDtcblxuICAgICAgaGVpZ2h0c1tjb2xdICs9IGhlaWdodEFuZEd1dHRlcjtcbiAgICAgIHBvc2l0aW9uID0geyB0b3AsIGxlZnQsIHdpZHRoOiBjb2x1bW5XaWR0aCwgaGVpZ2h0IH07XG4gICAgfVxuICAgIHBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uKTtcbiAgICByZXR1cm4gcG9zaXRpb25zO1xuICB9LCBbXSk7XG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCB0eXBlIHsgQ2FjaGUgfSBmcm9tICcuL0NhY2hlLmpzJztcblxudHlwZSBQb3NpdGlvbiA9IHsgdG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfTtcblxuY29uc3Qgb2Zmc2NyZWVuID0gKHdpZHRoLCBoZWlnaHQgPSBJbmZpbml0eSkgPT4gKHtcbiAgdG9wOiAtOTk5OSxcbiAgbGVmdDogLTk5OTksXG4gIHdpZHRoLFxuICBoZWlnaHQsXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgPFQ+KHtcbiAgY2FjaGUsXG4gIGNvbHVtbldpZHRoID0gMjM2LFxuICBndXR0ZXIgPSAxNCxcbiAgd2lkdGgsXG4gIG1pbkNvbHMgPSAzLFxufToge3xcbiAgY2FjaGU6IENhY2hlPFQsIG51bWJlcj4sXG4gIGNvbHVtbldpZHRoPzogbnVtYmVyLFxuICBndXR0ZXI/OiBudW1iZXIsXG4gIHdpZHRoPzogP251bWJlcixcbiAgbWluQ29scz86IG51bWJlcixcbnx9KSA9PiAoaXRlbXM6IEFycmF5PFQ+KTogQXJyYXk8UG9zaXRpb24+ID0+IHtcbiAgaWYgKHdpZHRoID09IG51bGwpIHtcbiAgICByZXR1cm4gaXRlbXMubWFwKCgpID0+IG9mZnNjcmVlbihjb2x1bW5XaWR0aCkpO1xuICB9XG5cbiAgY29uc3QgY29sdW1uV2lkdGhBbmRHdXR0ZXIgPSBjb2x1bW5XaWR0aCArIGd1dHRlcjtcbiAgY29uc3QgY29sdW1uQ291bnQgPSBNYXRoLm1heChcbiAgICBNYXRoLmZsb29yKCh3aWR0aCArIGd1dHRlcikgLyBjb2x1bW5XaWR0aEFuZEd1dHRlciksXG4gICAgbWluQ29sc1xuICApO1xuXG4gIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xuICBjb25zdCBoZWlnaHRzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGxldCBwb3NpdGlvbjtcbiAgICBjb25zdCBoZWlnaHQgPSBjYWNoZS5nZXQoaXRlbXNbaV0pO1xuXG4gICAgaWYgKGhlaWdodCA9PSBudWxsKSB7XG4gICAgICBwb3NpdGlvbiA9IG9mZnNjcmVlbihjb2x1bW5XaWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IGkgJSBjb2x1bW5Db3VudDtcbiAgICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IoaSAvIGNvbHVtbkNvdW50KTtcblxuICAgICAgaWYgKGNvbHVtbiA9PT0gMCB8fCBoZWlnaHQgPiBoZWlnaHRzW3Jvd10pIHtcbiAgICAgICAgaGVpZ2h0c1tyb3ddID0gaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b3AgPVxuICAgICAgICByb3cgPiAwXG4gICAgICAgICAgPyBoZWlnaHRzLnNsaWNlKDAsIHJvdykucmVkdWNlKChzdW0sIHkpID0+IHN1bSArIHkgKyBndXR0ZXIsIDApXG4gICAgICAgICAgOiAwO1xuXG4gICAgICBwb3NpdGlvbiA9IHtcbiAgICAgICAgdG9wLFxuICAgICAgICBsZWZ0OiBjb2x1bW4gKiBjb2x1bW5XaWR0aEFuZEd1dHRlcixcbiAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICB9O1xuICAgIH1cbiAgICBwb3NpdGlvbnMucHVzaChwb3NpdGlvbik7XG4gIH1cbiAgcmV0dXJuIHBvc2l0aW9ucztcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0IHR5cGUgeyBDYWNoZSB9IGZyb20gJy4vQ2FjaGUuanMnO1xuXG50eXBlIFBvc2l0aW9uID0geyB0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9O1xuXG5jb25zdCBtaW5kZXggPSBhcnIgPT4ge1xuICBsZXQgaWR4ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoYXJyW2ldIDwgYXJyW2lkeF0pIHtcbiAgICAgIGlkeCA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpZHg7XG59O1xuXG5leHBvcnQgZGVmYXVsdCA8VD4oe1xuICBndXR0ZXIgPSAwLFxuICBjYWNoZSxcbiAgbWluQ29scyA9IDIsXG4gIGlkZWFsQ29sdW1uV2lkdGggPSAyNDAsXG4gIHdpZHRoLFxufToge3xcbiAgZ3V0dGVyPzogbnVtYmVyLFxuICBjYWNoZTogQ2FjaGU8VCwgbnVtYmVyPixcbiAgbWluQ29scz86IG51bWJlcixcbiAgaWRlYWxDb2x1bW5XaWR0aD86IG51bWJlcixcbiAgd2lkdGg/OiA/bnVtYmVyLFxufH0pID0+IHtcbiAgaWYgKHdpZHRoID09IG51bGwpIHtcbiAgICByZXR1cm4gKGl0ZW1zOiBBcnJheTxtaXhlZD4pOiBBcnJheTxQb3NpdGlvbj4gPT5cbiAgICAgIGl0ZW1zLm1hcCgoKSA9PiAoe1xuICAgICAgICB0b3A6IEluZmluaXR5LFxuICAgICAgICBsZWZ0OiBJbmZpbml0eSxcbiAgICAgICAgd2lkdGg6IEluZmluaXR5LFxuICAgICAgICBoZWlnaHQ6IEluZmluaXR5LFxuICAgICAgfSkpO1xuICB9XG5cbiAgLy8gXCJUaGlzIGlzIGtpbmQgb2YgY3JhenkhXCIgLSB5b3VcbiAgLy8gWWVzLCBpbmRlZWQuIFRoZSBcImd1ZXNzaW5nXCIgaGVyZSBpcyBtZWFudCB0byByZXBsaWNhdGUgdGhlIHBhc3MgdGhhdCB0aGVcbiAgLy8gb3JpZ2luYWwgaW1wbGVtZW50YXRpb24gdGFrZXMgd2l0aCBDU1MuXG4gIGNvbnN0IGNvbGd1ZXNzID0gTWF0aC5mbG9vcih3aWR0aCAvIGlkZWFsQ29sdW1uV2lkdGgpO1xuICBjb25zdCBjb2x1bW5Db3VudCA9IE1hdGgubWF4KFxuICAgIE1hdGguZmxvb3IoKHdpZHRoIC0gY29sZ3Vlc3MgKiBndXR0ZXIpIC8gaWRlYWxDb2x1bW5XaWR0aCksXG4gICAgbWluQ29sc1xuICApO1xuICBjb25zdCBjb2x1bW5XaWR0aCA9IE1hdGguZmxvb3Iod2lkdGggLyBjb2x1bW5Db3VudCk7XG5cbiAgcmV0dXJuIChpdGVtczogQXJyYXk8VD4pID0+IHtcbiAgICAvLyB0aGUgdG90YWwgaGVpZ2h0IG9mIGVhY2ggY29sdW1uXG4gICAgY29uc3QgaGVpZ2h0cyA9IG5ldyBBcnJheShjb2x1bW5Db3VudCkuZmlsbCgwKTtcblxuICAgIHJldHVybiBpdGVtcy5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgY29uc3QgcG9zaXRpb25zID0gYWNjO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gY2FjaGUuZ2V0KGl0ZW0pO1xuICAgICAgbGV0IHBvc2l0aW9uO1xuXG4gICAgICBpZiAoaGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgcG9zaXRpb24gPSB7XG4gICAgICAgICAgdG9wOiBJbmZpbml0eSxcbiAgICAgICAgICBsZWZ0OiBJbmZpbml0eSxcbiAgICAgICAgICB3aWR0aDogY29sdW1uV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBJbmZpbml0eSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbCA9IG1pbmRleChoZWlnaHRzKTtcbiAgICAgICAgY29uc3QgdG9wID0gaGVpZ2h0c1tjb2xdO1xuICAgICAgICBjb25zdCBsZWZ0ID0gY29sICogY29sdW1uV2lkdGggKyBndXR0ZXIgLyAyO1xuXG4gICAgICAgIGhlaWdodHNbY29sXSArPSBoZWlnaHQ7XG4gICAgICAgIHBvc2l0aW9uID0ge1xuICAgICAgICAgIHRvcCxcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHdpZHRoOiBjb2x1bW5XaWR0aCAtIGd1dHRlcixcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiBwb3NpdGlvbnM7XG4gICAgfSwgW10pO1xuICB9O1xufTtcbiIsIi8vIEBmbG93XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXNvbnJ5TGF5b3V0IHt9XG4iLCIvLyBAZmxvd1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVW5pZm9ybVJvd0xheW91dCB7fVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnLi9kZWJvdW5jZS5qcyc7XG5pbXBvcnQgRmV0Y2hJdGVtcyBmcm9tICcuL0ZldGNoSXRlbXMuanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL01hc29ucnkuY3NzJztcbmltcG9ydCBTY3JvbGxDb250YWluZXIgZnJvbSAnLi9TY3JvbGxDb250YWluZXIuanMnO1xuaW1wb3J0IHRocm90dGxlIGZyb20gJy4vdGhyb3R0bGUuanMnO1xuaW1wb3J0IHR5cGUgeyBDYWNoZSB9IGZyb20gJy4vQ2FjaGUuanMnO1xuaW1wb3J0IE1lYXN1cmVtZW50U3RvcmUgZnJvbSAnLi9NZWFzdXJlbWVudFN0b3JlLmpzJztcbmltcG9ydCB7XG4gIGdldEVsZW1lbnRIZWlnaHQsXG4gIGdldFJlbGF0aXZlU2Nyb2xsVG9wLFxuICBnZXRTY3JvbGxQb3MsXG59IGZyb20gJy4vc2Nyb2xsVXRpbHMuanMnO1xuaW1wb3J0IHtcbiAgRGVmYXVsdExheW91dFN5bWJvbCxcbiAgVW5pZm9ybVJvd0xheW91dFN5bWJvbCxcbn0gZnJvbSAnLi9sZWdhY3lMYXlvdXRTeW1ib2xzLmpzJztcbmltcG9ydCBkZWZhdWx0TGF5b3V0IGZyb20gJy4vZGVmYXVsdExheW91dC5qcyc7XG5pbXBvcnQgdW5pZm9ybVJvd0xheW91dCBmcm9tICcuL3VuaWZvcm1Sb3dMYXlvdXQuanMnO1xuaW1wb3J0IGZ1bGxXaWR0aExheW91dCBmcm9tICcuL2Z1bGxXaWR0aExheW91dC5qcyc7XG5pbXBvcnQgTGVnYWN5TWFzb25yeUxheW91dCBmcm9tICcuL2xheW91dHMvTWFzb25yeUxheW91dC5qcyc7XG5pbXBvcnQgTGVnYWN5VW5pZm9ybVJvd0xheW91dCBmcm9tICcuL2xheW91dHMvVW5pZm9ybVJvd0xheW91dC5qcyc7XG5cbnR5cGUgTGF5b3V0ID1cbiAgfCB0eXBlb2YgRGVmYXVsdExheW91dFN5bWJvbFxuICB8IHR5cGVvZiBVbmlmb3JtUm93TGF5b3V0U3ltYm9sXG4gIHwgTGVnYWN5TWFzb25yeUxheW91dFxuICB8IExlZ2FjeVVuaWZvcm1Sb3dMYXlvdXQ7XG5cbnR5cGUgUHJvcHM8VD4gPSB7fFxuICBjb2x1bW5XaWR0aD86IG51bWJlcixcbiAgY29tcDogUmVhY3QuQ29tcG9uZW50VHlwZTx7XG4gICAgZGF0YTogVCxcbiAgICBpdGVtSWR4OiBudW1iZXIsXG4gICAgaXNNZWFzdXJpbmc6IGJvb2xlYW4sXG4gIH0+LFxuICBmbGV4aWJsZT86IGJvb2xlYW4sXG4gIGd1dHRlcldpZHRoPzogbnVtYmVyLFxuICBpdGVtczogQXJyYXk8VD4sXG4gIG1lYXN1cmVtZW50U3RvcmU6IENhY2hlPFQsICo+LFxuICBtaW5Db2xzOiBudW1iZXIsXG4gIGxheW91dD86IExheW91dCxcbiAgLy8gU3VwcG9ydCBsZWdhY3kgbG9hZEl0ZW1zIHVzYWdlLlxuICAvLyBUT0RPOiBTaW1wbGlmeSBub24gZmFsc2V5IGZsb3d0eXBlLlxuICBsb2FkSXRlbXM/OlxuICAgIHwgZmFsc2VcbiAgICB8ICgoXG4gICAgICAgID97XG4gICAgICAgICAgZnJvbTogbnVtYmVyLFxuICAgICAgICB9XG4gICAgICApID0+IHZvaWQgfCBib29sZWFuIHwge30pLFxuICBzY3JvbGxDb250YWluZXI/OiAoKSA9PiBIVE1MRWxlbWVudCxcbiAgdmlydHVhbEJvdW5kc1RvcD86IG51bWJlcixcbiAgdmlydHVhbEJvdW5kc0JvdHRvbT86IG51bWJlcixcbiAgdmlydHVhbGl6ZT86IGJvb2xlYW4sXG58fTtcblxudHlwZSBTdGF0ZTxUPiA9IHt8XG4gIGhhc1BlbmRpbmdNZWFzdXJlbWVudHM6IGJvb2xlYW4sXG4gIGlzRmV0Y2hpbmc6IGJvb2xlYW4sXG4gIGl0ZW1zOiBBcnJheTxUPixcbiAgc2Nyb2xsVG9wOiBudW1iZXIsXG4gIHdpZHRoOiA/bnVtYmVyLFxufH07XG5cbmNvbnN0IFJFU0laRV9ERUJPVU5DRSA9IDMwMDtcbi8vIE11bHRpcGxpZWQgYWdhaW5zdCBjb250YWluZXIgaGVpZ2h0LlxuLy8gVGhlIGFtb3VudCBvZiBleHRyYSBidWZmZXIgc3BhY2UgZm9yIHBvcHVsYXRpbmcgdmlzaWJsZSBpdGVtcy5cbmNvbnN0IFZJUlRVQUxfQlVGRkVSX0ZBQ1RPUiA9IDAuNztcblxuY29uc3QgbGF5b3V0TnVtYmVyVG9Dc3NEaW1lbnNpb24gPSBuID0+IChuICE9PSBJbmZpbml0eSA/IG4gOiB1bmRlZmluZWQpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXNvbnJ5PFQ+IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzPFQ+LCBTdGF0ZTxUPj4ge1xuICBzdGF0aWMgY3JlYXRlTWVhc3VyZW1lbnRTdG9yZSgpIHtcbiAgICByZXR1cm4gbmV3IE1lYXN1cmVtZW50U3RvcmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxheXMgcmVzaXplIGhhbmRsaW5nIGluIGNhc2UgdGhlIHNjcm9sbCBjb250YWluZXIgaXMgc3RpbGwgYmVpbmcgcmVzaXplZC5cbiAgICovXG4gIGhhbmRsZVJlc2l6ZSA9IGRlYm91bmNlKCgpID0+IHtcbiAgICBpZiAodGhpcy5ncmlkV3JhcHBlcikge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IHdpZHRoOiB0aGlzLmdyaWRXcmFwcGVyLmNsaWVudFdpZHRoIH0pO1xuICAgIH1cbiAgfSwgUkVTSVpFX0RFQk9VTkNFKTtcblxuICB1cGRhdGVTY3JvbGxQb3NpdGlvbiA9IHRocm90dGxlKCgpID0+IHtcbiAgICBpZiAoIXRoaXMuc2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lciA9IHRoaXMuc2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbENvbnRhaW5lclJlZigpO1xuXG4gICAgaWYgKCFzY3JvbGxDb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNjcm9sbFRvcDogZ2V0U2Nyb2xsUG9zKHNjcm9sbENvbnRhaW5lciksXG4gICAgfSk7XG4gIH0pO1xuXG4gIG1lYXN1cmVDb250YWluZXJBc3luYyA9IGRlYm91bmNlKCgpID0+IHtcbiAgICB0aGlzLm1lYXN1cmVDb250YWluZXIoKTtcbiAgfSwgMCk7XG5cbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJlZmVycmVkL3RhcmdldCBpdGVtIHdpZHRoLiBJZiBgZmxleGlibGVgIGlzIHNldCwgdGhlIGl0ZW0gd2lkdGggd2lsbFxuICAgICAqIGdyb3cgdG8gZmlsbCBjb2x1bW4gc3BhY2UsIGFuZCBzaHJpbmsgdG8gZml0IGlmIGJlbG93IG1pbiBjb2x1bW5zLlxuICAgICAqL1xuICAgIGNvbHVtbldpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNvbXBvbmVudCB0byByZW5kZXIuXG4gICAgICovXG4gICAgLyogZXNsaW50IHJlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzOiAwICovXG4gICAgY29tcDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmVmZXJyZWQvdGFyZ2V0IGl0ZW0gd2lkdGguIEl0ZW0gd2lkdGggd2lsbCBncm93IHRvIGZpbGxcbiAgICAgKiBjb2x1bW4gc3BhY2UsIGFuZCBzaHJpbmsgdG8gZml0IGlmIGJlbG93IG1pbiBjb2x1bW5zLlxuICAgICAqL1xuICAgIGZsZXhpYmxlOiBQcm9wVHlwZXMuYm9vbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBhbW91bnQgb2Ygc3BhY2UgYmV0d2VlbiBlYWNoIGl0ZW0uXG4gICAgICovXG4gICAgZ3V0dGVyV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBhbGwgb2JqZWN0cyB0byBkaXNwbGF5IGluIHRoZSBncmlkLlxuICAgICAqL1xuICAgIGl0ZW1zOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuc2hhcGUoe30pKS5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogTWVhc3VyZW1lbnQgU3RvcmVcbiAgICAgKi9cbiAgICBtZWFzdXJlbWVudFN0b3JlOiBQcm9wVHlwZXMuaW5zdGFuY2VPZihNZWFzdXJlbWVudFN0b3JlKSxcblxuICAgIC8qKlxuICAgICAqIExheW91dCBzeXN0ZW0gdG8gdXNlIGZvciBpdGVtc1xuICAgICAqL1xuICAgIGxheW91dDogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICBQcm9wVHlwZXMuaW5zdGFuY2VPZihMZWdhY3lNYXNvbnJ5TGF5b3V0KSxcbiAgICAgIFByb3BUeXBlcy5pbnN0YW5jZU9mKExlZ2FjeVVuaWZvcm1Sb3dMYXlvdXQpLFxuICAgICAgUHJvcFR5cGVzLnN5bWJvbCxcbiAgICBdKSxcblxuICAgIC8qKlxuICAgICAqIEEgY2FsbGJhY2sgd2hpY2ggdGhlIGdyaWQgY2FsbHMgd2hlbiB3ZSBuZWVkIHRvIGxvYWQgbW9yZSBpdGVtcyBhcyB0aGUgdXNlciBzY3JvbGxzLlxuICAgICAqIFRoZSBjYWxsYmFjayBzaG91bGQgdXBkYXRlIHRoZSBzdGF0ZSBvZiB0aGUgaXRlbXMsIGFuZCBwYXNzIHRob3NlIGluIGFzIHByb3BzXG4gICAgICogdG8gdGhpcyBjb21wb25lbnQuXG4gICAgICovXG4gICAgbG9hZEl0ZW1zOiBQcm9wVHlwZXMuZnVuYyxcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gbnVtYmVyIG9mIGNvbHVtbnMgdG8gZGlzcGxheS5cbiAgICAgKi9cbiAgICBtaW5Db2xzOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCB0aGUgZ3JpZCBjYWxscyB0byBnZXQgdGhlIHNjcm9sbCBjb250YWluZXIuXG4gICAgICogVGhpcyBpcyByZXF1aXJlZCBpZiB0aGUgZ3JpZCBpcyBleHBlY3RlZCB0byBiZSBzY3JvbGxhYmxlLlxuICAgICAqL1xuICAgIHNjcm9sbENvbnRhaW5lcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0byB1c2UgYWN0dWFsIHZpcnR1YWxpemF0aW9uXG4gICAgICovXG4gICAgdmlydHVhbGl6ZTogUHJvcFR5cGVzLmJvb2wsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBjb2x1bW5XaWR0aDogMjM2LFxuICAgIG1lYXN1cmVtZW50U3RvcmU6IG5ldyBNZWFzdXJlbWVudFN0b3JlKCksXG4gICAgbWluQ29sczogMyxcbiAgICBsYXlvdXQ6IERlZmF1bHRMYXlvdXRTeW1ib2wsXG4gICAgbG9hZEl0ZW1zOiAoKSA9PiB7fSxcbiAgICB2aXJ0dWFsaXplOiBmYWxzZSxcbiAgfTtcblxuICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvcHM8VD4pIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLmNvbnRhaW5lckhlaWdodCA9IDA7XG4gICAgdGhpcy5jb250YWluZXJPZmZzZXQgPSAwO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHM6IHByb3BzLml0ZW1zLnNvbWUoXG4gICAgICAgIGl0ZW0gPT4gISFpdGVtICYmICFwcm9wcy5tZWFzdXJlbWVudFN0b3JlLmhhcyhpdGVtKVxuICAgICAgKSxcbiAgICAgIGlzRmV0Y2hpbmc6IGZhbHNlLFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLXVudXNlZC1zdGF0ZVxuICAgICAgaXRlbXM6IHByb3BzLml0ZW1zLFxuICAgICAgc2Nyb2xsVG9wOiAwLFxuICAgICAgd2lkdGg6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgaG9va3MgYWZ0ZXIgdGhlIGNvbXBvbmVudCBtb3VudHMuXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVSZXNpemUpO1xuXG4gICAgdGhpcy5tZWFzdXJlQ29udGFpbmVyKCk7XG5cbiAgICBsZXQgeyBzY3JvbGxUb3AgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHRoaXMuc2Nyb2xsQ29udGFpbmVyICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHNjcm9sbENvbnRhaW5lciA9IHRoaXMuc2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbENvbnRhaW5lclJlZigpO1xuICAgICAgaWYgKHNjcm9sbENvbnRhaW5lcikge1xuICAgICAgICBzY3JvbGxUb3AgPSBnZXRTY3JvbGxQb3Moc2Nyb2xsQ29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHByZXZTdGF0ZSA9PiAoe1xuICAgICAgc2Nyb2xsVG9wLFxuICAgICAgd2lkdGg6IHRoaXMuZ3JpZFdyYXBwZXIgPyB0aGlzLmdyaWRXcmFwcGVyLmNsaWVudFdpZHRoIDogcHJldlN0YXRlLndpZHRoLFxuICAgIH0pKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IFByb3BzPFQ+LCBwcmV2U3RhdGU6IFN0YXRlPFQ+KSB7XG4gICAgY29uc3QgeyBpdGVtcywgbWVhc3VyZW1lbnRTdG9yZSB9ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMubWVhc3VyZUNvbnRhaW5lckFzeW5jKCk7XG5cbiAgICBpZiAocHJldlN0YXRlLndpZHRoICE9IG51bGwgJiYgdGhpcy5zdGF0ZS53aWR0aCAhPT0gcHJldlN0YXRlLndpZHRoKSB7XG4gICAgICBtZWFzdXJlbWVudFN0b3JlLnJlc2V0KCk7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSB3aGV0aGVyIHdlIHN0aWxsIGhhdmUgcGVuZGluZyBtZWFzdXJlbWVudHNcbiAgICBjb25zdCBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzID0gaXRlbXMuc29tZShcbiAgICAgIGl0ZW0gPT4gISFpdGVtICYmICFtZWFzdXJlbWVudFN0b3JlLmhhcyhpdGVtKVxuICAgICk7XG4gICAgaWYgKFxuICAgICAgaGFzUGVuZGluZ01lYXN1cmVtZW50cyB8fFxuICAgICAgaGFzUGVuZGluZ01lYXN1cmVtZW50cyAhPT0gdGhpcy5zdGF0ZS5oYXNQZW5kaW5nTWVhc3VyZW1lbnRzIHx8XG4gICAgICBwcmV2U3RhdGUud2lkdGggPT0gbnVsbFxuICAgICkge1xuICAgICAgdGhpcy5pbnNlcnRBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBsaXN0ZW5lcnMgd2hlbiB1bm1vdW50aW5nLlxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuaW5zZXJ0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuaW5zZXJ0QW5pbWF0aW9uRnJhbWUpO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBhc3luYyBtZXRob2RzIGFyZSBjYW5jZWxsZWQuXG4gICAgdGhpcy5tZWFzdXJlQ29udGFpbmVyQXN5bmMuY2xlYXJUaW1lb3V0KCk7XG4gICAgdGhpcy5oYW5kbGVSZXNpemUuY2xlYXJUaW1lb3V0KCk7XG4gICAgdGhpcy51cGRhdGVTY3JvbGxQb3NpdGlvbi5jbGVhclRpbWVvdXQoKTtcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzOiBQcm9wczxUPiwgc3RhdGU6IFN0YXRlPFQ+KSB7XG4gICAgY29uc3QgeyBpdGVtcywgbWVhc3VyZW1lbnRTdG9yZSB9ID0gcHJvcHM7XG4gICAgLy8gd2hlbmV2ZXIgd2UncmUgcmVjZWl2aW5nIG5ldyBwcm9wcywgZGV0ZXJtaW5lIHdoZXRoZXIgYW55IGl0ZW1zIG5lZWQgdG8gYmUgbWVhc3VyZWRcbiAgICAvLyBUT0RPIC0gd2Ugc2hvdWxkIHRyZWF0IGl0ZW1zIGFzIGltbXV0YWJsZVxuICAgIGNvbnN0IGhhc1BlbmRpbmdNZWFzdXJlbWVudHMgPSBpdGVtcy5zb21lKFxuICAgICAgaXRlbSA9PiAhbWVhc3VyZW1lbnRTdG9yZS5oYXMoaXRlbSlcbiAgICApO1xuXG4gICAgLy8gU2hhbGxvdyBjb21wYXJlIGFsbCBpdGVtcywgaWYgYW55IGNoYW5nZSByZWZsb3cgdGhlIGdyaWQuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIG91ciBjdXJyZW50IHByb3BzIGFuZCBldmVyeXRoaW5nIG1hdGNoZXMuXG4gICAgICAvLyBJZiB3ZSBoaXQgdGhpcyBjYXNlIGl0IG1lYW5zIHdlIG5lZWQgdG8gaW5zZXJ0IG5ldyBpdGVtcy5cbiAgICAgIGlmIChzdGF0ZS5pdGVtc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGFzUGVuZGluZ01lYXN1cmVtZW50cyxcbiAgICAgICAgICBpdGVtcyxcbiAgICAgICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzZXQgZ3JpZCBpdGVtcyB3aGVuOlxuICAgICAgaWYgKFxuICAgICAgICAvLyBBbiBpdGVtIG9iamVjdCByZWYgZG9lcyBub3QgbWF0Y2guXG4gICAgICAgIGl0ZW1zW2ldICE9PSBzdGF0ZS5pdGVtc1tpXSB8fFxuICAgICAgICAvLyBPciBsZXNzIGl0ZW1zIHRoYW4gd2UgY3VycmVudGx5IGhhdmUgYXJlIHBhc3NlZCBpbi5cbiAgICAgICAgaXRlbXMubGVuZ3RoIDwgc3RhdGUuaXRlbXMubGVuZ3RoXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzLFxuICAgICAgICAgIGl0ZW1zLFxuICAgICAgICAgIGlzRmV0Y2hpbmc6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlc2V0IGl0ZW1zIGlmIG5ldyBpdGVtcyBhcnJheSBpcyBlbXB0eS5cbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwICYmIHN0YXRlLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhhc1BlbmRpbmdNZWFzdXJlbWVudHMsXG4gICAgICAgIGl0ZW1zLFxuICAgICAgICBpc0ZldGNoaW5nOiBmYWxzZSxcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChoYXNQZW5kaW5nTWVhc3VyZW1lbnRzICE9PSBzdGF0ZS5oYXNQZW5kaW5nTWVhc3VyZW1lbnRzKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgd2UgYWx3YXlzIHVwZGF0ZSBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzLFxuICAgICAgICBpdGVtcyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIG51bGwgdG8gaW5kaWNhdGUgbm8gY2hhbmdlIHRvIHN0YXRlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc2V0R3JpZFdyYXBwZXJSZWYgPSAocmVmOiA/SFRNTEVsZW1lbnQpID0+IHtcbiAgICB0aGlzLmdyaWRXcmFwcGVyID0gcmVmO1xuICB9O1xuXG4gIHNldFNjcm9sbENvbnRhaW5lclJlZiA9IChyZWY6ID9TY3JvbGxDb250YWluZXIpID0+IHtcbiAgICB0aGlzLnNjcm9sbENvbnRhaW5lciA9IHJlZjtcbiAgfTtcblxuICBmZXRjaE1vcmUgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBsb2FkSXRlbXMgfSA9IHRoaXMucHJvcHM7XG4gICAgaWYgKGxvYWRJdGVtcyAmJiB0eXBlb2YgbG9hZEl0ZW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKFxuICAgICAgICB7XG4gICAgICAgICAgaXNGZXRjaGluZzogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4gbG9hZEl0ZW1zKHsgZnJvbTogdGhpcy5wcm9wcy5pdGVtcy5sZW5ndGggfSlcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnRhaW5lckhlaWdodDogbnVtYmVyO1xuXG4gIGNvbnRhaW5lck9mZnNldDogbnVtYmVyO1xuXG4gIGdyaWRXcmFwcGVyOiA/SFRNTEVsZW1lbnQ7XG5cbiAgaW5zZXJ0QW5pbWF0aW9uRnJhbWU6IEFuaW1hdGlvbkZyYW1lSUQ7XG5cbiAgbWVhc3VyZVRpbWVvdXQ6IFRpbWVvdXRJRDtcblxuICBzY3JvbGxDb250YWluZXI6ID9TY3JvbGxDb250YWluZXI7XG5cbiAgbWVhc3VyZUNvbnRhaW5lcigpIHtcbiAgICBpZiAodGhpcy5zY3JvbGxDb250YWluZXIgIT0gbnVsbCkge1xuICAgICAgY29uc3QgeyBzY3JvbGxDb250YWluZXIgfSA9IHRoaXM7XG4gICAgICBjb25zdCBzY3JvbGxDb250YWluZXJSZWYgPSBzY3JvbGxDb250YWluZXIuZ2V0U2Nyb2xsQ29udGFpbmVyUmVmKCk7XG4gICAgICBpZiAoc2Nyb2xsQ29udGFpbmVyUmVmKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVySGVpZ2h0ID0gZ2V0RWxlbWVudEhlaWdodChzY3JvbGxDb250YWluZXJSZWYpO1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMuZ3JpZFdyYXBwZXI7XG4gICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgY29uc3QgcmVsYXRpdmVTY3JvbGxUb3AgPSBnZXRSZWxhdGl2ZVNjcm9sbFRvcChzY3JvbGxDb250YWluZXJSZWYpO1xuICAgICAgICAgIHRoaXMuY29udGFpbmVyT2Zmc2V0ID1cbiAgICAgICAgICAgIGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHJlbGF0aXZlU2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIG1lYXN1cmVtZW50cy9wb3NpdGlvbnMgYW5kIGZvcmNlIGEgcmVmbG93IG9mIHRoZSBlbnRpcmUgZ3JpZC5cbiAgICogT25seSB1c2UgdGhpcyBpZiBhYnNvbHV0ZWx5IG5lY2Vzc2FyeSAtIGV4OiBXZSBuZWVkIHRvIHJlZmxvdyBpdGVtcyBpZiB0aGVcbiAgICogbnVtYmVyIG9mIGNvbHVtbnMgd2Ugd291bGQgZGlzcGxheSBzaG91bGQgY2hhbmdlIGFmdGVyIGEgcmVzaXplLlxuICAgKi9cbiAgcmVmbG93KCkge1xuICAgIHRoaXMucHJvcHMubWVhc3VyZW1lbnRTdG9yZS5yZXNldCgpO1xuICAgIHRoaXMubWVhc3VyZUNvbnRhaW5lcigpO1xuICAgIHRoaXMuZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIHJlbmRlck1hc29ucnlDb21wb25lbnQgPSAoaXRlbURhdGE6IFQsIGlkeDogbnVtYmVyLCBwb3NpdGlvbjogKikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbXA6IENvbXBvbmVudCxcbiAgICAgIHZpcnR1YWxpemUsXG4gICAgICB2aXJ0dWFsQm91bmRzVG9wLFxuICAgICAgdmlydHVhbEJvdW5kc0JvdHRvbSxcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCB7IHRvcCwgbGVmdCwgd2lkdGgsIGhlaWdodCB9ID0gcG9zaXRpb247XG5cbiAgICBsZXQgaXNWaXNpYmxlO1xuICAgIGlmICh0aGlzLnByb3BzLnNjcm9sbENvbnRhaW5lcikge1xuICAgICAgY29uc3QgdmlydHVhbEJ1ZmZlciA9IHRoaXMuY29udGFpbmVySGVpZ2h0ICogVklSVFVBTF9CVUZGRVJfRkFDVE9SO1xuICAgICAgY29uc3Qgb2Zmc2V0U2Nyb2xsUG9zID0gdGhpcy5zdGF0ZS5zY3JvbGxUb3AgLSB0aGlzLmNvbnRhaW5lck9mZnNldDtcbiAgICAgIGNvbnN0IHZpZXdwb3J0VG9wID0gdmlydHVhbEJvdW5kc1RvcFxuICAgICAgICA/IG9mZnNldFNjcm9sbFBvcyAtIHZpcnR1YWxCb3VuZHNUb3BcbiAgICAgICAgOiBvZmZzZXRTY3JvbGxQb3MgLSB2aXJ0dWFsQnVmZmVyO1xuICAgICAgY29uc3Qgdmlld3BvcnRCb3R0b20gPSB2aXJ0dWFsQm91bmRzQm90dG9tXG4gICAgICAgID8gb2Zmc2V0U2Nyb2xsUG9zICsgdGhpcy5jb250YWluZXJIZWlnaHQgKyB2aXJ0dWFsQm91bmRzQm90dG9tXG4gICAgICAgIDogb2Zmc2V0U2Nyb2xsUG9zICsgdGhpcy5jb250YWluZXJIZWlnaHQgKyB2aXJ0dWFsQnVmZmVyO1xuXG4gICAgICBpc1Zpc2libGUgPSAhKFxuICAgICAgICBwb3NpdGlvbi50b3AgKyBwb3NpdGlvbi5oZWlnaHQgPCB2aWV3cG9ydFRvcCB8fFxuICAgICAgICBwb3NpdGlvbi50b3AgPiB2aWV3cG9ydEJvdHRvbVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgbm8gc2Nyb2xsIGNvbnRhaW5lciBpcyBwYXNzZWQgaW4sIGl0ZW1zIHNob3VsZCBhbHdheXMgYmUgdmlzaWJsZVxuICAgICAgaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtQ29tcG9uZW50ID0gKFxuICAgICAgPGRpdlxuICAgICAgICBrZXk9e2BpdGVtLSR7aWR4fWB9XG4gICAgICAgIGNsYXNzTmFtZT17W3N0eWxlcy5NYXNvbnJ5X19JdGVtLCBzdHlsZXMuTWFzb25yeV9fSXRlbV9fTW91bnRlZF0uam9pbihcbiAgICAgICAgICAnICdcbiAgICAgICAgKX1cbiAgICAgICAgZGF0YS1ncmlkLWl0ZW1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGVYKCR7bGVmdH1weCkgdHJhbnNsYXRlWSgke3RvcH1weClgLFxuICAgICAgICAgIFdlYmtpdFRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtsZWZ0fXB4KSB0cmFuc2xhdGVZKCR7dG9wfXB4KWAsXG4gICAgICAgICAgd2lkdGg6IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uKHdpZHRoKSxcbiAgICAgICAgICBoZWlnaHQ6IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uKGhlaWdodCksXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIDxDb21wb25lbnQgZGF0YT17aXRlbURhdGF9IGl0ZW1JZHg9e2lkeH0gaXNNZWFzdXJpbmc9e2ZhbHNlfSAvPlxuICAgICAgPC9kaXY+XG4gICAgKTtcblxuICAgIHJldHVybiB2aXJ0dWFsaXplID8gKGlzVmlzaWJsZSAmJiBpdGVtQ29tcG9uZW50KSB8fCBudWxsIDogaXRlbUNvbXBvbmVudDtcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29sdW1uV2lkdGgsXG4gICAgICBjb21wOiBDb21wb25lbnQsXG4gICAgICBmbGV4aWJsZSxcbiAgICAgIGd1dHRlcldpZHRoOiBndXR0ZXIsXG4gICAgICBtZWFzdXJlbWVudFN0b3JlLFxuICAgICAgaXRlbXMsXG4gICAgICBtaW5Db2xzLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgaGFzUGVuZGluZ01lYXN1cmVtZW50cywgd2lkdGggfSA9IHRoaXMuc3RhdGU7XG5cbiAgICBsZXQgbGF5b3V0O1xuICAgIGlmIChmbGV4aWJsZSAmJiB3aWR0aCAhPT0gbnVsbCkge1xuICAgICAgbGF5b3V0ID0gZnVsbFdpZHRoTGF5b3V0KHtcbiAgICAgICAgZ3V0dGVyLFxuICAgICAgICBjYWNoZTogbWVhc3VyZW1lbnRTdG9yZSxcbiAgICAgICAgbWluQ29scyxcbiAgICAgICAgaWRlYWxDb2x1bW5XaWR0aDogY29sdW1uV2lkdGgsXG4gICAgICAgIHdpZHRoLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRoaXMucHJvcHMubGF5b3V0ID09PSBVbmlmb3JtUm93TGF5b3V0U3ltYm9sIHx8XG4gICAgICB0aGlzLnByb3BzLmxheW91dCBpbnN0YW5jZW9mIExlZ2FjeVVuaWZvcm1Sb3dMYXlvdXRcbiAgICApIHtcbiAgICAgIGxheW91dCA9IHVuaWZvcm1Sb3dMYXlvdXQoe1xuICAgICAgICBjYWNoZTogbWVhc3VyZW1lbnRTdG9yZSxcbiAgICAgICAgY29sdW1uV2lkdGgsXG4gICAgICAgIGd1dHRlcixcbiAgICAgICAgbWluQ29scyxcbiAgICAgICAgd2lkdGgsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5b3V0ID0gZGVmYXVsdExheW91dCh7XG4gICAgICAgIGNhY2hlOiBtZWFzdXJlbWVudFN0b3JlLFxuICAgICAgICBjb2x1bW5XaWR0aCxcbiAgICAgICAgZ3V0dGVyLFxuICAgICAgICBtaW5Db2xzLFxuICAgICAgICB3aWR0aCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCBncmlkQm9keTtcbiAgICBpZiAod2lkdGggPT0gbnVsbCAmJiBoYXNQZW5kaW5nTWVhc3VyZW1lbnRzKSB7XG4gICAgICAvLyBXaGVuIGh5cmRhdGluZyBmcm9tIGEgc2VydmVyIHJlbmRlciwgd2UgZG9uJ3QgaGF2ZSB0aGUgd2lkdGggb2YgdGhlIGdyaWRcbiAgICAgIC8vIGFuZCB0aGUgbWVhc3VyZW1lbnQgc3RvcmUgaXMgZW1wdHlcbiAgICAgIGdyaWRCb2R5ID0gKFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuTWFzb25yeX1cbiAgICAgICAgICBzdHlsZT17eyBoZWlnaHQ6IDAsIHdpZHRoOiAnMTAwJScgfX1cbiAgICAgICAgICByZWY9e3RoaXMuc2V0R3JpZFdyYXBwZXJSZWZ9XG4gICAgICAgID5cbiAgICAgICAgICB7aXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbSkubWFwKChpdGVtLCBpKSA9PiAoXG4gICAgICAgICAgICA8ZGl2IC8vIGtlZXAgdGhpcyBpbiBzeW5jIHdpdGggcmVuZGVyTWFzb25yeUNvbXBvbmVudFxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJzdGF0aWNcIlxuICAgICAgICAgICAgICBkYXRhLWdyaWQtaXRlbVxuICAgICAgICAgICAgICBrZXk9e2l9XG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwcHgpIHRyYW5zbGF0ZVkoMHB4KScsXG4gICAgICAgICAgICAgICAgV2Via2l0VHJhbnNmb3JtOiAndHJhbnNsYXRlWCgwcHgpIHRyYW5zbGF0ZVkoMHB4KScsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGZsZXhpYmxlXG4gICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgOiBsYXlvdXROdW1iZXJUb0Nzc0RpbWVuc2lvbihjb2x1bW5XaWR0aCksIC8vIHdlIGNhbid0IHNldCBhIHdpZHRoIGZvciBzZXJ2ZXIgcmVuZGVyZWQgZmxleGlibGUgaXRlbXNcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgcmVmPXtlbCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVsICYmICFmbGV4aWJsZSkge1xuICAgICAgICAgICAgICAgICAgLy8gb25seSBtZWFzdXJlIGZsZXhpYmxlIGl0ZW1zIG9uIGNsaWVudFxuICAgICAgICAgICAgICAgICAgbWVhc3VyZW1lbnRTdG9yZS5zZXQoaXRlbSwgZWwuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxDb21wb25lbnQgZGF0YT17aXRlbX0gaXRlbUlkeD17aX0gaXNNZWFzdXJpbmc9e2ZhbHNlfSAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHdpZHRoID09IG51bGwpIHtcbiAgICAgIC8vIFdoZW4gdGhlIHdpZHRoIGlzIGVtcHR5ICh1c3VhbGx5IGFmdGVyIGEgcmUtbW91bnQpIHJlbmRlciBhbiBlbXB0eVxuICAgICAgLy8gZGl2IHRvIGNvbGxlY3QgdGhlIHdpZHRoIGZvciBsYXlvdXRcbiAgICAgIGdyaWRCb2R5ID0gPGRpdiBzdHlsZT17eyB3aWR0aDogJzEwMCUnIH19IHJlZj17dGhpcy5zZXRHcmlkV3JhcHBlclJlZn0gLz47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZ1bGwgbGF5b3V0IGlzIHBvc3NpYmxlXG4gICAgICBjb25zdCBpdGVtc1RvUmVuZGVyID0gaXRlbXMuZmlsdGVyKFxuICAgICAgICBpdGVtID0+IGl0ZW0gJiYgbWVhc3VyZW1lbnRTdG9yZS5oYXMoaXRlbSlcbiAgICAgICk7XG4gICAgICBjb25zdCBpdGVtc1RvTWVhc3VyZSA9IGl0ZW1zXG4gICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtICYmICFtZWFzdXJlbWVudFN0b3JlLmhhcyhpdGVtKSlcbiAgICAgICAgLnNsaWNlKDAsIG1pbkNvbHMpO1xuXG4gICAgICBjb25zdCBwb3NpdGlvbnMgPSBsYXlvdXQoaXRlbXNUb1JlbmRlcik7XG4gICAgICBjb25zdCBtZWFzdXJpbmdQb3NpdGlvbnMgPSBsYXlvdXQoaXRlbXNUb01lYXN1cmUpO1xuICAgICAgLy8gTWF0aC5tYXgoKSA9PT0gLUluZmluaXR5IHdoZW4gdGhlcmUgYXJlIG5vIHBvc2l0aW9uc1xuICAgICAgY29uc3QgaGVpZ2h0ID0gcG9zaXRpb25zLmxlbmd0aFxuICAgICAgICA/IE1hdGgubWF4KC4uLnBvc2l0aW9ucy5tYXAocG9zID0+IHBvcy50b3AgKyBwb3MuaGVpZ2h0KSlcbiAgICAgICAgOiAwO1xuICAgICAgZ3JpZEJvZHkgPSAoXG4gICAgICAgIDxkaXYgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJyB9fSByZWY9e3RoaXMuc2V0R3JpZFdyYXBwZXJSZWZ9PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuTWFzb25yeX0gc3R5bGU9e3sgaGVpZ2h0LCB3aWR0aCB9fT5cbiAgICAgICAgICAgIHtpdGVtc1RvUmVuZGVyLm1hcCgoaXRlbSwgaSkgPT5cbiAgICAgICAgICAgICAgdGhpcy5yZW5kZXJNYXNvbnJ5Q29tcG9uZW50KGl0ZW0sIGksIHBvc2l0aW9uc1tpXSlcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5NYXNvbnJ5fSBzdHlsZT17eyB3aWR0aCB9fT5cbiAgICAgICAgICAgIHtpdGVtc1RvTWVhc3VyZS5tYXAoKGRhdGEsIGkpID0+IHtcbiAgICAgICAgICAgICAgLy8gaXRlbXNUb01lYXN1cmUgaXMgYWx3YXlzIHRoZSBsZW5ndGggb2YgbWluQ29scywgc28gaSB3aWxsIGFsd2F5cyBiZSAwLi5taW5Db2xzLmxlbmd0aFxuICAgICAgICAgICAgICAvLyB3ZSBub3JtYWxpemUgdGhlIGluZGV4IGhlcmUgcmVsYXRpdmUgdG8gdGhlIGl0ZW0gbGlzdCBhcyBhIHdob2xlIHNvIHRoYXQgaXRlbUlkeCBpcyBjb3JyZWN0XG4gICAgICAgICAgICAgIC8vIGFuZCBzbyB0aGF0IFJlYWN0IGRvZXNudCByZXVzZSB0aGUgbWVhc3VyZW1lbnQgbm9kZXNcbiAgICAgICAgICAgICAgY29uc3QgbWVhc3VyZW1lbnRJbmRleCA9IGl0ZW1zVG9SZW5kZXIubGVuZ3RoICsgaTtcbiAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBtZWFzdXJpbmdQb3NpdGlvbnNbaV07XG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAga2V5PXtgbWVhc3VyaW5nLSR7bWVhc3VyZW1lbnRJbmRleH1gfVxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uKHBvc2l0aW9uLnRvcCksXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uKHBvc2l0aW9uLmxlZnQpLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbGF5b3V0TnVtYmVyVG9Dc3NEaW1lbnNpb24ocG9zaXRpb24ud2lkdGgpLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uKHBvc2l0aW9uLmhlaWdodCksXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgcmVmPXtlbCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgICAgICAgIG1lYXN1cmVtZW50U3RvcmUuc2V0KGRhdGEsIGVsLmNsaWVudEhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPENvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICBkYXRhPXtkYXRhfVxuICAgICAgICAgICAgICAgICAgICBpdGVtSWR4PXttZWFzdXJlbWVudEluZGV4fVxuICAgICAgICAgICAgICAgICAgICBpc01lYXN1cmluZ1xuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pfVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAge3RoaXMuc2Nyb2xsQ29udGFpbmVyICYmIChcbiAgICAgICAgICAgIDxGZXRjaEl0ZW1zXG4gICAgICAgICAgICAgIGNvbnRhaW5lckhlaWdodD17dGhpcy5jb250YWluZXJIZWlnaHR9XG4gICAgICAgICAgICAgIGZldGNoTW9yZT17dGhpcy5mZXRjaE1vcmV9XG4gICAgICAgICAgICAgIGlzRmV0Y2hpbmc9e1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaXNGZXRjaGluZyB8fCB0aGlzLnN0YXRlLmhhc1BlbmRpbmdNZWFzdXJlbWVudHNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzY3JvbGxIZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgICAgICAgc2Nyb2xsVG9wPXt0aGlzLnN0YXRlLnNjcm9sbFRvcH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnByb3BzLnNjcm9sbENvbnRhaW5lciA/IChcbiAgICAgIDxTY3JvbGxDb250YWluZXJcbiAgICAgICAgcmVmPXt0aGlzLnNldFNjcm9sbENvbnRhaW5lclJlZn1cbiAgICAgICAgb25TY3JvbGw9e3RoaXMudXBkYXRlU2Nyb2xsUG9zaXRpb259XG4gICAgICAgIHNjcm9sbENvbnRhaW5lcj17dGhpcy5wcm9wcy5zY3JvbGxDb250YWluZXJ9XG4gICAgICA+XG4gICAgICAgIHtncmlkQm9keX1cbiAgICAgIDwvU2Nyb2xsQ29udGFpbmVyPlxuICAgICkgOiAoXG4gICAgICBncmlkQm9keVxuICAgICk7XG4gIH1cbn1cbiIsIi8qIEBmbG93ICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGlsZHJlbj86IFJlYWN0Lk5vZGUsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9TY3JvbGxCZWhhdmlvciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcz4ge1xuICBjb25zdHJ1Y3Rvcihwcm9wczogUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5wcmV2T3ZlcmZsb3cgPSBudWxsO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnByZXZPdmVyZmxvdyA9IHdpbmRvdy5kb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93O1xuICAgICAgd2luZG93LmRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gdGhpcy5wcmV2T3ZlcmZsb3c7XG4gICAgfVxuICB9XG5cbiAgcHJldk92ZXJmbG93OiBzdHJpbmcgfCBudWxsO1xuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufVxuIiwiLyogQGZsb3cgKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbnx9O1xuXG5mdW5jdGlvbiBxdWVyeUZvY3VzYWJsZUFsbChlbDogSFRNTERpdkVsZW1lbnQpIHtcbiAgY29uc3Qgc2VsZWN0b3IgPSBbXG4gICAgJ2FbaHJlZl0nLFxuICAgICdhcmVhW2hyZWZdJyxcbiAgICAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pJyxcbiAgICAnc2VsZWN0Om5vdChbZGlzYWJsZWRdKScsXG4gICAgJ3RleHRhcmVhOm5vdChbZGlzYWJsZWRdKScsXG4gICAgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLFxuICAgICdpZnJhbWUnLFxuICAgICdvYmplY3QnLFxuICAgICdlbWJlZCcsXG4gICAgJ1t0YWJpbmRleD1cIi0xXCJdJyxcbiAgICAnW3RhYmluZGV4PVwiMFwiXScsXG4gICAgJ1tjb250ZW50ZWRpdGFibGVdJyxcbiAgICAnYXVkaW9bY29udHJvbHNdJyxcbiAgICAndmlkZW9bY29udHJvbHNdJyxcbiAgICAnc3VtbWFyeScsXG4gIF0uam9pbignLCcpO1xuICByZXR1cm4gZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG59XG5cbmNvbnN0IGZvY3VzRWxlbWVudCA9IChlbDogSFRNTEVsZW1lbnQpID0+IHtcbiAgaWYgKHR5cGVvZiBlbC5mb2N1cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVsLmZvY3VzKCk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYXBGb2N1c0JlaGF2aW9yIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzPiB7XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMucHJldmlvdXNseUZvY3VzZWRFbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgdGhpcy5mb2N1c0ZpcnN0Q2hpbGQoKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuaGFuZGxlRm9jdXMsIHRydWUpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzLCB0cnVlKTtcbiAgICBpZiAodGhpcy5wcmV2aW91c2x5Rm9jdXNlZEVsKSB7XG4gICAgICBmb2N1c0VsZW1lbnQodGhpcy5wcmV2aW91c2x5Rm9jdXNlZEVsKTtcbiAgICB9XG4gIH1cblxuICBzZXRFbFJlZiA9IChlbDogP0hUTUxEaXZFbGVtZW50KSA9PiB7XG4gICAgaWYgKGVsKSB7XG4gICAgICB0aGlzLmVsID0gZWw7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZUZvY3VzID0gKGV2ZW50OiBGb2N1c0V2ZW50KSA9PiB7XG4gICAgaWYgKFxuICAgICAgIXRoaXMuZWwgfHxcbiAgICAgIChldmVudC50YXJnZXQgaW5zdGFuY2VvZiBOb2RlICYmIHRoaXMuZWwuY29udGFpbnMoZXZlbnQudGFyZ2V0KSlcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuZm9jdXNGaXJzdENoaWxkKCk7XG4gIH07XG5cbiAgZm9jdXNGaXJzdENoaWxkKCkge1xuICAgIGNvbnN0IHsgZWwgfSA9IHRoaXM7XG4gICAgaWYgKGVsKSB7XG4gICAgICBmb2N1c0VsZW1lbnQocXVlcnlGb2N1c2FibGVBbGwoZWwpWzBdKTtcbiAgICB9XG4gIH1cblxuICBlbDogP0hUTUxEaXZFbGVtZW50O1xuXG4gIHByZXZpb3VzbHlGb2N1c2VkRWw6ID9IVE1MRWxlbWVudDtcblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIDxkaXYgcmVmPXt0aGlzLnNldEVsUmVmfT57dGhpcy5wcm9wcy5jaGlsZHJlbn08L2Rpdj47XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcyc7XG5pbXBvcnQgRGl2aWRlciBmcm9tICcuL0RpdmlkZXIuanMnO1xuaW1wb3J0IEhlYWRpbmcgZnJvbSAnLi9IZWFkaW5nLmpzJztcbmltcG9ydCBJY29uQnV0dG9uIGZyb20gJy4vSWNvbkJ1dHRvbi5qcyc7XG5pbXBvcnQgU3RvcFNjcm9sbEJlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL1N0b3BTY3JvbGxCZWhhdmlvci5qcyc7XG5pbXBvcnQgVHJhcEZvY3VzQmVoYXZpb3IgZnJvbSAnLi9iZWhhdmlvcnMvVHJhcEZvY3VzQmVoYXZpb3IuanMnO1xuaW1wb3J0IE91dHNpZGVFdmVudEJlaGF2aW9yIGZyb20gJy4vYmVoYXZpb3JzL091dHNpZGVFdmVudEJlaGF2aW9yLmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9Nb2RhbC5jc3MnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgYWNjZXNzaWJpbGl0eUNsb3NlTGFiZWw6IHN0cmluZyxcbiAgYWNjZXNzaWJpbGl0eU1vZGFsTGFiZWw6IHN0cmluZyxcbiAgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlLFxuICBmb290ZXI/OiBSZWFjdC5Ob2RlLFxuICBoZWFkaW5nOiBzdHJpbmcsXG4gIG9uRGlzbWlzczogKCkgPT4gdm9pZCxcbiAgcm9sZT86ICdhbGVydGRpYWxvZycgfCAnZGlhbG9nJyxcbiAgc2l6ZT86ICdzbScgfCAnbWQnIHwgJ2xnJyxcbnx9O1xuXG5jb25zdCBTSVpFX1dJRFRIX01BUCA9IHtcbiAgc206IDQxNCxcbiAgbWQ6IDU0NCxcbiAgbGc6IDgwNCxcbn07XG5cbmNvbnN0IEVTQ0FQRV9LRVlfQ09ERSA9IDI3O1xuXG5jb25zdCBCYWNrZHJvcCA9ICh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW4/OiBSZWFjdC5Ob2RlIH0pID0+IChcbiAgPFJlYWN0LkZyYWdtZW50PlxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuQmFja2Ryb3B9IC8+XG4gICAge2NoaWxkcmVufVxuICA8L1JlYWN0LkZyYWdtZW50PlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kYWwgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHM+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gICAgYWNjZXNzaWJpbGl0eUNsb3NlTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBmb290ZXI6IFByb3BUeXBlcy5ub2RlLFxuICAgIGhlYWRpbmc6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBhY2Nlc3NpYmlsaXR5TW9kYWxMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIG9uRGlzbWlzczogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcm9sZTogUHJvcFR5cGVzLm9uZU9mKFsnYWxlcnRkaWFsb2cnLCAnZGlhbG9nJ10pLFxuICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3NtJywgJ21kJywgJ2xnJ10pLFxuICB9O1xuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuaGFuZGxlS2V5VXApO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5oYW5kbGVLZXlVcCk7XG4gIH1cblxuICBoYW5kbGVPdXRzaWRlQ2xpY2sgPSAoKSA9PiB7XG4gICAgdGhpcy5wcm9wcy5vbkRpc21pc3MoKTtcbiAgfTtcblxuICBoYW5kbGVDbG9zZUNsaWNrID0gKCkgPT4ge1xuICAgIHRoaXMucHJvcHMub25EaXNtaXNzKCk7XG4gIH07XG5cbiAgaGFuZGxlS2V5VXAgPSAoZXZlbnQ6IHsga2V5Q29kZTogbnVtYmVyIH0pID0+IHtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gRVNDQVBFX0tFWV9DT0RFKSB7XG4gICAgICB0aGlzLnByb3BzLm9uRGlzbWlzcygpO1xuICAgIH1cbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYWNjZXNzaWJpbGl0eUNsb3NlTGFiZWwsXG4gICAgICBhY2Nlc3NpYmlsaXR5TW9kYWxMYWJlbCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZm9vdGVyLFxuICAgICAgaGVhZGluZyxcbiAgICAgIHJvbGUgPSAnZGlhbG9nJyxcbiAgICAgIHNpemUgPSAnc20nLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHdpZHRoID0gU0laRV9XSURUSF9NQVBbc2l6ZV07XG5cbiAgICByZXR1cm4gKFxuICAgICAgPFN0b3BTY3JvbGxCZWhhdmlvcj5cbiAgICAgICAgPFRyYXBGb2N1c0JlaGF2aW9yPlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e2FjY2Vzc2liaWxpdHlNb2RhbExhYmVsfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuY29udGFpbmVyfVxuICAgICAgICAgICAgcm9sZT17cm9sZX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8QmFja2Ryb3A+XG4gICAgICAgICAgICAgIDxPdXRzaWRlRXZlbnRCZWhhdmlvciBvbkNsaWNrPXt0aGlzLmhhbmRsZU91dHNpZGVDbGlja30+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy53cmFwcGVyfSB0YWJJbmRleD17LTF9IHN0eWxlPXt7IHdpZHRoIH19PlxuICAgICAgICAgICAgICAgICAgPEJveFxuICAgICAgICAgICAgICAgICAgICBmbGV4PVwiZ3Jvd1wiXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uPVwicmVsYXRpdmVcIlxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5PVwiZmxleFwiXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbj1cImNvbHVtblwiXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxCb3ggZml0PlxuICAgICAgICAgICAgICAgICAgICAgIHtyb2xlID09PSAnZGlhbG9nJyA/IChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCb3hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fc3R5bGU6IHsgcGFkZGluZ0xlZnQ6IDUwLCBwYWRkaW5nUmlnaHQ6IDUwIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk9XCJmbGV4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ9XCJjZW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nWT17NX1cbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPEhlYWRpbmcgc2l6ZT1cInhzXCIgYWNjZXNzaWJpbGl0eUxldmVsPXsxfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aGVhZGluZ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9IZWFkaW5nPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxCb3ggZGlzcGxheT1cImZsZXhcIiBwYWRkaW5nPXs0fT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPEhlYWRpbmcgc2l6ZT1cInNtXCIgYWNjZXNzaWJpbGl0eUxldmVsPXsxfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aGVhZGluZ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9IZWFkaW5nPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICB7cm9sZSA9PT0gJ2RpYWxvZycgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgPEJveCBwYWRkaW5nPXsyfSBwb3NpdGlvbj1cImFic29sdXRlXCIgdG9wIHJpZ2h0PlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8SWNvbkJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlMYWJlbD17YWNjZXNzaWJpbGl0eUNsb3NlTGFiZWx9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImNhbmNlbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVDbG9zZUNsaWNrfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICB7cm9sZSA9PT0gJ2RpYWxvZycgJiYgPERpdmlkZXIgLz59XG4gICAgICAgICAgICAgICAgICAgIDwvQm94PlxuICAgICAgICAgICAgICAgICAgICA8Qm94IGZsZXg9XCJncm93XCIgb3ZlcmZsb3c9XCJhdXRvXCIgcG9zaXRpb249XCJyZWxhdGl2ZVwiPlxuICAgICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgICAgICAgICAgIDxCb3ggZml0PlxuICAgICAgICAgICAgICAgICAgICAgIHtmb290ZXIgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgPEJveD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAge3JvbGUgPT09ICdkaWFsb2cnICYmIDxEaXZpZGVyIC8+fVxuICAgICAgICAgICAgICAgICAgICAgICAgICA8Qm94IHBhZGRpbmc9ezR9Pntmb290ZXJ9PC9Cb3g+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICAgICAgICAgIDwvQm94PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L091dHNpZGVFdmVudEJlaGF2aW9yPlxuICAgICAgICAgICAgPC9CYWNrZHJvcD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9UcmFwRm9jdXNCZWhhdmlvcj5cbiAgICAgIDwvU3RvcFNjcm9sbEJlaGF2aW9yPlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vUHVsc2FyLmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIHBhdXNlZD86IGJvb2xlYW4sXG4gIHNpemU/OiBudW1iZXIsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQdWxzYXIocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHsgcGF1c2VkLCBzaXplID0gMTM1IH0gPSBwcm9wcztcblxuICByZXR1cm4gKFxuICAgIDxCb3hcbiAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3tcbiAgICAgICAgX19zdHlsZToge1xuICAgICAgICAgIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiBwYXVzZWQgPyAwIDogJ2luZmluaXRlJyxcbiAgICAgICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgICAgICAgYm94U2hhZG93OiAnbm9uZScsXG4gICAgICAgIH0sXG4gICAgICB9fVxuICAgICAgZGlzcGxheT17cGF1c2VkID8gJ25vbmUnIDogJ2Jsb2NrJ31cbiAgICAgIGhlaWdodD17c2l6ZX1cbiAgICAgIHBvc2l0aW9uPVwicmVsYXRpdmVcIlxuICAgICAgd2lkdGg9e3NpemV9XG4gICAgPlxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5pbm5lckNpcmNsZX0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMub3V0ZXJDaXJjbGV9IC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L0JveD5cbiAgKTtcbn1cblxuUHVsc2FyLnByb3BUeXBlcyA9IHtcbiAgcGF1c2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2l6ZTogUHJvcFR5cGVzLm51bWJlcixcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1JhZGlvQnV0dG9uLmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBjaGVja2VkPzogYm9vbGVhbixcbiAgZGlzYWJsZWQ/OiBib29sZWFuLFxuICBpZDogc3RyaW5nLFxuICBuYW1lPzogc3RyaW5nLFxuICBvbkNoYW5nZTogKHtcbiAgICBldmVudDogU3ludGhldGljSW5wdXRFdmVudDw+LFxuICAgIGNoZWNrZWQ6IGJvb2xlYW4sXG4gIH0pID0+IHZvaWQsXG4gIHZhbHVlOiBzdHJpbmcsXG4gIHNpemU/OiAnc20nIHwgJ21kJyxcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgZm9jdXNlZDogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRpb0J1dHRvbiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBjaGVja2VkOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnc20nLCAnbWQnXSksXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBjaGVja2VkOiBmYWxzZSxcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgc2l6ZTogJ21kJyxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBmb2N1c2VkOiBmYWxzZSxcbiAgfTtcblxuICBoYW5kbGVDaGFuZ2UgPSAoZXZlbnQ6IFN5bnRoZXRpY0lucHV0RXZlbnQ8PikgPT4ge1xuICAgIGNvbnN0IHsgY2hlY2tlZCB9ID0gZXZlbnQudGFyZ2V0O1xuICAgIHRoaXMucHJvcHMub25DaGFuZ2UoeyBjaGVja2VkLCBldmVudCB9KTtcbiAgfTtcblxuICBoYW5kbGVCbHVyID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWQ6IGZhbHNlIH0pO1xuXG4gIGhhbmRsZUZvY3VzID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBmb2N1c2VkOiB0cnVlIH0pO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNoZWNrZWQsIGRpc2FibGVkLCBpZCwgbmFtZSwgc2l6ZSwgdmFsdWUgfSA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKHN0eWxlcy5SYWRpb0J1dHRvbiwge1xuICAgICAgICAgIFtzdHlsZXMuUmFkaW9CdXR0b25Jc0ZvY3VzZWRdOiB0aGlzLnN0YXRlLmZvY3VzZWQsXG4gICAgICAgICAgW3N0eWxlcy5SYWRpb0J1dHRvblNtXTogc2l6ZSA9PT0gJ3NtJyxcbiAgICAgICAgICBbc3R5bGVzLlJhZGlvQnV0dG9uTWRdOiBzaXplID09PSAnbWQnLFxuICAgICAgICAgIFtzdHlsZXMuUmFkaW9CdXR0b25XaGl0ZUJnXTogIWRpc2FibGVkIHx8IGNoZWNrZWQsXG4gICAgICAgICAgW3N0eWxlcy5SYWRpb0J1dHRvbkxpZ2h0R3JheUJnXTogZGlzYWJsZWQgJiYgIWNoZWNrZWQsXG4gICAgICAgIH0pfVxuICAgICAgPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICBjaGVja2VkPXtjaGVja2VkfVxuICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NuYW1lcyhzdHlsZXMuSW5wdXQsIHtcbiAgICAgICAgICAgIFtzdHlsZXMuSW5wdXRFbmFibGVkXTogIWRpc2FibGVkLFxuICAgICAgICAgICAgW3N0eWxlcy5JbnB1dFNtXTogc2l6ZSA9PT0gJ3NtJyxcbiAgICAgICAgICAgIFtzdHlsZXMuSW5wdXRNZF06IHNpemUgPT09ICdtZCcsXG4gICAgICAgICAgfSl9XG4gICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgIGlkPXtpZH1cbiAgICAgICAgICBuYW1lPXtuYW1lfVxuICAgICAgICAgIG9uQmx1cj17dGhpcy5oYW5kbGVCbHVyfVxuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZUNoYW5nZX1cbiAgICAgICAgICBvbkZvY3VzPXt0aGlzLmhhbmRsZUZvY3VzfVxuICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICAvPlxuICAgICAgICB7Y2hlY2tlZCAmJiAoXG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKHN0eWxlcy5DaGVjaywge1xuICAgICAgICAgICAgICBbc3R5bGVzLkNoZWNrU21dOiBzaXplID09PSAnc20nLFxuICAgICAgICAgICAgICBbc3R5bGVzLkNoZWNrTWRdOiBzaXplID09PSAnbWQnLFxuICAgICAgICAgICAgICBbc3R5bGVzLkNoZWNrRW5hYmxlZF06ICFkaXNhYmxlZCxcbiAgICAgICAgICAgICAgW3N0eWxlcy5DaGVja0Rpc2FibGVkXTogZGlzYWJsZWQsXG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgRmV0Y2hJdGVtcyBmcm9tICcuL0ZldGNoSXRlbXMuanMnO1xuaW1wb3J0IFNjcm9sbENvbnRhaW5lciBmcm9tICcuL1Njcm9sbENvbnRhaW5lci5qcyc7XG5pbXBvcnQge1xuICBnZXRFbGVtZW50SGVpZ2h0LFxuICBnZXRTY3JvbGxIZWlnaHQsXG4gIGdldFNjcm9sbFBvcyxcbn0gZnJvbSAnLi9zY3JvbGxVdGlscy5qcyc7XG5pbXBvcnQgdGhyb3R0bGUgZnJvbSAnLi90aHJvdHRsZS5qcyc7XG5cbnR5cGUgUHJvcHMgPSB7XG4gIGNvbnRhaW5lcj86IEhUTUxFbGVtZW50LFxuICBpc0F0RW5kPzogYm9vbGVhbixcbiAgaXNGZXRjaGluZzogYm9vbGVhbixcbiAgZmV0Y2hNb3JlPzogKCkgPT4gdm9pZCxcbiAgcmVuZGVySGVpZ2h0PzogKCkgPT4gbnVtYmVyLFxufTtcblxudHlwZSBTdGF0ZSA9IHtcbiAgY29udGFpbmVySGVpZ2h0OiBudW1iZXIsXG4gIHNjcm9sbEhlaWdodDogbnVtYmVyLFxuICBzY3JvbGxUb3A6IG51bWJlcixcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjcm9sbEZldGNoIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgLyoqXG4gICAqIEZldGNoZXMgYWRkaXRpb25hbCBpdGVtcyBpZiBuZWVkZWQuXG4gICAqL1xuICB1cGRhdGVQb3NpdGlvbiA9IHRocm90dGxlKCgpID0+IHtcbiAgICB0aGlzLnNldFN0YXRlKHRoaXMuZ2V0U2Nyb2xsU3RhdGUoKSk7XG4gIH0pO1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHM6IHt9O1xuXG4gIHN0YXRlID0ge1xuICAgIGNvbnRhaW5lckhlaWdodDogMCxcbiAgICBzY3JvbGxIZWlnaHQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwLFxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIHNjcm9sbCBsaXN0ZW5lciBhZnRlciB0aGUgY29tcG9uZW50IG1vdW50cy5cbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgY29udGFpbmVyIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGNvbnRhaW5lckhlaWdodDogZ2V0RWxlbWVudEhlaWdodChjb250YWluZXIpLFxuICAgICAgICAuLi50aGlzLmdldFNjcm9sbFN0YXRlKCksXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc2Nyb2xsIGJ1ZmZlciBhbmQgY2hlY2sgYWZ0ZXIgdGhlIGNvbXBvbmVudCB1cGRhdGVzLlxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgIC8vIHNldFRpbWVvdXQgc28gdGhlIHBhcmVudCBjb21wb25lbnQgY2FuIGNhbGN1bGF0ZSByZW5kZXJIZWlnaHQoKS5cbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2Nyb2xsYWJsZSBjb250ZW50IGhlaWdodC5cbiAgICovXG4gIGdldFNjcm9sbEhlaWdodCA9ICgpID0+IHtcbiAgICBjb25zdCB7IGNvbnRhaW5lciB9ID0gdGhpcy5wcm9wcztcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBnZXRTY3JvbGxIZWlnaHQoY29udGFpbmVyKTtcbiAgfTtcblxuICBnZXRTY3JvbGxTdGF0ZSgpIHtcbiAgICBjb25zdCB7IGNvbnRhaW5lciwgcmVuZGVySGVpZ2h0IH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc2Nyb2xsSGVpZ2h0ID0gcmVuZGVySGVpZ2h0IHx8IHRoaXMuZ2V0U2Nyb2xsSGVpZ2h0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbEhlaWdodDogc2Nyb2xsSGVpZ2h0KCksXG4gICAgICBzY3JvbGxUb3A6IGdldFNjcm9sbFBvcyhjb250YWluZXIpLFxuICAgIH07XG4gIH1cblxuICBzY3JvbGxCdWZmZXI6IG51bWJlcjtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjb250YWluZXJIZWlnaHQsIHNjcm9sbEhlaWdodCwgc2Nyb2xsVG9wIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHsgY29udGFpbmVyLCBmZXRjaE1vcmUsIGlzQXRFbmQsIGlzRmV0Y2hpbmcgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgIGNvbnRhaW5lckhlaWdodCxcbiAgICAgIGZldGNoTW9yZSxcbiAgICAgIGlzQXRFbmQsXG4gICAgICBpc0ZldGNoaW5nLFxuICAgICAgc2Nyb2xsSGVpZ2h0LFxuICAgICAgc2Nyb2xsVG9wLFxuICAgIH07XG5cbiAgICBpZiAoIWNvbnRhaW5lciB8fCBpc0F0RW5kKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAgIDxTY3JvbGxDb250YWluZXJcbiAgICAgICAgb25TY3JvbGw9e3RoaXMudXBkYXRlUG9zaXRpb259XG4gICAgICAgIHNjcm9sbENvbnRhaW5lcj17Y29udGFpbmVyfVxuICAgICAgPlxuICAgICAgICA8RmV0Y2hJdGVtcyB7Li4ucHJvcHN9IC8+XG4gICAgICA8L1Njcm9sbENvbnRhaW5lcj5cbiAgICApO1xuICB9XG59XG5cblNjcm9sbEZldGNoLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIFRoZSBzY3JvbGwgY29udGFpbmVyIHRvIHVzZS4gRGVmYXVsdHMgdG8gd2luZG93LlxuICAgKi9cbiAgY29udGFpbmVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGFkZEV2ZW50TGlzdGVuZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IFByb3BUeXBlcy5mdW5jLFxuICB9KSxcbiAgcmVuZGVySGVpZ2h0OiBQcm9wVHlwZXMuZnVuYyxcbiAgaXNBdEVuZDogUHJvcFR5cGVzLmJvb2wsXG4gIGlzRmV0Y2hpbmc6IFByb3BUeXBlcy5ib29sLFxuICBmZXRjaE1vcmU6IFByb3BUeXBlcy5mdW5jLFxufTtcblxuU2Nyb2xsRmV0Y2guZGVmYXVsdFByb3BzID0ge1xuICBjb250YWluZXI6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogbnVsbCxcbn07XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1NlYXJjaEZpZWxkLmNzcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5qcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY2Nlc3NpYmlsaXR5TGFiZWw6IHN0cmluZyxcbiAgaWQ6IHN0cmluZyxcbiAgb25CbHVyPzogKHsgZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+IH0pID0+IHZvaWQsXG4gIG9uQ2hhbmdlOiAoe1xuICAgIHZhbHVlOiBzdHJpbmcsXG4gICAgc3ludGhldGljRXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+LFxuICB9KSA9PiB2b2lkLFxuICBvbkZvY3VzPzogKHtcbiAgICB2YWx1ZTogc3RyaW5nLFxuICAgIHN5bnRoZXRpY0V2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PixcbiAgfSkgPT4gdm9pZCxcbiAgcGxhY2Vob2xkZXI/OiBzdHJpbmcsXG4gIHZhbHVlPzogc3RyaW5nLFxufH07XG5cbnR5cGUgU3RhdGUgPSB7fFxuICBmb2N1c2VkOiBib29sZWFuLFxuICBob3ZlcmVkOiBib29sZWFuLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaEZpZWxkIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGFjY2Vzc2liaWxpdHlMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgb25CbHVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvbkZvY3VzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB2YWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgfTtcblxuICBzdGF0ZTogU3RhdGUgPSB7XG4gICAgZm9jdXNlZDogZmFsc2UsXG4gICAgaG92ZXJlZDogZmFsc2UsXG4gIH07XG5cbiAgaGFuZGxlQ2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgdmFsdWU6IGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWUsXG4gICAgICBzeW50aGV0aWNFdmVudDogZXZlbnQsXG4gICAgfSk7XG4gIH07XG5cbiAgaGFuZGxlQ2xlYXIgPSAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICB2YWx1ZTogJycsXG4gICAgICBzeW50aGV0aWNFdmVudDogZXZlbnQsXG4gICAgfSk7XG4gIH07XG5cbiAgaGFuZGxlTW91c2VFbnRlciA9ICgpID0+IHRoaXMuc2V0U3RhdGUoeyBob3ZlcmVkOiB0cnVlIH0pO1xuXG4gIGhhbmRsZU1vdXNlTGVhdmUgPSAoKSA9PiB0aGlzLnNldFN0YXRlKHsgaG92ZXJlZDogZmFsc2UgfSk7XG5cbiAgaGFuZGxlRm9jdXMgPSAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWQ6IHRydWUgfSk7XG5cbiAgICBpZiAodGhpcy5wcm9wcy5vbkZvY3VzKSB7XG4gICAgICB0aGlzLnByb3BzLm9uRm9jdXMoe1xuICAgICAgICB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgICAgc3ludGhldGljRXZlbnQ6IGV2ZW50LFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZUJsdXIgPSAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWQ6IGZhbHNlIH0pO1xuXG4gICAgaWYgKHRoaXMucHJvcHMub25CbHVyKSB7XG4gICAgICB0aGlzLnByb3BzLm9uQmx1cih7IGV2ZW50IH0pO1xuICAgIH1cbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBhY2Nlc3NpYmlsaXR5TGFiZWwsIGlkLCBwbGFjZWhvbGRlciwgdmFsdWUgfSA9IHRoaXMucHJvcHM7XG5cbiAgICAvLyBUaGlzIG1pcnJvcnMgdGhlIGJ1aWx0IGluIGJyb3dzZXIgYmVoYXZpb3IuIElmIHRoZXJlJ3MgYSB2YWx1ZSwgc2hvdyB0aGVcbiAgICAvLyBjbGVhciBidXR0b24gaWYgeW91J3JlIGhvdmVyaW5nIG9yIGlmIHlvdSd2ZSBmb2N1c2VkIG9uIHRoZSBmaWVsZFxuICAgIGNvbnN0IHNob3dDbGVhciA9XG4gICAgICAodGhpcy5zdGF0ZS5mb2N1c2VkIHx8IHRoaXMuc3RhdGUuaG92ZXJlZCkgJiYgdmFsdWUgJiYgdmFsdWUubGVuZ3RoID4gMDtcblxuICAgIHJldHVybiAoXG4gICAgICA8Qm94XG4gICAgICAgIGRpc3BsYXk9XCJmbGV4XCJcbiAgICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgICAgIGFsaWduSXRlbXM9XCJjZW50ZXJcIlxuICAgICAgICBvbk1vdXNlRW50ZXI9e3RoaXMuaGFuZGxlTW91c2VFbnRlcn1cbiAgICAgICAgb25Nb3VzZUxlYXZlPXt0aGlzLmhhbmRsZU1vdXNlTGVhdmV9XG4gICAgICAgIG9uRm9jdXM9e3RoaXMuaGFuZGxlRm9jdXN9XG4gICAgICAgIG9uQmx1cj17dGhpcy5oYW5kbGVCbHVyfVxuICAgICAgICBjb2xvcj1cIndoaXRlXCJcbiAgICAgID5cbiAgICAgICAgPEJveFxuICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3tcbiAgICAgICAgICAgIF9fc3R5bGU6IHtcbiAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICAgICAgICAvLyBBZGRlZCB0aGUgZm9sbG93aW5nIGxpbmVzIGZvciBTYWZhcmkgc3VwcG9ydFxuICAgICAgICAgICAgICB0b3A6ICc1MCUnLFxuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC01MCUpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfX1cbiAgICAgICAgICBwb3NpdGlvbj1cImFic29sdXRlXCJcbiAgICAgICAgICBsZWZ0XG4gICAgICAgICAgcGFkZGluZ1g9ezR9XG4gICAgICAgID5cbiAgICAgICAgICA8SWNvbiBpY29uPVwic2VhcmNoXCIgYWNjZXNzaWJpbGl0eUxhYmVsPVwiXCIgLz5cbiAgICAgICAgPC9Cb3g+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIGFyaWEtbGFiZWw9e2FjY2Vzc2liaWxpdHlMYWJlbH1cbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5pbnB1dH1cbiAgICAgICAgICBpZD17aWR9XG4gICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlQ2hhbmdlfVxuICAgICAgICAgIHBsYWNlaG9sZGVyPXtwbGFjZWhvbGRlcn1cbiAgICAgICAgICByb2xlPVwic2VhcmNoYm94XCJcbiAgICAgICAgICB0eXBlPVwic2VhcmNoXCJcbiAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgIC8+XG4gICAgICAgIHtzaG93Q2xlYXIgJiYgKFxuICAgICAgICAgIDxCb3ggcG9zaXRpb249XCJhYnNvbHV0ZVwiIHJpZ2h0IHRvcD5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuY2xlYXJ9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xlYXJ9XG4gICAgICAgICAgICAgIHRhYkluZGV4PXstMX1cbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxJY29uIGljb249XCJjbGVhclwiIGFjY2Vzc2liaWxpdHlMYWJlbD1cIlwiIC8+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8L0JveD5cbiAgICAgICAgKX1cbiAgICAgIDwvQm94PlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBUZXh0IGZyb20gJy4vVGV4dC5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vU2VnbWVudGVkQ29udHJvbC5jc3MnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgaXRlbXM6IEFycmF5PFJlYWN0Lk5vZGU+LFxuICBvbkNoYW5nZTogKHsgZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8PiwgYWN0aXZlSW5kZXg6IG51bWJlciB9KSA9PiB2b2lkLFxuICBzZWxlY3RlZEl0ZW1JbmRleDogbnVtYmVyLFxuICBzaXplPzogJ21kJyB8ICdsZycsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2VnbWVudGVkQ29udHJvbChwcm9wczogUHJvcHMpIHtcbiAgY29uc3QgeyBpdGVtcywgb25DaGFuZ2UsIHNlbGVjdGVkSXRlbUluZGV4LCBzaXplID0gJ21kJyB9ID0gcHJvcHM7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY2xhc3NOYW1lPXtjbGFzc25hbWVzKHN0eWxlcy5TZWdtZW50ZWRDb250cm9sLCB7XG4gICAgICAgIFtzdHlsZXMubWRdOiBzaXplID09PSAnbWQnLFxuICAgICAgICBbc3R5bGVzLmxnXTogc2l6ZSA9PT0gJ2xnJyxcbiAgICAgIH0pfVxuICAgICAgcm9sZT1cInRhYmxpc3RcIlxuICAgID5cbiAgICAgIHtpdGVtcy5tYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IGkgPT09IHNlbGVjdGVkSXRlbUluZGV4O1xuICAgICAgICBjb25zdCBjcyA9IGNsYXNzbmFtZXMoc3R5bGVzLml0ZW0sIHtcbiAgICAgICAgICBbc3R5bGVzLml0ZW1Jc05vdFNlbGVjdGVkXTogIWlzU2VsZWN0ZWQsXG4gICAgICAgICAgW3N0eWxlcy5pdGVtSXNTZWxlY3RlZF06IGlzU2VsZWN0ZWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIGFyaWEtc2VsZWN0ZWQ9e2lzU2VsZWN0ZWR9XG4gICAgICAgICAgICBjbGFzc05hbWU9e2NzfVxuICAgICAgICAgICAga2V5PXtpfVxuICAgICAgICAgICAgb25DbGljaz17ZSA9PiBvbkNoYW5nZSh7IGV2ZW50OiBlLCBhY3RpdmVJbmRleDogaSB9KX1cbiAgICAgICAgICAgIHJvbGU9XCJ0YWJcIlxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAge3R5cGVvZiBpdGVtID09PSAnc3RyaW5nJyA/IChcbiAgICAgICAgICAgICAgPFRleHRcbiAgICAgICAgICAgICAgICBib2xkXG4gICAgICAgICAgICAgICAgY29sb3I9e2lzU2VsZWN0ZWQgPyAnZGFya0dyYXknIDogJ2dyYXknfVxuICAgICAgICAgICAgICAgIGFsaWduPVwiY2VudGVyXCJcbiAgICAgICAgICAgICAgICBzaXplPXtzaXplfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge2l0ZW19XG4gICAgICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgIDxCb3ggZGlzcGxheT1cImZsZXhcIiBqdXN0aWZ5Q29udGVudD1cImNlbnRlclwiPlxuICAgICAgICAgICAgICAgIHtpdGVtfVxuICAgICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICk7XG4gICAgICB9KX1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuU2VnbWVudGVkQ29udHJvbC5wcm9wVHlwZXMgPSB7XG4gIGl0ZW1zOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubm9kZSkuaXNSZXF1aXJlZCxcbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHNlbGVjdGVkSXRlbUluZGV4OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IEZseW91dCBmcm9tICcuL0ZseW91dC5qcyc7XG5pbXBvcnQgVGV4dCBmcm9tICcuL1RleHQuanMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi9JY29uLmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9TZWxlY3RMaXN0LmNzcyc7XG5cbnR5cGUgU3RhdGUgPSB7XG4gIGZvY3VzZWQ6IGJvb2xlYW4sXG4gIGVycm9ySXNPcGVuOiBib29sZWFuLFxuICBlcnJvck1lc3NhZ2U/OiBzdHJpbmcsXG59O1xuXG50eXBlIFByb3BzID0ge3xcbiAgZXJyb3JNZXNzYWdlPzogc3RyaW5nLFxuICBkaXNhYmxlZD86IGJvb2xlYW4sXG4gIGlkOiBzdHJpbmcsXG4gIGlkZWFsRXJyb3JEaXJlY3Rpb24/OiAndXAnIHwgJ3JpZ2h0JyB8ICdkb3duJyB8ICdsZWZ0JyAvKiBkZWZhdWx0OiByaWdodCAqLyxcbiAgbmFtZT86IHN0cmluZyxcbiAgb25DaGFuZ2U6ICh7IGV2ZW50OiBTeW50aGV0aWNJbnB1dEV2ZW50PD4sIHZhbHVlOiBzdHJpbmcgfSkgPT4gdm9pZCxcbiAgb3B0aW9uczogQXJyYXk8e1xuICAgIGxhYmVsOiBzdHJpbmcsXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgfT4sXG4gIHBsYWNlaG9sZGVyPzogc3RyaW5nLFxuICB2YWx1ZT86ID9zdHJpbmcsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VsZWN0TGlzdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgZXJyb3JNZXNzYWdlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgaWRlYWxFcnJvckRpcmVjdGlvbjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIG9wdGlvbnM6IFByb3BUeXBlcy5hcnJheU9mKFxuICAgICAgUHJvcFR5cGVzLmV4YWN0KHtcbiAgICAgICAgbGFiZWw6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICAgICAgdmFsdWU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICAgIH0pXG4gICAgKSxcbiAgICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICB2YWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBpZGVhbEVycm9yRGlyZWN0aW9uOiAncmlnaHQnLFxuICAgIG9wdGlvbnM6IFtdLFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIGZvY3VzZWQ6IGZhbHNlLFxuICAgIGVycm9ySXNPcGVuOiBmYWxzZSxcbiAgfTtcblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzOiBQcm9wcywgc3RhdGU6IFN0YXRlKSB7XG4gICAgaWYgKHByb3BzLmVycm9yTWVzc2FnZSAhPT0gc3RhdGUuZXJyb3JNZXNzYWdlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcklzT3BlbjogISFwcm9wcy5lcnJvck1lc3NhZ2UsXG4gICAgICAgIGVycm9yTWVzc2FnZTogcHJvcHMuZXJyb3JNZXNzYWdlLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGhhbmRsZU9uQ2hhbmdlID0gKGV2ZW50OiBTeW50aGV0aWNJbnB1dEV2ZW50PD4pID0+IHtcbiAgICBpZiAoXG4gICAgICBldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCAmJlxuICAgICAgdGhpcy5wcm9wcy52YWx1ZSAhPT0gZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgKSB7XG4gICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHsgZXZlbnQsIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWUgfSk7XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3JJc09wZW46IGZhbHNlIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBoYW5kbGVCbHVyID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnByb3BzLmVycm9yTWVzc2FnZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9ySXNPcGVuOiBmYWxzZSB9KTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlRm9jdXMgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMuZXJyb3JNZXNzYWdlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3JJc09wZW46IHRydWUgfSk7XG4gICAgfVxuICB9O1xuXG4gIHNlbGVjdDogP0hUTUxTZWxlY3RFbGVtZW50O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXNhYmxlZCxcbiAgICAgIGVycm9yTWVzc2FnZSxcbiAgICAgIGlkLFxuICAgICAgaWRlYWxFcnJvckRpcmVjdGlvbixcbiAgICAgIG5hbWUsXG4gICAgICBvcHRpb25zLFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICB2YWx1ZSxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc25hbWVzKFxuICAgICAgc3R5bGVzLnNlbGVjdCxcbiAgICAgIGRpc2FibGVkID8gc3R5bGVzLmRpc2FibGVkIDogc3R5bGVzLmVuYWJsZWQsXG4gICAgICBlcnJvck1lc3NhZ2UgPyBzdHlsZXMuZXJyb3JlZCA6IHN0eWxlcy5ub3JtYWxcbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3hcbiAgICAgICAgY29sb3I9e2Rpc2FibGVkID8gJ2xpZ2h0R3JheScgOiAnd2hpdGUnfVxuICAgICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7IF9fc3R5bGU6IHsgYm9yZGVyUmFkaXVzOiA0IH0gfX1cbiAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICBwb3NpdGlvbj1cInJlbGF0aXZlXCJcbiAgICAgICAgd2lkdGg9XCIxMDAlXCJcbiAgICAgID5cbiAgICAgICAgPEJveFxuICAgICAgICAgIGFsaWduSXRlbXM9XCJjZW50ZXJcIlxuICAgICAgICAgIGJvdHRvbVxuICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3tcbiAgICAgICAgICAgIF9fc3R5bGU6IHsgcGFkZGluZ1JpZ2h0OiAxNCwgcGFkZGluZ1RvcDogMiB9LFxuICAgICAgICAgIH19XG4gICAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICAgIHBvc2l0aW9uPVwiYWJzb2x1dGVcIlxuICAgICAgICAgIHJpZ2h0XG4gICAgICAgICAgdG9wXG4gICAgICAgID5cbiAgICAgICAgICA8SWNvblxuICAgICAgICAgICAgaWNvbj1cImFycm93LWRvd25cIlxuICAgICAgICAgICAgc2l6ZT17MTJ9XG4gICAgICAgICAgICBjb2xvcj17ZGlzYWJsZWQgPyAnZ3JheScgOiAnZGFya0dyYXknfVxuICAgICAgICAgICAgYWNjZXNzaWJpbGl0eUxhYmVsPVwiXCJcbiAgICAgICAgICAvPlxuICAgICAgICA8L0JveD5cbiAgICAgICAgPHNlbGVjdFxuICAgICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9e1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICYmIHRoaXMuc3RhdGUuZm9jdXNlZCA/IGAke2lkfS1nZXN0YWx0LWVycm9yYCA6IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJpYS1pbnZhbGlkPXtlcnJvck1lc3NhZ2UgPyAndHJ1ZScgOiAnZmFsc2UnfVxuICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlc31cbiAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgaWQ9e2lkfVxuICAgICAgICAgIG5hbWU9e25hbWV9XG4gICAgICAgICAgb25CbHVyPXt0aGlzLmhhbmRsZUJsdXJ9XG4gICAgICAgICAgb25Gb2N1cz17dGhpcy5oYW5kbGVGb2N1c31cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVPbkNoYW5nZX1cbiAgICAgICAgICByZWY9e2MgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3QgPSBjO1xuICAgICAgICAgIH19XG4gICAgICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgICA+XG4gICAgICAgICAge3BsYWNlaG9sZGVyICYmXG4gICAgICAgICAgICAhdmFsdWUgJiYgKFxuICAgICAgICAgICAgICA8b3B0aW9uIHNlbGVjdGVkIGRpc2FibGVkIHZhbHVlIGhpZGRlbj5cbiAgICAgICAgICAgICAgICB7cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgICAgIDwvb3B0aW9uPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICB7b3B0aW9ucy5tYXAob3B0aW9uID0+IChcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PXtvcHRpb24udmFsdWV9IHZhbHVlPXtvcHRpb24udmFsdWV9PlxuICAgICAgICAgICAgICB7b3B0aW9uLmxhYmVsfVxuICAgICAgICAgICAgPC9vcHRpb24+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvc2VsZWN0PlxuICAgICAgICB7ZXJyb3JNZXNzYWdlICYmXG4gICAgICAgICAgdGhpcy5zdGF0ZS5lcnJvcklzT3BlbiAmJiAoXG4gICAgICAgICAgICA8Rmx5b3V0XG4gICAgICAgICAgICAgIGFuY2hvcj17dGhpcy5zZWxlY3R9XG4gICAgICAgICAgICAgIGNvbG9yPVwib3JhbmdlXCJcbiAgICAgICAgICAgICAgaWRlYWxEaXJlY3Rpb249e2lkZWFsRXJyb3JEaXJlY3Rpb259XG4gICAgICAgICAgICAgIG9uRGlzbWlzcz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGVycm9ySXNPcGVuOiBmYWxzZSB9KX1cbiAgICAgICAgICAgICAgc2l6ZT1cInNtXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPEJveCBwYWRkaW5nPXszfT5cbiAgICAgICAgICAgICAgICA8VGV4dCBib2xkIGNvbG9yPVwid2hpdGVcIj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPXtgJHtpZH0tZ2VzdGFsdC1lcnJvcmB9PntlcnJvck1lc3NhZ2V9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgICAgICAgPC9Cb3g+XG4gICAgICAgICAgICA8L0ZseW91dD5cbiAgICAgICAgICApfVxuICAgICAgPC9Cb3g+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vU3Bpbm5lci5jc3MnO1xuXG5jb25zdCBTSVpFID0gNDA7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY2Nlc3NpYmlsaXR5TGFiZWw6IHN0cmluZyxcbiAgc2hvdzogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTcGlubmVyKHsgYWNjZXNzaWJpbGl0eUxhYmVsLCBzaG93IH06IFByb3BzKSB7XG4gIHJldHVybiBzaG93ID8gKFxuICAgIDxCb3ggeHM9e3sgZGlzcGxheTogJ2ZsZXgnIH19IGp1c3RpZnlDb250ZW50PVwiYXJvdW5kXCIgb3ZlcmZsb3c9XCJoaWRkZW5cIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaWNvbn0+XG4gICAgICAgIDxJY29uXG4gICAgICAgICAgaWNvbj1cImtub29wXCJcbiAgICAgICAgICBhY2Nlc3NpYmlsaXR5TGFiZWw9e2FjY2Vzc2liaWxpdHlMYWJlbH1cbiAgICAgICAgICBzaXplPXtTSVpFfVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9Cb3g+XG4gICkgOiAoXG4gICAgPGRpdiAvPlxuICApO1xufVxuXG5TcGlubmVyLnByb3BUeXBlcyA9IHtcbiAgc2hvdzogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAgYWNjZXNzaWJpbGl0eUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG59O1xuIiwiLy8gQGZsb3dcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBsYXlvdXQgZnJvbSAnLi9MYXlvdXQuY3NzJztcblxudHlwZSBUaHJlc2hvbGQgPVxuICB8IHt8IHRvcDogbnVtYmVyIHwgc3RyaW5nIHx9XG4gIHwge3wgYm90dG9tOiBudW1iZXIgfCBzdHJpbmcgfH1cbiAgfCB7fCBsZWZ0OiBudW1iZXIgfCBzdHJpbmcgfH1cbiAgfCB7fCByaWdodDogbnVtYmVyIHwgc3RyaW5nIHx9XG4gIHwge3wgdG9wOiBudW1iZXIgfCBzdHJpbmcsIGJvdHRvbTogbnVtYmVyIHwgc3RyaW5nIHx9XG4gIHwge3wgbGVmdDogbnVtYmVyIHwgc3RyaW5nLCByaWdodDogbnVtYmVyIHwgc3RyaW5nIHx9XG4gIHwge3xcbiAgICAgIHRvcDogbnVtYmVyIHwgc3RyaW5nLFxuICAgICAgbGVmdDogbnVtYmVyIHwgc3RyaW5nLFxuICAgICAgcmlnaHQ6IG51bWJlciB8IHN0cmluZyxcbiAgICAgIGJvdHRvbTogbnVtYmVyIHwgc3RyaW5nLFxuICAgIHx9O1xuXG50eXBlIFByb3BzID0ge3xcbiAgY2hpbGRyZW46IFJlYWN0Lk5vZGUsXG4gIGRhbmdlcm91c2x5U2V0WkluZGV4PzogeyBfX3pJbmRleDogbnVtYmVyIH0sXG4gIC4uLlRocmVzaG9sZCxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTdGlja3kocHJvcHM6IFByb3BzKSB7XG4gIGNvbnN0IHsgZGFuZ2Vyb3VzbHlTZXRaSW5kZXggPSB7IF9fekluZGV4OiAxIH0sIGNoaWxkcmVuIH0gPSBwcm9wcztcbiAgY29uc3Qgc3R5bGUgPSB7XG4gICAgdG9wOiBwcm9wcy50b3AgIT0gbnVsbCA/IHByb3BzLnRvcCA6IHVuZGVmaW5lZCxcbiAgICBsZWZ0OiBwcm9wcy5sZWZ0ICE9IG51bGwgPyBwcm9wcy5sZWZ0IDogdW5kZWZpbmVkLFxuICAgIHJpZ2h0OiBwcm9wcy5yaWdodCAhPSBudWxsID8gcHJvcHMucmlnaHQgOiB1bmRlZmluZWQsXG4gICAgYm90dG9tOiBwcm9wcy5ib3R0b20gIT0gbnVsbCA/IHByb3BzLmJvdHRvbSA6IHVuZGVmaW5lZCxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZXJzY29yZS1kYW5nbGVcbiAgICB6SW5kZXg6IGRhbmdlcm91c2x5U2V0WkluZGV4Ll9fekluZGV4LFxuICB9O1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtsYXlvdXQuc3RpY2t5fSBzdHlsZT17c3R5bGV9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvZGl2PlxuICApO1xufVxuXG5TdGlja3kucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIGRhbmdlcm91c2x5U2V0WkluZGV4OiBQcm9wVHlwZXMuZXhhY3Qoe1xuICAgIF9fekluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICB9KSxcbiAgdG9wOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIGxlZnQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgYm90dG9tOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIHJpZ2h0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSksXG59O1xuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY2xhc3NuYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9Td2l0Y2guY3NzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGRpc2FibGVkPzogYm9vbGVhbixcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZT86IHN0cmluZyxcbiAgb25DaGFuZ2U6ICh7IGV2ZW50OiBTeW50aGV0aWNJbnB1dEV2ZW50PD4sIHZhbHVlOiBib29sZWFuIH0pID0+IHZvaWQsXG4gIHN3aXRjaGVkPzogYm9vbGVhbixcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgZm9jdXNlZDogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTd2l0Y2ggZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHMsIFN0YXRlPiB7XG4gIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBzd2l0Y2hlZDogUHJvcFR5cGVzLmJvb2wsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgc3dpdGNoZWQ6IGZhbHNlLFxuICB9O1xuXG4gIHN0YXRlOiBTdGF0ZSA9IHtcbiAgICBmb2N1c2VkOiBmYWxzZSxcbiAgfTtcblxuICBoYW5kbGVCbHVyID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWQ6IGZhbHNlIH0pO1xuXG4gIGhhbmRsZUNoYW5nZSA9IChldmVudDogU3ludGhldGljSW5wdXRFdmVudDw+KSA9PiB7XG4gICAgY29uc3QgeyBjaGVja2VkIH0gPSBldmVudC50YXJnZXQ7XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh7XG4gICAgICBldmVudCxcbiAgICAgIHZhbHVlOiBjaGVja2VkLFxuICAgIH0pO1xuICB9O1xuXG4gIGhhbmRsZUZvY3VzID0gKCkgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBmb2N1c2VkOiB0cnVlIH0pO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGRpc2FibGVkLCBpZCwgbmFtZSwgc3dpdGNoZWQgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBjb25zdCBzd2l0Y2hTdHlsZXMgPSBjbGFzc25hbWVzKFxuICAgICAgc3R5bGVzLnN3aXRjaCxcbiAgICAgIHtcbiAgICAgICAgW3N0eWxlcy5mb2N1c2VkXTogdGhpcy5zdGF0ZS5mb2N1c2VkLFxuICAgICAgfSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgICAgZGlzYWJsZWRcbiAgICAgICAgPyBzd2l0Y2hlZFxuICAgICAgICAgID8gc3R5bGVzLnN3aXRjaEdyYXlcbiAgICAgICAgICA6IHN0eWxlcy5zd2l0Y2hMaWdodEdyYXlcbiAgICAgICAgOiBzd2l0Y2hlZFxuICAgICAgICAgID8gc3R5bGVzLnN3aXRjaERhcmtHcmF5XG4gICAgICAgICAgOiBzdHlsZXMuc3dpdGNoV2hpdGVcbiAgICApO1xuXG4gICAgY29uc3Qgc2xpZGVyU3R5bGVzID0gY2xhc3NuYW1lcyhcbiAgICAgIHN0eWxlcy5zbGlkZXIsXG4gICAgICBzd2l0Y2hlZCA/IHN0eWxlcy5zbGlkZXJSaWdodCA6IHN0eWxlcy5zbGlkZXJMZWZ0LFxuICAgICAgc3dpdGNoZWQgJiYgIWRpc2FibGVkID8gc3R5bGVzLnNsaWRlckRhcmsgOiBzdHlsZXMuc2xpZGVyTGlnaHRcbiAgICApO1xuXG4gICAgY29uc3QgaW5wdXRTdHlsZXMgPSBjbGFzc25hbWVzKHN0eWxlcy5jaGVja2JveCwge1xuICAgICAgW3N0eWxlcy5jaGVja2JveEVuYWJsZWRdOiAhZGlzYWJsZWQsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N3aXRjaFN0eWxlc30+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIGNoZWNrZWQ9e3N3aXRjaGVkfVxuICAgICAgICAgIGNsYXNzTmFtZT17aW5wdXRTdHlsZXN9XG4gICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgIGlkPXtpZH1cbiAgICAgICAgICBuYW1lPXtuYW1lfVxuICAgICAgICAgIG9uQmx1cj17dGhpcy5oYW5kbGVCbHVyfVxuICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZUNoYW5nZX1cbiAgICAgICAgICBvbkZvY3VzPXt0aGlzLmhhbmRsZUZvY3VzfVxuICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzbGlkZXJTdHlsZXN9IC8+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFRleHQgZnJvbSAnLi9UZXh0LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9UYWJzLmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY3RpdmVUYWJJbmRleDogbnVtYmVyLFxuICB0YWJzOiBBcnJheTx7fFxuICAgIHRleHQ6IFJlYWN0Lk5vZGUsXG4gICAgaHJlZjogc3RyaW5nLFxuICB8fT4sXG4gIG9uQ2hhbmdlOiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PD4sXG4gICAgYWN0aXZlVGFiSW5kZXg6IG51bWJlcixcbiAgfSkgPT4gdm9pZCxcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgZm9jdXNlZFRhYkluZGV4OiA/bnVtYmVyLFxuICBob3ZlcmVkVGFiSW5kZXg6ID9udW1iZXIsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFicyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBhY3RpdmVUYWJJbmRleDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIHRhYnM6IFByb3BUeXBlcy5hcnJheU9mKFxuICAgICAgUHJvcFR5cGVzLmV4YWN0KHtcbiAgICAgICAgdGV4dDogUHJvcFR5cGVzLm5vZGUsXG4gICAgICAgIGhyZWY6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICB9KVxuICAgICkuaXNSZXF1aXJlZCxcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgfTtcblxuICBzdGF0ZTogU3RhdGUgPSB7XG4gICAgZm9jdXNlZFRhYkluZGV4OiB1bmRlZmluZWQsXG4gICAgaG92ZXJlZFRhYkluZGV4OiB1bmRlZmluZWQsXG4gIH07XG5cbiAgaGFuZGxlVGFiQ2xpY2sgPSAoaTogbnVtYmVyLCBlOiBTeW50aGV0aWNNb3VzZUV2ZW50PD4pID0+IHtcbiAgICBjb25zdCB7IG9uQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIG9uQ2hhbmdlKHsgYWN0aXZlVGFiSW5kZXg6IGksIGV2ZW50OiBlIH0pO1xuICB9O1xuXG4gIGhhbmRsZVRhYkZvY3VzID0gKGk6IG51bWJlcikgPT4gdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWRUYWJJbmRleDogaSB9KTtcblxuICBoYW5kbGVUYWJCbHVyID0gKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGZvY3VzZWRUYWJJbmRleDogdW5kZWZpbmVkIH0pO1xuXG4gIGhhbmRsZVRhYk1vdXNlRW50ZXIgPSAoaTogbnVtYmVyKSA9PiB0aGlzLnNldFN0YXRlKHsgaG92ZXJlZFRhYkluZGV4OiBpIH0pO1xuXG4gIGhhbmRsZVRhYk1vdXNlTGVhdmUgPSAoKSA9PiB0aGlzLnNldFN0YXRlKHsgaG92ZXJlZFRhYkluZGV4OiB1bmRlZmluZWQgfSk7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgdGFicywgYWN0aXZlVGFiSW5kZXggfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgeyBmb2N1c2VkVGFiSW5kZXgsIGhvdmVyZWRUYWJJbmRleCB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5UYWJzfSByb2xlPVwidGFibGlzdFwiPlxuICAgICAgICB7dGFicy5tYXAoKHsgdGV4dCwgaHJlZiB9LCBpKSA9PiB7XG4gICAgICAgICAgY29uc3QgaXNBY3RpdmUgPSBpID09PSBhY3RpdmVUYWJJbmRleDtcbiAgICAgICAgICBjb25zdCBpc0hvdmVyZWQgPSBpID09PSBob3ZlcmVkVGFiSW5kZXg7XG4gICAgICAgICAgY29uc3QgaXNGb2N1c2VkID0gaSA9PT0gZm9jdXNlZFRhYkluZGV4O1xuICAgICAgICAgIGNvbnN0IGNzID0gY2xhc3NuYW1lcyhzdHlsZXMudGFiLCB7XG4gICAgICAgICAgICBbc3R5bGVzLnRhYklzTm90QWN0aXZlXTogIWlzQWN0aXZlLFxuICAgICAgICAgICAgW3N0eWxlcy50YWJJc0FjdGl2ZV06IGlzQWN0aXZlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8YVxuICAgICAgICAgICAgICBhcmlhLXNlbGVjdGVkPXtpc0FjdGl2ZX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjc31cbiAgICAgICAgICAgICAgaHJlZj17aHJlZn1cbiAgICAgICAgICAgICAga2V5PXtpfVxuICAgICAgICAgICAgICBvbkNsaWNrPXsoZTogU3ludGhldGljTW91c2VFdmVudDw+KSA9PiB0aGlzLmhhbmRsZVRhYkNsaWNrKGksIGUpfVxuICAgICAgICAgICAgICBvbkZvY3VzPXsoKSA9PiB0aGlzLmhhbmRsZVRhYkZvY3VzKGkpfVxuICAgICAgICAgICAgICBvbkJsdXI9e3RoaXMuaGFuZGxlVGFiQmx1cn1cbiAgICAgICAgICAgICAgb25Nb3VzZUVudGVyPXsoKSA9PiB0aGlzLmhhbmRsZVRhYk1vdXNlRW50ZXIoaSl9XG4gICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17dGhpcy5oYW5kbGVUYWJNb3VzZUxlYXZlfVxuICAgICAgICAgICAgICByb2xlPVwidGFiXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPFRleHRcbiAgICAgICAgICAgICAgICBib2xkXG4gICAgICAgICAgICAgICAgY29sb3I9e2lzQWN0aXZlIHx8IGlzSG92ZXJlZCB8fCBpc0ZvY3VzZWQgPyAnZGFya0dyYXknIDogJ2dyYXknfVxuICAgICAgICAgICAgICAgIHNpemU9XCJtZFwiXG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7dGV4dH1cbiAgICAgICAgICAgICAgPC9UZXh0PlxuICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICk7XG4gICAgICAgIH0pfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IEZseW91dCBmcm9tICcuL0ZseW91dC5qcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBUZXh0IGZyb20gJy4vVGV4dC5qcyc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vVGV4dEFyZWEuY3NzJztcblxudHlwZSBTdGF0ZSA9IHtcbiAgZm9jdXNlZDogYm9vbGVhbixcbiAgZXJyb3JJc09wZW46IGJvb2xlYW4sXG4gIGVycm9yTWVzc2FnZT86IHN0cmluZyxcbn07XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBlcnJvck1lc3NhZ2U/OiBzdHJpbmcsXG4gIGRpc2FibGVkPzogYm9vbGVhbixcbiAgaGFzRXJyb3I/OiBib29sZWFuLFxuICBpZDogc3RyaW5nLFxuICBpZGVhbEVycm9yRGlyZWN0aW9uPzogJ3VwJyB8ICdyaWdodCcgfCAnZG93bicgfCAnbGVmdCcgLyogZGVmYXVsdDogcmlnaHQgKi8sXG4gIG5hbWU/OiBzdHJpbmcsXG4gIG9uQmx1cj86ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0ZvY3VzRXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4sXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgfSkgPT4gdm9pZCxcbiAgb25DaGFuZ2U6ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0lucHV0RXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4sXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgfSkgPT4gdm9pZCxcbiAgb25Gb2N1cz86ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0ZvY3VzRXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4sXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgfSkgPT4gdm9pZCxcbiAgb25LZXlEb3duPzogKHtcbiAgICBldmVudDogU3ludGhldGljS2V5Ym9hcmRFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PixcbiAgICB2YWx1ZTogc3RyaW5nLFxuICB9KSA9PiB2b2lkLFxuICBwbGFjZWhvbGRlcj86IHN0cmluZyxcbiAgcm93cz86IG51bWJlciAvKiBkZWZhdWx0OiAzICovLFxuICB2YWx1ZT86IHN0cmluZyxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0QXJlYSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2wsXG4gICAgZXJyb3JNZXNzYWdlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGhhc0Vycm9yOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGlkZWFsRXJyb3JEaXJlY3Rpb246IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkJsdXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIG9uRm9jdXM6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uS2V5RG93bjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgcGxhY2Vob2xkZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgcm93czogUHJvcFR5cGVzLm51bWJlcixcbiAgICB2YWx1ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICBoYXNFcnJvcjogZmFsc2UsXG4gICAgaWRlYWxFcnJvckRpcmVjdGlvbjogJ3JpZ2h0JyxcbiAgICByb3dzOiAzLFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIGZvY3VzZWQ6IGZhbHNlLFxuICAgIGVycm9ySXNPcGVuOiBmYWxzZSxcbiAgfTtcblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzOiBQcm9wcywgc3RhdGU6IFN0YXRlKSB7XG4gICAgaWYgKHByb3BzLmVycm9yTWVzc2FnZSAhPT0gc3RhdGUuZXJyb3JNZXNzYWdlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcklzT3BlbjogISFwcm9wcy5lcnJvck1lc3NhZ2UsXG4gICAgICAgIGVycm9yTWVzc2FnZTogcHJvcHMuZXJyb3JNZXNzYWdlLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGhhbmRsZUNoYW5nZSA9IChldmVudDogU3ludGhldGljSW5wdXRFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PikgPT4ge1xuICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgZXZlbnQsXG4gICAgICB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLnByb3BzLmVycm9yTWVzc2FnZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9ySXNPcGVuOiB0cnVlIH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVCbHVyID0gKGV2ZW50OiBTeW50aGV0aWNGb2N1c0V2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMuZXJyb3JNZXNzYWdlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3JJc09wZW46IGZhbHNlIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9wcy5vbkJsdXIpIHtcbiAgICAgIHRoaXMucHJvcHMub25CbHVyKHtcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIHZhbHVlOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZUZvY3VzID0gKGV2ZW50OiBTeW50aGV0aWNGb2N1c0V2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMuZXJyb3JNZXNzYWdlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3JJc09wZW46IHRydWUgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BzLm9uRm9jdXMpIHtcbiAgICAgIHRoaXMucHJvcHMub25Gb2N1cyh7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVLZXlEb3duID0gKGV2ZW50OiBTeW50aGV0aWNLZXlib2FyZEV2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMub25LZXlEb3duKSB7XG4gICAgICB0aGlzLnByb3BzLm9uS2V5RG93bih7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB0ZXh0YXJlYTogP0hUTUxFbGVtZW50O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXNhYmxlZCxcbiAgICAgIGVycm9yTWVzc2FnZSxcbiAgICAgIGhhc0Vycm9yLFxuICAgICAgaWQsXG4gICAgICBpZGVhbEVycm9yRGlyZWN0aW9uLFxuICAgICAgbmFtZSxcbiAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgcm93cyxcbiAgICAgIHZhbHVlLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzbmFtZXMoXG4gICAgICBzdHlsZXMudGV4dEFyZWEsXG4gICAgICBkaXNhYmxlZCA/IHN0eWxlcy5kaXNhYmxlZCA6IHN0eWxlcy5lbmFibGVkLFxuICAgICAgaGFzRXJyb3IgfHwgZXJyb3JNZXNzYWdlID8gc3R5bGVzLmVycm9yZWQgOiBzdHlsZXMubm9ybWFsXG4gICAgKTtcblxuICAgIHJldHVybiAoXG4gICAgICA8c3Bhbj5cbiAgICAgICAgPHRleHRhcmVhXG4gICAgICAgICAgYXJpYS1kZXNjcmliZWRieT17XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgJiYgdGhpcy5zdGF0ZS5mb2N1c2VkID8gYCR7aWR9LWdlc3RhbHQtZXJyb3JgIDogbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgICBhcmlhLWludmFsaWQ9e2Vycm9yTWVzc2FnZSB8fCBoYXNFcnJvciA/ICd0cnVlJyA6ICdmYWxzZSd9XG4gICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzfVxuICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICBpZD17aWR9XG4gICAgICAgICAgbmFtZT17bmFtZX1cbiAgICAgICAgICBvbkJsdXI9e3RoaXMuaGFuZGxlQmx1cn1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgb25Gb2N1cz17dGhpcy5oYW5kbGVGb2N1c31cbiAgICAgICAgICBvbktleURvd249e3RoaXMuaGFuZGxlS2V5RG93bn1cbiAgICAgICAgICBwbGFjZWhvbGRlcj17cGxhY2Vob2xkZXJ9XG4gICAgICAgICAgcmVmPXtjID0+IHtcbiAgICAgICAgICAgIHRoaXMudGV4dGFyZWEgPSBjO1xuICAgICAgICAgIH19XG4gICAgICAgICAgcm93cz17cm93c31cbiAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgIC8+XG4gICAgICAgIHtlcnJvck1lc3NhZ2UgJiYgdGhpcy5zdGF0ZS5lcnJvcklzT3BlbiA/IChcbiAgICAgICAgICA8Rmx5b3V0XG4gICAgICAgICAgICBhbmNob3I9e3RoaXMudGV4dGFyZWF9XG4gICAgICAgICAgICBjb2xvcj1cIm9yYW5nZVwiXG4gICAgICAgICAgICBpZGVhbERpcmVjdGlvbj17aWRlYWxFcnJvckRpcmVjdGlvbn1cbiAgICAgICAgICAgIG9uRGlzbWlzcz17KCkgPT4gdGhpcy5zZXRTdGF0ZSh7IGVycm9ySXNPcGVuOiBmYWxzZSB9KX1cbiAgICAgICAgICAgIHNpemU9XCJzbVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPEJveCBwYWRkaW5nPXszfT5cbiAgICAgICAgICAgICAgPFRleHQgYm9sZCBjb2xvcj1cIndoaXRlXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gaWQ9e2Ake2lkfS1nZXN0YWx0LWVycm9yYH0+e2Vycm9yTWVzc2FnZX08L3NwYW4+XG4gICAgICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgICAgIDwvQm94PlxuICAgICAgICAgIDwvRmx5b3V0PlxuICAgICAgICApIDogbnVsbH1cbiAgICAgIDwvc3Bhbj5cbiAgICApO1xuICB9XG59XG4iLCIvLyBAZmxvd1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsYXNzbmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgRmx5b3V0IGZyb20gJy4vRmx5b3V0LmpzJztcbmltcG9ydCBCb3ggZnJvbSAnLi9Cb3guanMnO1xuaW1wb3J0IFRleHQgZnJvbSAnLi9UZXh0LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9UZXh0RmllbGQuY3NzJztcblxudHlwZSBTdGF0ZSA9IHtcbiAgZm9jdXNlZDogYm9vbGVhbixcbiAgZXJyb3JJc09wZW46IGJvb2xlYW4sXG4gIGVycm9yTWVzc2FnZT86IHN0cmluZyxcbn07XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhdXRvQ29tcGxldGU/OiAnY3VycmVudC1wYXNzd29yZCcgfCAnb24nIHwgJ29mZicgfCAndXNlcm5hbWUnLFxuICBkaXNhYmxlZD86IGJvb2xlYW4sXG4gIGVycm9yTWVzc2FnZT86IHN0cmluZyxcbiAgaGFzRXJyb3I/OiBib29sZWFuLFxuICBpZDogc3RyaW5nLFxuICBpZGVhbEVycm9yRGlyZWN0aW9uPzogJ3VwJyB8ICdyaWdodCcgfCAnZG93bicgfCAnbGVmdCcgLyogZGVmYXVsdDogcmlnaHQgKi8sXG4gIG5hbWU/OiBzdHJpbmcsXG4gIG9uQmx1cj86ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0ZvY3VzRXZlbnQ8SFRNTElucHV0RWxlbWVudD4sXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgfSkgPT4gdm9pZCxcbiAgb25DaGFuZ2U6ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0lucHV0RXZlbnQ8SFRNTElucHV0RWxlbWVudD4sXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgfSkgPT4gdm9pZCxcbiAgb25Gb2N1cz86ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0ZvY3VzRXZlbnQ8SFRNTElucHV0RWxlbWVudD4sXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgfSkgPT4gdm9pZCxcbiAgb25LZXlEb3duPzogKHtcbiAgICBldmVudDogU3ludGhldGljS2V5Ym9hcmRFdmVudDxIVE1MSW5wdXRFbGVtZW50PixcbiAgICB2YWx1ZTogc3RyaW5nLFxuICB9KSA9PiB2b2lkLFxuICBwbGFjZWhvbGRlcj86IHN0cmluZyxcbiAgdHlwZT86ICdkYXRlJyB8ICdlbWFpbCcgfCAnbnVtYmVyJyB8ICdwYXNzd29yZCcgfCAndGV4dCcgfCAndXJsJyxcbiAgdmFsdWU/OiBzdHJpbmcsXG58fTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dEZpZWxkIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzLCBTdGF0ZT4ge1xuICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgIGF1dG9Db21wbGV0ZTogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAgICdjdXJyZW50LXBhc3N3b3JkJyxcbiAgICAgICdvbicsXG4gICAgICAnb2ZmJyxcbiAgICAgICd1c2VybmFtZScsXG4gICAgXSksXG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIGVycm9yTWVzc2FnZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBoYXNFcnJvcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBpZGVhbEVycm9yRGlyZWN0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgb25CbHVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvbkZvY3VzOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbktleURvd246IFByb3BUeXBlcy5mdW5jLFxuICAgIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHR5cGU6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgICAnZGF0ZScsXG4gICAgICAnZW1haWwnLFxuICAgICAgJ251bWJlcicsXG4gICAgICAncGFzc3dvcmQnLFxuICAgICAgJ3RleHQnLFxuICAgICAgJ3VybCcsXG4gICAgXSksXG4gICAgdmFsdWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgaGFzRXJyb3I6IGZhbHNlLFxuICAgIGlkZWFsRXJyb3JEaXJlY3Rpb246ICdyaWdodCcsXG4gICAgdHlwZTogJ3RleHQnLFxuICB9O1xuXG4gIHN0YXRlID0ge1xuICAgIGZvY3VzZWQ6IGZhbHNlLFxuICAgIGVycm9ySXNPcGVuOiBmYWxzZSxcbiAgfTtcblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzOiBQcm9wcywgc3RhdGU6IFN0YXRlKSB7XG4gICAgaWYgKHByb3BzLmVycm9yTWVzc2FnZSAhPT0gc3RhdGUuZXJyb3JNZXNzYWdlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcklzT3BlbjogISFwcm9wcy5lcnJvck1lc3NhZ2UsXG4gICAgICAgIGVycm9yTWVzc2FnZTogcHJvcHMuZXJyb3JNZXNzYWdlLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGhhbmRsZUNoYW5nZSA9IChldmVudDogU3ludGhldGljSW5wdXRFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4ge1xuICAgIHRoaXMucHJvcHMub25DaGFuZ2Uoe1xuICAgICAgZXZlbnQsXG4gICAgICB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICB9KTtcbiAgfTtcblxuICBoYW5kbGVCbHVyID0gKGV2ZW50OiBTeW50aGV0aWNGb2N1c0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMuZXJyb3JNZXNzYWdlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3JJc09wZW46IGZhbHNlIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9wcy5vbkJsdXIpIHtcbiAgICAgIHRoaXMucHJvcHMub25CbHVyKHtcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIHZhbHVlOiBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlLFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZUZvY3VzID0gKGV2ZW50OiBTeW50aGV0aWNGb2N1c0V2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMuZXJyb3JNZXNzYWdlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHsgZXJyb3JJc09wZW46IHRydWUgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BzLm9uRm9jdXMpIHtcbiAgICAgIHRoaXMucHJvcHMub25Gb2N1cyh7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBoYW5kbGVLZXlEb3duID0gKGV2ZW50OiBTeW50aGV0aWNLZXlib2FyZEV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgaWYgKHRoaXMucHJvcHMub25LZXlEb3duKSB7XG4gICAgICB0aGlzLnByb3BzLm9uS2V5RG93bih7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICB2YWx1ZTogZXZlbnQuY3VycmVudFRhcmdldC52YWx1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB0ZXh0ZmllbGQ6ID9IVE1MRWxlbWVudDtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXV0b0NvbXBsZXRlLFxuICAgICAgZGlzYWJsZWQsXG4gICAgICBlcnJvck1lc3NhZ2UsXG4gICAgICBoYXNFcnJvcixcbiAgICAgIGlkLFxuICAgICAgaWRlYWxFcnJvckRpcmVjdGlvbixcbiAgICAgIG5hbWUsXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIHR5cGUsXG4gICAgICB2YWx1ZSxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc25hbWVzKFxuICAgICAgc3R5bGVzLnRleHRGaWVsZCxcbiAgICAgIGRpc2FibGVkID8gc3R5bGVzLmRpc2FibGVkIDogc3R5bGVzLmVuYWJsZWQsXG4gICAgICBoYXNFcnJvciB8fCBlcnJvck1lc3NhZ2UgPyBzdHlsZXMuZXJyb3JlZCA6IHN0eWxlcy5ub3JtYWxcbiAgICApO1xuXG4gICAgLy8gdHlwZT0nbnVtYmVyJyBkb2Vzbid0IHdvcmsgb24gaW9zIHNhZmFyaSB3aXRob3V0IGEgcGF0dGVyblxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE0NDQ3NjY4L2lucHV0LXR5cGUtbnVtYmVyLWlzLW5vdC1zaG93aW5nLWEtbnVtYmVyLWtleXBhZC1vbi1pb3NcbiAgICBjb25zdCBwYXR0ZXJuID0gdHlwZSA9PT0gJ251bWJlcicgPyAnXFxcXGQqJyA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiAoXG4gICAgICA8c3Bhbj5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgYXJpYS1kZXNjcmliZWRieT17XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgJiYgdGhpcy5zdGF0ZS5mb2N1c2VkID8gYCR7aWR9LWdlc3RhbHQtZXJyb3JgIDogbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgICBhcmlhLWludmFsaWQ9e2Vycm9yTWVzc2FnZSB8fCBoYXNFcnJvciA/ICd0cnVlJyA6ICdmYWxzZSd9XG4gICAgICAgICAgYXV0b0NvbXBsZXRlPXthdXRvQ29tcGxldGV9XG4gICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzfVxuICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICBpZD17aWR9XG4gICAgICAgICAgbmFtZT17bmFtZX1cbiAgICAgICAgICBvbkJsdXI9e3RoaXMuaGFuZGxlQmx1cn1cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgb25Gb2N1cz17dGhpcy5oYW5kbGVGb2N1c31cbiAgICAgICAgICBvbktleURvd249e3RoaXMuaGFuZGxlS2V5RG93bn1cbiAgICAgICAgICBwYXR0ZXJuPXtwYXR0ZXJufVxuICAgICAgICAgIHBsYWNlaG9sZGVyPXtwbGFjZWhvbGRlcn1cbiAgICAgICAgICByZWY9e2MgPT4ge1xuICAgICAgICAgICAgdGhpcy50ZXh0ZmllbGQgPSBjO1xuICAgICAgICAgIH19XG4gICAgICAgICAgdHlwZT17dHlwZX1cbiAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgIC8+XG4gICAgICAgIHtlcnJvck1lc3NhZ2UgJiZcbiAgICAgICAgICB0aGlzLnN0YXRlLmVycm9ySXNPcGVuICYmIChcbiAgICAgICAgICAgIDxGbHlvdXRcbiAgICAgICAgICAgICAgYW5jaG9yPXt0aGlzLnRleHRmaWVsZH1cbiAgICAgICAgICAgICAgY29sb3I9XCJvcmFuZ2VcIlxuICAgICAgICAgICAgICBpZGVhbERpcmVjdGlvbj17aWRlYWxFcnJvckRpcmVjdGlvbn1cbiAgICAgICAgICAgICAgb25EaXNtaXNzPXsoKSA9PiB0aGlzLnNldFN0YXRlKHsgZXJyb3JJc09wZW46IGZhbHNlIH0pfVxuICAgICAgICAgICAgICBzaXplPVwic21cIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8Qm94IHBhZGRpbmc9ezN9PlxuICAgICAgICAgICAgICAgIDxUZXh0IGJvbGQgY29sb3I9XCJ3aGl0ZVwiPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9e2Ake2lkfS1nZXN0YWx0LWVycm9yYH0+e2Vycm9yTWVzc2FnZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9UZXh0PlxuICAgICAgICAgICAgICA8L0JveD5cbiAgICAgICAgICAgIDwvRmx5b3V0PlxuICAgICAgICAgICl9XG4gICAgICA8L3NwYW4+XG4gICAgKTtcbiAgfVxufVxuIiwiLy8gQGZsb3dcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBNYXNrIGZyb20gJy4vTWFzay5qcyc7XG5pbXBvcnQgVGV4dCBmcm9tICcuL1RleHQuanMnO1xuaW1wb3J0IEljb24gZnJvbSAnLi9JY29uLmpzJztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNvbG9yPzogJ2RhcmtHcmF5JyB8ICdvcmFuZ2UnLFxuICBpY29uPzogJ2Fycm93LWNpcmNsZS1mb3J3YXJkJywgLy8gbGVhdmluZyBvcGVuIHRvIGFkZGl0aW9uYWwgaWNvbnMgaW4gdGhlIGZ1dHVyZVxuICB0ZXh0OiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+LFxuICB0aHVtYm5haWw/OiBSZWFjdC5Ob2RlLFxufH07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRvYXN0KHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7IGNvbG9yID0gJ2RhcmtHcmF5JywgaWNvbiwgdGh1bWJuYWlsLCB0ZXh0IH0gPSBwcm9wcztcblxuICBsZXQgY29udGVudHM7XG4gIC8vIENvbmZpcm1hdGlvbiBUb2FzdHNcbiAgaWYgKHRleHQgaW5zdGFuY2VvZiBBcnJheSAmJiB0ZXh0Lmxlbmd0aCA+IDEpIHtcbiAgICBjb250ZW50cyA9IChcbiAgICAgIDxCb3ggeHM9e3sgZGlzcGxheTogJ2ZsZXgnIH19PlxuICAgICAgICA8Qm94IHhzPXt7IGRpc3BsYXk6ICdmbGV4Q29sdW1uJyB9fSBmbGV4PVwibm9uZVwiIGp1c3RpZnlDb250ZW50PVwiY2VudGVyXCI+XG4gICAgICAgICAge3RodW1ibmFpbCA/IChcbiAgICAgICAgICAgIDxNYXNrIHNoYXBlPVwicm91bmRlZFwiIGhlaWdodD17NDh9IHdpZHRoPXs0OH0+XG4gICAgICAgICAgICAgIHt0aHVtYm5haWx9XG4gICAgICAgICAgICA8L01hc2s+XG4gICAgICAgICAgKSA6IG51bGx9XG4gICAgICAgIDwvQm94PlxuICAgICAgICA8Qm94XG4gICAgICAgICAgeHM9e3sgZGlzcGxheTogJ2ZsZXhDb2x1bW4nIH19XG4gICAgICAgICAganVzdGlmeUNvbnRlbnQ9XCJjZW50ZXJcIlxuICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3sgX19zdHlsZTogeyBwYWRkaW5nTGVmdDogMTAgfSB9fVxuICAgICAgICA+XG4gICAgICAgICAgPEJveFxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbmxpbmVTdHlsZT17eyBfX3N0eWxlOiB7IGZvbnRXZWlnaHQ6ICdub3JtYWwnIH0gfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8VGV4dCBjb2xvcj1cIndoaXRlXCIgc2l6ZT1cImxnXCI+XG4gICAgICAgICAgICAgIHt0ZXh0WzBdfVxuICAgICAgICAgICAgPC9UZXh0PlxuICAgICAgICAgIDwvQm94PlxuICAgICAgICAgIDxUZXh0IGJvbGQgY29sb3I9XCJ3aGl0ZVwiIHNpemU9XCJsZ1wiPlxuICAgICAgICAgICAge3RleHRbMV19XG4gICAgICAgICAgPC9UZXh0PlxuICAgICAgICA8L0JveD5cbiAgICAgIDwvQm94PlxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG9hc3RzIGFzIEd1aWRlc1xuICAgIGNvbnRlbnRzID0gKFxuICAgICAgPEJveFxuICAgICAgICB4cz17eyBkaXNwbGF5OiAnZmxleCcgfX1cbiAgICAgICAganVzdGlmeUNvbnRlbnQ9XCJiZXR3ZWVuXCJcbiAgICAgICAgYWxpZ25JdGVtcz1cImNlbnRlclwiXG4gICAgICA+XG4gICAgICAgIDxUZXh0IGJvbGQgY29sb3I9XCJ3aGl0ZVwiIHNpemU9XCJsZ1wiPlxuICAgICAgICAgIHt0ZXh0fVxuICAgICAgICA8L1RleHQ+XG4gICAgICAgIHtpY29uICYmIChcbiAgICAgICAgICA8Qm94IGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3sgX19zdHlsZTogeyBwYWRkaW5nTGVmdDogMjQgfSB9fT5cbiAgICAgICAgICAgIDxJY29uIGFjY2Vzc2liaWxpdHlMYWJlbD1cIlwiIGNvbG9yPVwid2hpdGVcIiBpY29uPXtpY29ufSBzaXplPXszNn0gLz5cbiAgICAgICAgICA8L0JveD5cbiAgICAgICAgKX1cbiAgICAgIDwvQm94PlxuICAgICk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxCb3ggbWFyZ2luQm90dG9tPXszfSBwYWRkaW5nWD17NH0gbWF4V2lkdGg9ezM3Nn0gd2lkdGg9XCIxMDB2d1wiPlxuICAgICAgPEJveCBjb2xvcj17Y29sb3J9IGZpdCBwYWRkaW5nWD17OH0gcGFkZGluZ1k9ezV9IHNoYXBlPVwicGlsbFwiPlxuICAgICAgICB7Y29udGVudHN9XG4gICAgICA8L0JveD5cbiAgICA8L0JveD5cbiAgKTtcbn1cblxuVG9hc3QucHJvcFR5cGVzID0ge1xuICBjb2xvcjogUHJvcFR5cGVzLm9uZU9mKFsnZGFya0dyYXknLCAnb3JhbmdlJ10pLFxuICBpY29uOiBQcm9wVHlwZXMub25lT2YoWydhcnJvdy1jaXJjbGUtZm9yd2FyZCddKSwgLy8gbGVhdmluZyBvcGVuIHRvIGFkZGl0aW9uYWwgaWNvbnMgaW4gdGhlIGZ1dHVyZVxuICB0ZXh0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxuICBdKS5pc1JlcXVpcmVkLFxuICB0aHVtYm5haWw6IFByb3BUeXBlcy5ub2RlLFxufTtcbiIsIi8vIEBmbG93XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IEJveCBmcm9tICcuL0JveC5qcyc7XG5pbXBvcnQgQ29udHJvbGxlciBmcm9tICcuL0NvbnRyb2xsZXIuanMnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgYW5jaG9yOiA/SFRNTEVsZW1lbnQsXG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgaWRlYWxEaXJlY3Rpb24/OiAndXAnIHwgJ3JpZ2h0JyB8ICdkb3duJyB8ICdsZWZ0JyxcbiAgb25EaXNtaXNzOiAoKSA9PiB2b2lkLFxuICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3I/OiBib29sZWFuLFxuICBzaXplPzogJ3hzJyB8ICdzbScgfCAnbWQnIHwgJ2xnJyB8ICd4bCcgLyogZGVmYXVsdCBtZCAqLyxcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUb29sdGlwKHByb3BzOiBQcm9wcykge1xuICBjb25zdCB7XG4gICAgYW5jaG9yLFxuICAgIGNoaWxkcmVuLFxuICAgIGlkZWFsRGlyZWN0aW9uLFxuICAgIG9uRGlzbWlzcyxcbiAgICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3IgPSB0cnVlLFxuICAgIHNpemUgPSAnbWQnLFxuICB9ID0gcHJvcHM7XG5cbiAgaWYgKCFhbmNob3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPENvbnRyb2xsZXJcbiAgICAgIGFuY2hvcj17YW5jaG9yfVxuICAgICAgYmdDb2xvcj1cImRhcmtHcmF5XCJcbiAgICAgIGlkZWFsRGlyZWN0aW9uPXtpZGVhbERpcmVjdGlvbn1cbiAgICAgIHBvc2l0aW9uUmVsYXRpdmVUb0FuY2hvcj17cG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yfVxuICAgICAgb25EaXNtaXNzPXtvbkRpc21pc3N9XG4gICAgICBzaXplPXtzaXplfVxuICAgID5cbiAgICAgIDxCb3ggY29sdW1uPXsxMn0gcGFkZGluZz17M30+XG4gICAgICAgIHtjaGlsZHJlbn1cbiAgICAgIDwvQm94PlxuICAgIDwvQ29udHJvbGxlcj5cbiAgKTtcbn1cblxuVG9vbHRpcC5wcm9wVHlwZXMgPSB7XG4gIGFuY2hvcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBjb250YWluczogUHJvcFR5cGVzLmZ1bmMsXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBQcm9wVHlwZXMuZnVuYyxcbiAgfSksXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgaWRlYWxEaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ3VwJywgJ3JpZ2h0JywgJ2Rvd24nLCAnbGVmdCddKSxcbiAgb25EaXNtaXNzOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBwb3NpdGlvblJlbGF0aXZlVG9BbmNob3I6IFByb3BUeXBlcy5ib29sLFxuICBzaXplOiBQcm9wVHlwZXMub25lT2YoWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddKSxcbn07XG4iLCIvLyBAZmxvd1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbGFzc25hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1RvdWNoYWJsZS5jc3MnO1xuXG50eXBlIFNoYXBlID1cbiAgfCAnc3F1YXJlJ1xuICB8ICdyb3VuZGVkJ1xuICB8ICdwaWxsJ1xuICB8ICdjaXJjbGUnXG4gIHwgJ3JvdW5kZWRUb3AnXG4gIHwgJ3JvdW5kZWRCb3R0b20nXG4gIHwgJ3JvdW5kZWRMZWZ0J1xuICB8ICdyb3VuZGVkUmlnaHQnO1xuXG50eXBlIE1vdXNlQ3Vyc29yID1cbiAgfCAnY29weSdcbiAgfCAnZ3JhYidcbiAgfCAnZ3JhYmJpbmcnXG4gIHwgJ21vdmUnXG4gIHwgJ25vRHJvcCdcbiAgfCAncG9pbnRlcidcbiAgfCAnem9vbUluJ1xuICB8ICd6b29tT3V0JztcblxudHlwZSBQcm9wcyA9IHt8XG4gIGNoaWxkcmVuPzogUmVhY3QuTm9kZSxcbiAgZnVsbEhlaWdodD86IGJvb2xlYW4sXG4gIGZ1bGxXaWR0aD86IGJvb2xlYW4sXG4gIG1vdXNlQ3Vyc29yPzogTW91c2VDdXJzb3IsXG4gIG9uTW91c2VFbnRlcj86ICh7IGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50PiB9KSA9PiB2b2lkLFxuICBvbk1vdXNlTGVhdmU/OiAoeyBldmVudDogU3ludGhldGljTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD4gfSkgPT4gdm9pZCxcbiAgb25Ub3VjaD86ICh7XG4gICAgZXZlbnQ6XG4gICAgICB8IFN5bnRoZXRpY01vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+XG4gICAgICB8IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ8SFRNTERpdkVsZW1lbnQ+LFxuICB9KSA9PiB2b2lkLFxuICBzaGFwZT86IFNoYXBlLFxufH07XG5cbmNvbnN0IFNQQUNFX0NIQVJfQ09ERSA9IDMyO1xuY29uc3QgRU5URVJfQ0hBUl9DT0RFID0gMTM7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvdWNoYWJsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxQcm9wcz4ge1xuICBoYW5kbGVLZXlQcmVzcyA9IChldmVudDogU3ludGhldGljS2V5Ym9hcmRFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uVG91Y2ggfSA9IHRoaXMucHJvcHM7XG4gICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHNwYWNlIG9yIGVudGVyIHdlcmUgcHJlc3NlZFxuICAgIGlmIChcbiAgICAgIG9uVG91Y2ggJiZcbiAgICAgIChldmVudC5jaGFyQ29kZSA9PT0gU1BBQ0VfQ0hBUl9DT0RFIHx8IGV2ZW50LmNoYXJDb2RlID09PSBFTlRFUl9DSEFSX0NPREUpXG4gICAgKSB7XG4gICAgICAvLyBQcmV2ZW50IHRoZSBkZWZhdWx0IGFjdGlvbiB0byBzdG9wIHNjcm9sbGluZyB3aGVuIHNwYWNlIGlzIHByZXNzZWRcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBvblRvdWNoKHsgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjaGlsZHJlbixcbiAgICAgIGZ1bGxXaWR0aCA9IHRydWUsXG4gICAgICBmdWxsSGVpZ2h0LFxuICAgICAgbW91c2VDdXJzb3IgPSAncG9pbnRlcicsXG4gICAgICBvbk1vdXNlRW50ZXIsXG4gICAgICBvbk1vdXNlTGVhdmUsXG4gICAgICBvblRvdWNoLFxuICAgICAgc2hhcGUgPSAnc3F1YXJlJyxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGNvbnN0IGNsYXNzZXMgPSBjbGFzc25hbWVzKFxuICAgICAgc3R5bGVzLnRvdWNoYWJsZSxcbiAgICAgIHN0eWxlc1ttb3VzZUN1cnNvcl0sXG4gICAgICBzdHlsZXNbc2hhcGVdLFxuICAgICAge1xuICAgICAgICBbc3R5bGVzLmZ1bGxIZWlnaHRdOiBmdWxsSGVpZ2h0LFxuICAgICAgICBbc3R5bGVzLmZ1bGxXaWR0aF06IGZ1bGxXaWR0aCxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXZcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzfVxuICAgICAgICBvbkNsaWNrPXtldmVudCA9PiBvblRvdWNoICYmIG9uVG91Y2goeyBldmVudCB9KX1cbiAgICAgICAgb25Nb3VzZUVudGVyPXtldmVudCA9PiBvbk1vdXNlRW50ZXIgJiYgb25Nb3VzZUVudGVyKHsgZXZlbnQgfSl9XG4gICAgICAgIG9uTW91c2VMZWF2ZT17ZXZlbnQgPT4gb25Nb3VzZUxlYXZlICYmIG9uTW91c2VMZWF2ZSh7IGV2ZW50IH0pfVxuICAgICAgICBvbktleVByZXNzPXt0aGlzLmhhbmRsZUtleVByZXNzfVxuICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgdGFiSW5kZXg9XCIwXCJcbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5Ub3VjaGFibGUucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIGZ1bGxIZWlnaHQ6IFByb3BUeXBlcy5ib29sLFxuICBmdWxsV2lkdGg6IFByb3BUeXBlcy5ib29sLFxuICBtb3VzZUN1cnNvcjogUHJvcFR5cGVzLm9uZU9mKFtcbiAgICAnY29weScsXG4gICAgJ2dyYWInLFxuICAgICdncmFiYmluZycsXG4gICAgJ21vdmUnLFxuICAgICdub0Ryb3AnLFxuICAgICdwb2ludGVyJyxcbiAgICAnem9vbUluJyxcbiAgICAnem9vbU91dCcsXG4gIF0pLFxuICBvblRvdWNoOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZUVudGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgb25Nb3VzZUxlYXZlOiBQcm9wVHlwZXMuZnVuYyxcbiAgc2hhcGU6IFByb3BUeXBlcy5vbmVPZihbXG4gICAgJ3NxdWFyZScsXG4gICAgJ3JvdW5kZWQnLFxuICAgICdwaWxsJyxcbiAgICAnY2lyY2xlJyxcbiAgICAncm91bmRlZFRvcCcsXG4gICAgJ3JvdW5kZWRCb3R0b20nLFxuICAgICdyb3VuZGVkTGVmdCcsXG4gICAgJ3JvdW5kZWRSaWdodCcsXG4gIF0pLFxufTtcbiIsIi8vIEBmbG93XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9WaWRlby5jc3MnO1xuXG50eXBlIFByb3BzID0ge3xcbiAgY3VycmVudFRpbWU6IG51bWJlcixcbiAgZHVyYXRpb246IG51bWJlcixcbiAgc2VlazogKHRpbWU6IG51bWJlcikgPT4gdm9pZCxcbnx9O1xuXG50eXBlIFN0YXRlID0ge3xcbiAgc2Vla2luZzogYm9vbGVhbixcbnx9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWRlb1BsYXloZWFkIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBjdXJyZW50VGltZTogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIGR1cmF0aW9uOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgc2VlazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgfTtcblxuICBzdGF0ZSA9IHtcbiAgICBzZWVraW5nOiBmYWxzZSxcbiAgfTtcblxuICBzZXRQbGF5aGVhZFJlZiA9IChyZWY6ID9IVE1MRGl2RWxlbWVudCkgPT4ge1xuICAgIHRoaXMucGxheWhlYWQgPSByZWY7XG4gIH07XG5cbiAgc2VlayA9IChjbGllbnRYOiBudW1iZXIpID0+IHtcbiAgICBpZiAodGhpcy5wbGF5aGVhZCkge1xuICAgICAgY29uc3QgeyBkdXJhdGlvbiwgc2VlayB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHsgbGVmdCwgd2lkdGggfSA9IHRoaXMucGxheWhlYWQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBwZXJjZW50ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oKGNsaWVudFggLSBsZWZ0KSAvIHdpZHRoLCAxKSk7XG4gICAgICBjb25zdCBuZXdUaW1lID0gcGVyY2VudCAqIGR1cmF0aW9uO1xuICAgICAgc2VlayhuZXdUaW1lKTtcbiAgICB9XG4gIH07XG5cbiAgc3RvcENsaWNrID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgaGFuZGxlTW91c2VEb3duID0gKGV2ZW50OiBTeW50aGV0aWNNb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50PikgPT4ge1xuICAgIHRoaXMuc2V0U3RhdGUoeyBzZWVraW5nOiB0cnVlIH0pO1xuICAgIHRoaXMuc2VlayhldmVudC5jbGllbnRYKTtcbiAgfTtcblxuICBoYW5kbGVNb3VzZU1vdmUgPSAoZXZlbnQ6IFN5bnRoZXRpY01vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyBzZWVraW5nIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzZWVraW5nKSB7XG4gICAgICB0aGlzLnNlZWsoZXZlbnQuY2xpZW50WCk7XG4gICAgfVxuICB9O1xuXG4gIGhhbmRsZU1vdXNlVXAgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IHNlZWtpbmc6IGZhbHNlIH0pO1xuICB9O1xuXG4gIHBsYXloZWFkOiA/SFRNTERpdkVsZW1lbnQ7XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY3VycmVudFRpbWUsIGR1cmF0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHdpZHRoID0gYCR7TWF0aC5mbG9vcigoY3VycmVudFRpbWUgKiAxMDAwMCkgLyBkdXJhdGlvbikgLyAxMDB9JWA7XG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3hcbiAgICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgICAgIGRpc3BsYXk9XCJmbGV4XCJcbiAgICAgICAgZmxleD1cImdyb3dcIlxuICAgICAgICBhbGlnbkl0ZW1zPVwiY2VudGVyXCJcbiAgICAgICAgaGVpZ2h0PXsxNn1cbiAgICAgID5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGFyaWEtdmFsdWVtYXg9e2R1cmF0aW9ufVxuICAgICAgICAgIGFyaWEtdmFsdWVtaW49XCIwXCJcbiAgICAgICAgICBhcmlhLXZhbHVlbm93PXtjdXJyZW50VGltZX1cbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5wbGF5aGVhZH1cbiAgICAgICAgICBvbkNsaWNrPXt0aGlzLnN0b3BDbGlja31cbiAgICAgICAgICBvbktleVByZXNzPXt0aGlzLnN0b3BDbGlja31cbiAgICAgICAgICBvbk1vdXNlRG93bj17dGhpcy5oYW5kbGVNb3VzZURvd259XG4gICAgICAgICAgb25Nb3VzZU1vdmU9e3RoaXMuaGFuZGxlTW91c2VNb3ZlfVxuICAgICAgICAgIG9uTW91c2VVcD17dGhpcy5oYW5kbGVNb3VzZVVwfVxuICAgICAgICAgIHJlZj17dGhpcy5zZXRQbGF5aGVhZFJlZn1cbiAgICAgICAgICByb2xlPVwicHJvZ3Jlc3NiYXJcIlxuICAgICAgICAgIHRhYkluZGV4PVwiLTFcIlxuICAgICAgICA+XG4gICAgICAgICAgPEJveFxuICAgICAgICAgICAgbGVmdFxuICAgICAgICAgICAgcmlnaHRcbiAgICAgICAgICAgIHBvc2l0aW9uPVwiYWJzb2x1dGVcIlxuICAgICAgICAgICAgY29sb3I9XCJsaWdodEdyYXlcIlxuICAgICAgICAgICAgc2hhcGU9XCJyb3VuZGVkXCJcbiAgICAgICAgICAgIGhlaWdodD17NH1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8Qm94IGNvbG9yPVwid2hpdGVcIiBzaGFwZT1cInJvdW5kZWRcIiBoZWlnaHQ9XCIxMDAlXCIgd2lkdGg9e3dpZHRofSAvPlxuICAgICAgICAgIDwvQm94PlxuICAgICAgICAgIDxCb3hcbiAgICAgICAgICAgIHBvc2l0aW9uPVwiYWJzb2x1dGVcIlxuICAgICAgICAgICAgc2hhcGU9XCJyb3VuZGVkXCJcbiAgICAgICAgICAgIGhlaWdodD17NH1cbiAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGU9e3sgX19zdHlsZTogeyBsZWZ0OiB3aWR0aCB9IH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPEJveFxuICAgICAgICAgICAgICBzaGFwZT1cImNpcmNsZVwiXG4gICAgICAgICAgICAgIHdpZHRoPXsxNn1cbiAgICAgICAgICAgICAgaGVpZ2h0PXsxNn1cbiAgICAgICAgICAgICAgY29sb3I9XCJ3aGl0ZVwiXG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQ9ey0yfVxuICAgICAgICAgICAgICBkYW5nZXJvdXNseVNldElubGluZVN0eWxlPXt7IF9fc3R5bGU6IHsgbWFyZ2luVG9wOiAtNiB9IH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvQm94PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvQm94PlxuICAgICk7XG4gIH1cbn1cbiIsIi8vIEBmbG93XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgQm94IGZyb20gJy4vQm94LmpzJztcbmltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5qcyc7XG5pbXBvcnQgVGV4dCBmcm9tICcuL1RleHQuanMnO1xuaW1wb3J0IFRvdWNoYWJsZSBmcm9tICcuL1RvdWNoYWJsZS5qcyc7XG5pbXBvcnQgVmlkZW9QbGF5aGVhZCBmcm9tICcuL1ZpZGVvUGxheWhlYWQuanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1ZpZGVvLmNzcyc7XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY2Nlc3NpYmlsaXR5TWF4aW1pemVMYWJlbDogc3RyaW5nLFxuICBhY2Nlc3NpYmlsaXR5TWluaW1pemVMYWJlbDogc3RyaW5nLFxuICBhY2Nlc3NpYmlsaXR5TXV0ZUxhYmVsOiBzdHJpbmcsXG4gIGFjY2Vzc2liaWxpdHlQYXVzZUxhYmVsOiBzdHJpbmcsXG4gIGFjY2Vzc2liaWxpdHlQbGF5TGFiZWw6IHN0cmluZyxcbiAgYWNjZXNzaWJpbGl0eVVubXV0ZUxhYmVsOiBzdHJpbmcsXG4gIGN1cnJlbnRUaW1lOiBudW1iZXIsXG4gIGR1cmF0aW9uOiBudW1iZXIsXG4gIGZ1bGxzY3JlZW46IGJvb2xlYW4sXG4gIG9uRnVsbHNjcmVlbkNoYW5nZTogKCkgPT4gdm9pZCxcbiAgb25QYXVzZTogKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHZvaWQsXG4gIG9uUGxheTogKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHZvaWQsXG4gIG9uVm9sdW1lQ2hhbmdlOiAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxEaXZFbGVtZW50PikgPT4gdm9pZCxcbiAgcGxheWluZzogYm9vbGVhbixcbiAgc2VlazogKHRpbWU6IG51bWJlcikgPT4gdm9pZCxcbiAgdm9sdW1lOiBudW1iZXIsXG58fTtcblxuY29uc3QgZnVsbHNjcmVlbkVuYWJsZWQgPSAoKSA9PlxuICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICBkb2N1bWVudC5mdWxsc2NyZWVuRW5hYmxlZCB8fFxuICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCB8fFxuICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRW5hYmxlZCB8fFxuICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbmFibGVkO1xuXG5jb25zdCB0aW1lVG9TdHJpbmcgPSAodGltZT86IG51bWJlcikgPT4ge1xuICBjb25zdCByb3VuZGVkID0gTWF0aC5mbG9vcih0aW1lIHx8IDApO1xuICBjb25zdCBtaW51dGVzID0gTWF0aC5mbG9vcihyb3VuZGVkIC8gNjApO1xuICBjb25zdCBzZWNvbmRzID0gcm91bmRlZCAtIG1pbnV0ZXMgKiA2MDtcbiAgY29uc3QgbWludXRlc1N0ciA9IG1pbnV0ZXMgPCAxMCA/IGAwJHttaW51dGVzfWAgOiBtaW51dGVzO1xuICBjb25zdCBzZWNvbmRzU3RyID0gc2Vjb25kcyA8IDEwID8gYDAke3NlY29uZHN9YCA6IHNlY29uZHM7XG4gIHJldHVybiBgJHttaW51dGVzU3RyfToke3NlY29uZHNTdHJ9YDtcbn07XG5cbmNsYXNzIFZpZGVvQ29udHJvbHMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHM+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBhY2Nlc3NpYmlsaXR5TWF4aW1pemVMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGFjY2Vzc2liaWxpdHlNaW5pbWl6ZUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgYWNjZXNzaWJpbGl0eU11dGVMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGFjY2Vzc2liaWxpdHlQYXVzZUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgYWNjZXNzaWJpbGl0eVBsYXlMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGFjY2Vzc2liaWxpdHlVbm11dGVMYWJlbDogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGN1cnJlbnRUaW1lOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgZHVyYXRpb246IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICBmdWxsc2NyZWVuOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAgIG9uRnVsbHNjcmVlbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvblBhdXNlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIG9uUGxheTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvblZvbHVtZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBwbGF5aW5nOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICAgIHNlZWs6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgdm9sdW1lOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIH07XG5cbiAgaGFuZGxlRnVsbHNjcmVlbkNoYW5nZSA9ICh7XG4gICAgZXZlbnQsXG4gIH06IHtcbiAgICBldmVudDpcbiAgICAgIHwgU3ludGhldGljTW91c2VFdmVudDxIVE1MRGl2RWxlbWVudD5cbiAgICAgIHwgU3ludGhldGljS2V5Ym9hcmRFdmVudDxIVE1MRGl2RWxlbWVudD4sXG4gIH0pID0+IHtcbiAgICBjb25zdCB7IG9uRnVsbHNjcmVlbkNoYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBvbkZ1bGxzY3JlZW5DaGFuZ2UoKTtcbiAgfTtcblxuICBoYW5kbGVQbGF5aW5nQ2hhbmdlID0gKHtcbiAgICBldmVudCxcbiAgfToge1xuICAgIGV2ZW50OlxuICAgICAgfCBTeW50aGV0aWNNb3VzZUV2ZW50PEhUTUxEaXZFbGVtZW50PlxuICAgICAgfCBTeW50aGV0aWNLZXlib2FyZEV2ZW50PEhUTUxEaXZFbGVtZW50PixcbiAgfSkgPT4ge1xuICAgIGNvbnN0IHsgcGxheWluZywgb25QYXVzZSwgb25QbGF5IH0gPSB0aGlzLnByb3BzO1xuICAgIGlmIChwbGF5aW5nKSB7XG4gICAgICBvblBhdXNlKGV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb25QbGF5KGV2ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgaGFuZGxlVm9sdW1lQ2hhbmdlID0gKHtcbiAgICBldmVudCxcbiAgfToge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzICovXG4gICAgZXZlbnQ6XG4gICAgICB8IFN5bnRoZXRpY01vdXNlRXZlbnQ8SFRNTERpdkVsZW1lbnQ+XG4gICAgICB8IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ8SFRNTERpdkVsZW1lbnQ+LFxuICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3Qvbm8tdW51c2VkLXByb3AtdHlwZXMgKi9cbiAgfSkgPT4ge1xuICAgIGNvbnN0IHsgb25Wb2x1bWVDaGFuZ2UgfSA9IHRoaXMucHJvcHM7XG4gICAgb25Wb2x1bWVDaGFuZ2UoZXZlbnQpO1xuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBhY2Nlc3NpYmlsaXR5TWF4aW1pemVMYWJlbCxcbiAgICAgIGFjY2Vzc2liaWxpdHlNaW5pbWl6ZUxhYmVsLFxuICAgICAgYWNjZXNzaWJpbGl0eU11dGVMYWJlbCxcbiAgICAgIGFjY2Vzc2liaWxpdHlQYXVzZUxhYmVsLFxuICAgICAgYWNjZXNzaWJpbGl0eVBsYXlMYWJlbCxcbiAgICAgIGFjY2Vzc2liaWxpdHlVbm11dGVMYWJlbCxcbiAgICAgIGN1cnJlbnRUaW1lLFxuICAgICAgZHVyYXRpb24sXG4gICAgICBmdWxsc2NyZWVuLFxuICAgICAgcGxheWluZyxcbiAgICAgIHNlZWssXG4gICAgICB2b2x1bWUsXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgbXV0ZWQgPSB2b2x1bWUgPT09IDA7XG4gICAgY29uc3Qgc2hvd0Z1bGxzY3JlZW5CdXR0b24gPVxuICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIWZ1bGxzY3JlZW5FbmFibGVkKCk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY29udHJvbHN9PlxuICAgICAgICA8Qm94IHBhZGRpbmc9ezJ9PlxuICAgICAgICAgIDxUb3VjaGFibGUgb25Ub3VjaD17dGhpcy5oYW5kbGVQbGF5aW5nQ2hhbmdlfSBmdWxsV2lkdGg9e2ZhbHNlfT5cbiAgICAgICAgICAgIDxJY29uXG4gICAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlMYWJlbD17XG4gICAgICAgICAgICAgICAgcGxheWluZyA/IGFjY2Vzc2liaWxpdHlQYXVzZUxhYmVsIDogYWNjZXNzaWJpbGl0eVBsYXlMYWJlbFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbG9yPVwid2hpdGVcIlxuICAgICAgICAgICAgICBpY29uPXtwbGF5aW5nID8gJ3BhdXNlJyA6ICdwbGF5J31cbiAgICAgICAgICAgICAgc2l6ZT17MjB9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvVG91Y2hhYmxlPlxuICAgICAgICA8L0JveD5cbiAgICAgICAgPEJveCB3aWR0aD17NTB9IHBhZGRpbmc9ezJ9PlxuICAgICAgICAgIDxUZXh0IGNvbG9yPVwid2hpdGVcIiBhbGlnbj1cInJpZ2h0XCIgc2l6ZT1cInhzXCI+XG4gICAgICAgICAgICB7dGltZVRvU3RyaW5nKGN1cnJlbnRUaW1lKX1cbiAgICAgICAgICA8L1RleHQ+XG4gICAgICAgIDwvQm94PlxuICAgICAgICA8Qm94IHBhZGRpbmc9ezJ9IGZsZXg9XCJncm93XCI+XG4gICAgICAgICAgPFZpZGVvUGxheWhlYWRcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lPXtjdXJyZW50VGltZX1cbiAgICAgICAgICAgIGR1cmF0aW9uPXtkdXJhdGlvbn1cbiAgICAgICAgICAgIHNlZWs9e3NlZWt9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9Cb3g+XG4gICAgICAgIDxCb3ggd2lkdGg9ezUwfSBwYWRkaW5nPXsyfT5cbiAgICAgICAgICA8VGV4dCBjb2xvcj1cIndoaXRlXCIgYWxpZ249XCJyaWdodFwiIHNpemU9XCJ4c1wiPlxuICAgICAgICAgICAge3RpbWVUb1N0cmluZyhkdXJhdGlvbil9XG4gICAgICAgICAgPC9UZXh0PlxuICAgICAgICA8L0JveD5cbiAgICAgICAgPEJveCBwYWRkaW5nPXsyfT5cbiAgICAgICAgICA8VG91Y2hhYmxlIG9uVG91Y2g9e3RoaXMuaGFuZGxlVm9sdW1lQ2hhbmdlfSBmdWxsV2lkdGg9e2ZhbHNlfT5cbiAgICAgICAgICAgIDxJY29uXG4gICAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlMYWJlbD17XG4gICAgICAgICAgICAgICAgbXV0ZWQgPyBhY2Nlc3NpYmlsaXR5VW5tdXRlTGFiZWwgOiBhY2Nlc3NpYmlsaXR5TXV0ZUxhYmVsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29sb3I9XCJ3aGl0ZVwiXG4gICAgICAgICAgICAgIGljb249e211dGVkID8gJ211dGUnIDogJ3NvdW5kJ31cbiAgICAgICAgICAgICAgc2l6ZT17MjB9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvVG91Y2hhYmxlPlxuICAgICAgICA8L0JveD5cbiAgICAgICAge3Nob3dGdWxsc2NyZWVuQnV0dG9uICYmIChcbiAgICAgICAgICA8Qm94IHBhZGRpbmc9ezJ9PlxuICAgICAgICAgICAgPFRvdWNoYWJsZSBvblRvdWNoPXt0aGlzLmhhbmRsZUZ1bGxzY3JlZW5DaGFuZ2V9IGZ1bGxXaWR0aD17ZmFsc2V9PlxuICAgICAgICAgICAgICA8SWNvblxuICAgICAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlMYWJlbD17XG4gICAgICAgICAgICAgICAgICBmdWxsc2NyZWVuXG4gICAgICAgICAgICAgICAgICAgID8gYWNjZXNzaWJpbGl0eU1pbmltaXplTGFiZWxcbiAgICAgICAgICAgICAgICAgICAgOiBhY2Nlc3NpYmlsaXR5TWF4aW1pemVMYWJlbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2xvcj1cIndoaXRlXCJcbiAgICAgICAgICAgICAgICBpY29uPXtmdWxsc2NyZWVuID8gJ21pbmltaXplJyA6ICdtYXhpbWl6ZSd9XG4gICAgICAgICAgICAgICAgc2l6ZT17MjB9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L1RvdWNoYWJsZT5cbiAgICAgICAgICA8L0JveD5cbiAgICAgICAgKX1cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmlkZW9Db250cm9scztcbiIsIi8vIEBmbG93XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgVmlkZW9Db250cm9scyBmcm9tICcuL1ZpZGVvQ29udHJvbHMuanMnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL1ZpZGVvLmNzcyc7XG5cbnR5cGUgU291cmNlID1cbiAgfCBzdHJpbmdcbiAgfCBBcnJheTx7fCB0eXBlOiAndmlkZW8vbTN1OCcgfCAndmlkZW8vbXA0JyB8ICd2aWRlby9vZ2cnLCBzcmM6IHN0cmluZyB8fT47XG5cbnR5cGUgUHJvcHMgPSB7fFxuICBhY2Nlc3NpYmlsaXR5TWF4aW1pemVMYWJlbDogc3RyaW5nLFxuICBhY2Nlc3NpYmlsaXR5TWluaW1pemVMYWJlbDogc3RyaW5nLFxuICBhY2Nlc3NpYmlsaXR5TXV0ZUxhYmVsOiBzdHJpbmcsXG4gIGFjY2Vzc2liaWxpdHlQYXVzZUxhYmVsOiBzdHJpbmcsXG4gIGFjY2Vzc2liaWxpdHlQbGF5TGFiZWw6IHN0cmluZyxcbiAgYWNjZXNzaWJpbGl0eVVubXV0ZUxhYmVsOiBzdHJpbmcsXG4gIGFzcGVjdFJhdGlvOiBudW1iZXIsXG4gIGNhcHRpb25zOiBzdHJpbmcsXG4gIGNvbnRyb2xzPzogYm9vbGVhbixcbiAgbG9vcD86IGJvb2xlYW4sXG4gIG9uRHVyYXRpb25DaGFuZ2U/OiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MVmlkZW9FbGVtZW50PixcbiAgICBkdXJhdGlvbjogbnVtYmVyLFxuICB9KSA9PiB2b2lkLFxuICBvbkVuZGVkPzogKHsgZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxWaWRlb0VsZW1lbnQ+IH0pID0+IHZvaWQsXG4gIG9uRnVsbHNjcmVlbkNoYW5nZT86ICh7IGV2ZW50OiBFdmVudCwgZnVsbHNjcmVlbjogYm9vbGVhbiB9KSA9PiB2b2lkLFxuICBvbkxvYWRlZENoYW5nZT86ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxWaWRlb0VsZW1lbnQ+LFxuICAgIGxvYWRlZDogbnVtYmVyLFxuICB9KSA9PiB2b2lkLFxuICBvblBsYXk/OiAoeyBldmVudDogU3ludGhldGljRXZlbnQ8SFRNTERpdkVsZW1lbnQ+IH0pID0+IHZvaWQsXG4gIG9uUGF1c2U/OiAoeyBldmVudDogU3ludGhldGljRXZlbnQ8SFRNTERpdkVsZW1lbnQ+IH0pID0+IHZvaWQsXG4gIG9uUmVhZHk/OiAoeyBldmVudDogU3ludGhldGljRXZlbnQ8SFRNTFZpZGVvRWxlbWVudD4gfSkgPT4gdm9pZCxcbiAgb25TZWVrPzogKHsgZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxWaWRlb0VsZW1lbnQ+IH0pID0+IHZvaWQsXG4gIG9uVGltZUNoYW5nZT86ICh7XG4gICAgZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxWaWRlb0VsZW1lbnQ+LFxuICAgIHRpbWU6IG51bWJlcixcbiAgfSkgPT4gdm9pZCxcbiAgb25Wb2x1bWVDaGFuZ2U/OiAoe1xuICAgIGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MRGl2RWxlbWVudD4sXG4gICAgdm9sdW1lOiBudW1iZXIsXG4gIH0pID0+IHZvaWQsXG4gIHBsYXliYWNrUmF0ZTogbnVtYmVyLFxuICBwbGF5aW5nOiBib29sZWFuLFxuICBwbGF5c0lubGluZT86IGJvb2xlYW4sXG4gIHBvc3Rlcj86IHN0cmluZyxcbiAgcHJlbG9hZDogJ2F1dG8nIHwgJ21ldGFkYXRhJyB8ICdub25lJyxcbiAgc3JjOiBTb3VyY2UsXG4gIHZvbHVtZTogbnVtYmVyLFxufH07XG5cbnR5cGUgU3RhdGUgPSB7fFxuICBjdXJyZW50VGltZTogbnVtYmVyLFxuICBkdXJhdGlvbjogbnVtYmVyLFxuICBmdWxsc2NyZWVuOiBib29sZWFuLFxufH07XG5cbi8vIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGZ1bGxzY3JlZW4gYW5kIHZlbmRvciBwcmVmaXhlcyBzZWVcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GdWxsc2NyZWVuX0FQSVxuXG5jb25zdCByZXF1ZXN0RnVsbHNjcmVlbiA9IChlbGVtZW50OiBIVE1MRWxlbWVudCkgPT4ge1xuICBpZiAoZWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgIGVsZW1lbnQucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICB9IGVsc2UgaWYgKGVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICAgIGVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICB9IGVsc2UgaWYgKGVsZW1lbnQubW96UmVxdWVzdEZ1bGxTY3JlZW4pIHtcbiAgICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICAgIGVsZW1lbnQubW96UmVxdWVzdEZ1bGxTY3JlZW4oKTtcbiAgICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICB9IGVsc2UgaWYgKGVsZW1lbnQubXNSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gICAgZWxlbWVudC5tc1JlcXVlc3RGdWxsc2NyZWVuKCk7XG4gIH1cbn07XG5cbmNvbnN0IGV4aXRGdWxsc2NyZWVuID0gKCkgPT4ge1xuICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICBpZiAoZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgfSBlbHNlIGlmIChkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbikge1xuICAgIC8vICRGbG93SXNzdWUgLSB2ZW5kb3IgcHJlZml4IG1pc3NpbmcgZnJvbSBGbG93XG4gICAgZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICB9IGVsc2UgaWYgKGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4pIHtcbiAgICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICAgIGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4oKTtcbiAgICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICB9IGVsc2UgaWYgKGRvY3VtZW50Lm1zRXhpdEZ1bGxzY3JlZW4pIHtcbiAgICAvLyAkRmxvd0lzc3VlIC0gdmVuZG9yIHByZWZpeCBtaXNzaW5nIGZyb20gRmxvd1xuICAgIGRvY3VtZW50Lm1zRXhpdEZ1bGxzY3JlZW4oKTtcbiAgfVxufTtcblxuLy8gTm9ybWFsbHkgZG9jdW1lbnQuZnVsbHNjcmVlbiBzdWZmaWNlcyBoZXJlIGFzIGEgZmxhZywgYnV0IElFMTEgZG9lcyBub3Rcbi8vIGhhdmUgYSB2ZW5kb3Igc3BlY2lmaWMgdmVyc2lvbiBzbyB3ZSBtdXN0IGluc3RlYWQgdXNlIHRoZSBhY3R1YWwgZWxlbWVudFxuY29uc3QgaXNGdWxsc2NyZWVuID0gKCkgPT5cbiAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnQgfHxcbiAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQgfHxcbiAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgZG9jdW1lbnQubW96RnVsbFNjcmVlbkVsZW1lbnQgfHxcbiAgLy8gJEZsb3dJc3N1ZSAtIHZlbmRvciBwcmVmaXggbWlzc2luZyBmcm9tIEZsb3dcbiAgZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudDtcblxuY29uc3QgYWRkRnVsbHNjcmVlbkV2ZW50TGlzdGVuZXIgPSAobGlzdGVuZXI6IEV2ZW50TGlzdGVuZXIpID0+IHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZnVsbHNjcmVlbmNoYW5nZScsIGxpc3RlbmVyKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsIGxpc3RlbmVyKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW96ZnVsbHNjcmVlbmNoYW5nZScsIGxpc3RlbmVyKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignTVNGdWxsc2NyZWVuQ2hhbmdlJywgbGlzdGVuZXIpO1xufTtcblxuY29uc3QgcmVtb3ZlRnVsbHNjcmVlbkV2ZW50TGlzdGVuZXIgPSAobGlzdGVuZXI6IEV2ZW50TGlzdGVuZXIpID0+IHtcbiAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZnVsbHNjcmVlbmNoYW5nZScsIGxpc3RlbmVyKTtcbiAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsIGxpc3RlbmVyKTtcbiAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW96ZnVsbHNjcmVlbmNoYW5nZScsIGxpc3RlbmVyKTtcbiAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignTVNGdWxsc2NyZWVuQ2hhbmdlJywgbGlzdGVuZXIpO1xufTtcblxuY29uc3QgaXNOZXdTb3VyY2UgPSAob2xkU291cmNlOiBTb3VyY2UsIG5ld1NvdXJjZTogU291cmNlKTogYm9vbGVhbiA9PiB7XG4gIGlmICh0eXBlb2Ygb2xkU291cmNlICE9PSB0eXBlb2YgbmV3U291cmNlKSB7XG4gICAgLy8gSWYgdGhlIHNvdXJjZSB0eXBlIGNoYW5nZWQgZnJvbSBzdHJpbmcgdG8gQXJyYXlcbiAgICAvLyBvciB2aWNlIHZlcnNhLCB3ZSBoYXZlIGEgbmV3IHNvdXJjZVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5ld1NvdXJjZSkpIHtcbiAgICBpZiAob2xkU291cmNlLmxlbmd0aCAhPT0gbmV3U291cmNlLmxlbmd0aCkge1xuICAgICAgLy8gSWYgdGhlIHNvdXJjZXMgYXJlIGJvdGggYW4gQXJyYXksIGFuZCB0aGUgbGVuZ3Roc1xuICAgICAgLy8gZG8gbm90IG1hdGNoIHdlIGV2YWx1YXRlIGFzIGEgbmV3IHNvdXJjZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIElmIHRoZSBzb3VyY2VzIGFyZSBib3RoIGFuIEFycmF5IGFuZCB0aGUgc2FtZSBsZW5ndGgsXG4gICAgLy8gdmVyaWZ5IGV2ZXJ5IGVsZW1lbnQgc3RheWVkIHRoZSBzYW1lXG4gICAgcmV0dXJuIG5ld1NvdXJjZS5zb21lKFxuICAgICAgKHNvdXJjZSwgaW5kZXgpID0+XG4gICAgICAgICFBcnJheS5pc0FycmF5KG9sZFNvdXJjZSkgfHxcbiAgICAgICAgc291cmNlLnR5cGUgIT09IG9sZFNvdXJjZVtpbmRleF0udHlwZSB8fFxuICAgICAgICBzb3VyY2Uuc3JjICE9PSBvbGRTb3VyY2VbaW5kZXhdLnNyY1xuICAgICk7XG4gIH1cbiAgLy8gSWYgdGhlIHNvdXJjZXMgYXJlIGJvdGggYSBzdHJpbmcsIHNpbXBseSBjb21wYXJlXG4gIC8vIHRoZSBuZXcgd2l0aCB0aGUgb2xkXG4gIHJldHVybiBuZXdTb3VyY2UgIT09IG9sZFNvdXJjZTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZGVvIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxQcm9wcywgU3RhdGU+IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICBhY2Nlc3NpYmlsaXR5TWF4aW1pemVMYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBhY2Nlc3NpYmlsaXR5TWluaW1pemVMYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBhY2Nlc3NpYmlsaXR5TXV0ZUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFjY2Vzc2liaWxpdHlQYXVzZUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFjY2Vzc2liaWxpdHlQbGF5TGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgYWNjZXNzaWJpbGl0eVVubXV0ZUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGFzcGVjdFJhdGlvOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgY2FwdGlvbnM6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICBjb250cm9sczogUHJvcFR5cGVzLmJvb2wsXG4gICAgbG9vcDogUHJvcFR5cGVzLmJvb2wsXG4gICAgb25EdXJhdGlvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25FbmRlZDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25GdWxsc2NyZWVuQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvbkxvYWRlZENoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25QbGF5OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblBhdXNlOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblJlYWR5OiBQcm9wVHlwZXMuZnVuYyxcbiAgICBvblNlZWs6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uVGltZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25Wb2x1bWVDaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAgIHBsYXliYWNrUmF0ZTogUHJvcFR5cGVzLm51bWJlcixcbiAgICBwbGF5aW5nOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBwbGF5c0lubGluZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgcG9zdGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHByZWxvYWQ6IFByb3BUeXBlcy5vbmVPZihbJ2F1dG8nLCAnbWV0YWRhdGEnLCAnbm9uZSddKSxcbiAgICBzcmM6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgIFByb3BUeXBlcy5hcnJheU9mKFxuICAgICAgICBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgICAgIHR5cGU6IFByb3BUeXBlcy5vbmVPZihbJ3ZpZGVvL20zdTgnLCAndmlkZW8vbXA0JywgJ3ZpZGVvL29nZyddKVxuICAgICAgICAgICAgLmlzUmVxdWlyZWQsXG4gICAgICAgICAgc3JjOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgICAgIH0pXG4gICAgICApLFxuICAgIF0pLmlzUmVxdWlyZWQsXG4gICAgdm9sdW1lOiBQcm9wVHlwZXMubnVtYmVyLFxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgcGxheWJhY2tSYXRlOiAxLFxuICAgIHBsYXlpbmc6IGZhbHNlLFxuICAgIHByZWxvYWQ6ICdhdXRvJyxcbiAgICB2b2x1bWU6IDEsXG4gIH07XG5cbiAgc3RhdGUgPSB7XG4gICAgY3VycmVudFRpbWU6IDAsXG4gICAgZHVyYXRpb246IDAsXG4gICAgZnVsbHNjcmVlbjogZmFsc2UsXG4gIH07XG5cbiAgLyoqXG4gICAqIFJlYWN0IGxpZmVjeWNsZSBob29rcyBwZXJ0aW5lbnQgdG8gVmlkZW9cbiAgICovXG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgeyBwbGF5YmFja1JhdGUsIHBsYXlpbmcsIHZvbHVtZSB9ID0gdGhpcy5wcm9wcztcbiAgICAvLyBTZXQgdXAgZXZlbnQgbGlzdGVuZXJzIHRvIGNhdGNoIGJhY2tkb29ycyBpbiBmdWxsc2NyZWVuXG4gICAgLy8gY2hhbmdlcyBzdWNoIGFzIHVzaW5nIHRoZSBFU0Mga2V5IHRvIGV4aXRcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgYWRkRnVsbHNjcmVlbkV2ZW50TGlzdGVuZXIodGhpcy5oYW5kbGVGdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICB9XG4gICAgLy8gTG9hZCB0aGUgdmlkZW8gdG8gaHlkcmF0ZSB0aGUgRE9NIGFmdGVyIGEgc2VydmVyIHJlbmRlclxuICAgIHRoaXMubG9hZCgpO1xuICAgIC8vIFNldCB0aGUgaW5pdGlhbCB2b2x1bWVcbiAgICB0aGlzLnNldFZvbHVtZSh2b2x1bWUpO1xuICAgIC8vIFNldCB0aGUgaW5pdGlhbCBwbGF5YmFjayByYXRlXG4gICAgdGhpcy5zZXRQbGF5YmFja1JhdGUocGxheWJhY2tSYXRlKTtcbiAgICAvLyBTaW11bGF0ZSBhbiBhdXRvcGxheSBlZmZlY3QgaWYgdGhlIGNvbXBvbmVudFxuICAgIGlmIChwbGF5aW5nKSB7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzOiBQcm9wcykge1xuICAgIC8vIElmIHRoZSB2aWRlbyBzb3VyY2UgY2hhbmdlZCwgcmVsb2FkIHRoZSB2aWRlb1xuICAgIGlmIChpc05ld1NvdXJjZShwcmV2UHJvcHMuc3JjLCB0aGlzLnByb3BzLnNyYykpIHtcbiAgICAgIHRoaXMubG9hZCgpO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgdm9sdW1lIGNoYW5nZWQsIHNldCB0aGUgbmV3IHZvbHVtZVxuICAgIGlmIChwcmV2UHJvcHMudm9sdW1lICE9PSB0aGlzLnByb3BzLnZvbHVtZSkge1xuICAgICAgdGhpcy5zZXRWb2x1bWUodGhpcy5wcm9wcy52b2x1bWUpO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgcGxheWJhY2sgcmF0ZSBjaGFuZ2VkLCBzZXQgdGhlIG5ldyByYXRlXG4gICAgaWYgKHByZXZQcm9wcy5wbGF5YmFja1JhdGUgIT09IHRoaXMucHJvcHMucGxheWJhY2tSYXRlKSB7XG4gICAgICB0aGlzLnNldFBsYXliYWNrUmF0ZSh0aGlzLnByb3BzLnBsYXliYWNrUmF0ZSk7XG4gICAgfVxuICAgIC8vIElmIHRoZSBwbGF5YmFjayBjaGFuZ2VkLCBwbGF5IG9yIHBhdXNlIHRoZSB2aWRlb1xuICAgIGlmIChwcmV2UHJvcHMucGxheWluZyAhPT0gdGhpcy5wcm9wcy5wbGF5aW5nKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5wbGF5aW5nKSB7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHJlbW92ZUZ1bGxzY3JlZW5FdmVudExpc3RlbmVyKHRoaXMuaGFuZGxlRnVsbHNjcmVlbkNoYW5nZSk7XG4gIH1cblxuICAvKipcbiAgICogRE9NIHJlZmVyZW5jZSBob3VzZWtlZXBpbmcgdGhhdCBpcyBuZWVkZWQgZm9yIGZ1bmN0aW9uYWxpdHlcbiAgICovXG5cbiAgLy8gVGhlIHBsYXllciBlbGVtZW50IGVuY2Fwc3VsYXRlcyB0aGUgYWN0dWFsIHZpZGVvIERPTVxuICAvLyBlbGVtZW50IGFzIHdlbGwgYXMgdGhlIGNvbnRyb2xzIHRvIGJyaW5nIGJvdGggZnVsbHNjcmVlblxuICBzZXRQbGF5ZXJSZWYgPSAocmVmOiA/SFRNTERpdkVsZW1lbnQpID0+IHtcbiAgICB0aGlzLnBsYXllciA9IHJlZjtcbiAgfTtcblxuICAvLyBUaGUgYWN0dWFsIHJlZmVyZW5jZSB0byB0aGUgdmlkZW8gSFRNTCBET00gZWxlbWVudFxuICBzZXRWaWRlb1JlZiA9IChyZWY6ID9IVE1MVmlkZW9FbGVtZW50KSA9PiB7XG4gICAgdGhpcy52aWRlbyA9IHJlZjtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb25zIHRoYXQgZGlyZWN0bHkgaW50ZXJhY3Qgd2l0aCB0aGUgSFRNTCB2aWRlbyBlbGVtZW50XG4gICAqL1xuXG4gIC8vIFNldCB0aGUgdmlkZW8gdG8gdGhlIGRlc2lyZWQgcGxheWJhY2sgcmF0ZTogMSAobm9ybWFsKVxuICBzZXRQbGF5YmFja1JhdGUgPSAocGxheWJhY2tSYXRlOiBudW1iZXIpID0+IHtcbiAgICBpZiAodGhpcy52aWRlbykge1xuICAgICAgdGhpcy52aWRlby5wbGF5YmFja1JhdGUgPSBwbGF5YmFja1JhdGU7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNldCB0aGUgdmlkZW8gdG8gdGhlIGRlc2lyZWQgdm9sdW1lOiAwIChtdXRlZCkgLT4gMSAobWF4KVxuICBzZXRWb2x1bWUgPSAodm9sdW1lOiBudW1iZXIpID0+IHtcbiAgICBpZiAodGhpcy52aWRlbykge1xuICAgICAgdGhpcy52aWRlby52b2x1bWUgPSB2b2x1bWU7XG4gICAgfVxuICB9O1xuXG4gIC8vIENoYW5nZSB0aGUgdmlkZW8gc291cmNlIGFuZCByZS1sb2FkIHRoZSB2aWRlb1xuICBsb2FkID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnZpZGVvKSB7XG4gICAgICB0aGlzLnZpZGVvLmxvYWQoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUGF1c2UgdGhlIHZpZGVvXG4gIHBhdXNlID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnZpZGVvKSB7XG4gICAgICB0aGlzLnZpZGVvLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFBsYXkgdGhlIHZpZGVvXG4gIHBsYXkgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMudmlkZW8pIHtcbiAgICAgIHRoaXMudmlkZW8ucGxheSgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBTZWVrIHRoZSB2aWRlbyB0byB0aGUgZGVzaXJlZCB0aW1lXG4gIHNlZWsgPSAodGltZTogbnVtYmVyKSA9PiB7XG4gICAgaWYgKHRoaXMudmlkZW8pIHtcbiAgICAgIHRoaXMudmlkZW8uY3VycmVudFRpbWUgPSB0aW1lO1xuICAgIH1cbiAgfTtcblxuICAvLyBFbnRlci9leGl0IGZ1bGxzY3JlZW4gdmlkZW8gcGxheWVyIG1vZGVcbiAgdG9nZ2xlRnVsbHNjcmVlbiA9ICgpID0+IHtcbiAgICBpZiAoaXNGdWxsc2NyZWVuKCkpIHtcbiAgICAgIGV4aXRGdWxsc2NyZWVuKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBsYXllcikge1xuICAgICAgcmVxdWVzdEZ1bGxzY3JlZW4odGhpcy5wbGF5ZXIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGFuZGxlcnMgZm9yIHZhcmlvdXMgbWVkaWEgZXZlbnRzIG9uIHRoZSB2aWRlb1xuICAgKi9cblxuICAvLyBTZW50IHdoZW4gZW5vdWdoIGRhdGEgaXMgYXZhaWxhYmxlIHRoYXQgdGhlIG1lZGlhIGNhbiBiZSBwbGF5ZWRcbiAgaGFuZGxlQ2FuUGxheSA9IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTFZpZGVvRWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uUmVhZHkgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAob25SZWFkeSkge1xuICAgICAgb25SZWFkeSh7IGV2ZW50IH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUaGUgbWV0YWRhdGEgaGFzIGxvYWRlZCBvciBjaGFuZ2VkLCBpbmRpY2F0aW5nIGEgY2hhbmdlIGluXG4gIC8vIGR1cmF0aW9uIG9mIHRoZSBtZWRpYVxuICBoYW5kbGVEdXJhdGlvbkNoYW5nZSA9IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTFZpZGVvRWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uRHVyYXRpb25DaGFuZ2UgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgZHVyYXRpb24gPSAodGhpcy52aWRlbyAmJiB0aGlzLnZpZGVvLmR1cmF0aW9uKSB8fCAwO1xuICAgIHRoaXMuc2V0U3RhdGUoeyBkdXJhdGlvbiB9KTtcblxuICAgIGlmIChvbkR1cmF0aW9uQ2hhbmdlKSB7XG4gICAgICBvbkR1cmF0aW9uQ2hhbmdlKHsgZXZlbnQsIGR1cmF0aW9uIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBTZW50IHdoZW4gcGxheWJhY2sgY29tcGxldGVzLlxuICBoYW5kbGVFbmRlZCA9IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTFZpZGVvRWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uRW5kZWQgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAob25FbmRlZCkge1xuICAgICAgb25FbmRlZCh7IGV2ZW50IH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBTZW50IHdoZW4gdGhlIHZpZGVvIGlzIHN3aXRjaGVkIHRvL291dC1vZiBmdWxsc2NyZWVuIG1vZGVcbiAgaGFuZGxlRnVsbHNjcmVlbkNoYW5nZSA9IChldmVudDogRXZlbnQpID0+IHtcbiAgICBjb25zdCB7IG9uRnVsbHNjcmVlbkNoYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBmdWxsc2NyZWVuID0gISFpc0Z1bGxzY3JlZW4oKTtcbiAgICB0aGlzLnNldFN0YXRlKHsgZnVsbHNjcmVlbiB9KTtcblxuICAgIGlmIChvbkZ1bGxzY3JlZW5DaGFuZ2UpIHtcbiAgICAgIG9uRnVsbHNjcmVlbkNoYW5nZSh7IGV2ZW50LCBmdWxsc2NyZWVuIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBTZW50IHdoZW4gcGxheWJhY2sgb2YgdGhlIG1lZGlhIHN0YXJ0cyBhZnRlciBoYXZpbmcgYmVlbiBwYXVzZWQuXG4gIGhhbmRsZVBsYXkgPSAoZXZlbnQ6IFN5bnRoZXRpY0V2ZW50PEhUTUxEaXZFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHsgb25QbGF5IH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKG9uUGxheSkge1xuICAgICAgb25QbGF5KHsgZXZlbnQgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlbnQgd2hlbiBwbGF5YmFjayBpcyBwYXVzZWQuXG4gIGhhbmRsZVBhdXNlID0gKGV2ZW50OiBTeW50aGV0aWNFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uUGF1c2UgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAob25QYXVzZSkge1xuICAgICAgb25QYXVzZSh7IGV2ZW50IH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBTZW50IHBlcmlvZGljYWxseSB0byBpbmZvcm0gaW50ZXJlc3RlZCBwYXJ0aWVzIG9mIHByb2dyZXNzIGRvd25sb2FkaW5nIHRoZSBtZWRpYVxuICBoYW5kbGVQcm9ncmVzcyA9IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTFZpZGVvRWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uTG9hZGVkQ2hhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgYnVmZmVyZWQgfSA9IHRoaXMudmlkZW8gfHwge307XG4gICAgY29uc3QgbG9hZGVkID1cbiAgICAgIGJ1ZmZlcmVkICYmIGJ1ZmZlcmVkLmxlbmd0aCA+IDAgPyBidWZmZXJlZC5lbmQoYnVmZmVyZWQubGVuZ3RoIC0gMSkgOiAwO1xuXG4gICAgaWYgKG9uTG9hZGVkQ2hhbmdlKSB7XG4gICAgICBvbkxvYWRlZENoYW5nZSh7IGV2ZW50LCBsb2FkZWQgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFNlbnQgd2hlbiBhIHNlZWsgb3BlcmF0aW9uIGNvbXBsZXRlcy5cbiAgaGFuZGxlU2VlayA9IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTFZpZGVvRWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uU2VlayB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChvblNlZWspIHtcbiAgICAgIG9uU2Vlayh7IGV2ZW50IH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBUaGUgdGltZSBpbmRpY2F0ZWQgYnkgdGhlIGVsZW1lbnQncyBjdXJyZW50VGltZSBhdHRyaWJ1dGUgaGFzIGNoYW5nZWRcbiAgaGFuZGxlVGltZVVwZGF0ZSA9IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTFZpZGVvRWxlbWVudD4pID0+IHtcbiAgICBjb25zdCB7IG9uVGltZUNoYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBjdXJyZW50VGltZSA9ICh0aGlzLnZpZGVvICYmIHRoaXMudmlkZW8uY3VycmVudFRpbWUpIHx8IDA7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGN1cnJlbnRUaW1lIH0pO1xuXG4gICAgaWYgKG9uVGltZUNoYW5nZSkge1xuICAgICAgb25UaW1lQ2hhbmdlKHsgZXZlbnQsIHRpbWU6IGN1cnJlbnRUaW1lIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBTZW50IHdoZW4gdGhlIGF1ZGlvIHZvbHVtZSBjaGFuZ2VzXG4gIGhhbmRsZVZvbHVtZUNoYW5nZSA9IChldmVudDogU3ludGhldGljRXZlbnQ8SFRNTERpdkVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgeyBvblZvbHVtZUNoYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBtdXRlZCA9ICh0aGlzLnZpZGVvICYmIHRoaXMudmlkZW8ubXV0ZWQpIHx8IGZhbHNlO1xuXG4gICAgaWYgKG9uVm9sdW1lQ2hhbmdlKSB7XG4gICAgICBvblZvbHVtZUNoYW5nZSh7IGV2ZW50LCB2b2x1bWU6IG11dGVkID8gMSA6IDAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZpZGVvOiA/SFRNTFZpZGVvRWxlbWVudDtcblxuICBwbGF5ZXI6ID9IVE1MRGl2RWxlbWVudDtcblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYXNwZWN0UmF0aW8sXG4gICAgICBjYXB0aW9ucyxcbiAgICAgIGxvb3AsXG4gICAgICBwbGF5aW5nLFxuICAgICAgcGxheXNJbmxpbmUsXG4gICAgICBwb3N0ZXIsXG4gICAgICBwcmVsb2FkLFxuICAgICAgc3JjLFxuICAgICAgdm9sdW1lLFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHsgY3VycmVudFRpbWUsIGR1cmF0aW9uLCBmdWxsc2NyZWVuIH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgY29uc3QgcGFkZGluZ0JvdHRvbSA9IChmdWxsc2NyZWVuICYmICcwJykgfHwgYCR7KDEgLyBhc3BlY3RSYXRpbykgKiAxMDB9JWA7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdlxuICAgICAgICByZWY9e3RoaXMuc2V0UGxheWVyUmVmfVxuICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5wbGF5ZXJ9XG4gICAgICAgIHN0eWxlPXt7IHBhZGRpbmdCb3R0b20sIGhlaWdodDogZnVsbHNjcmVlbiA/ICcxMDAlJyA6IDAgfX1cbiAgICAgID5cbiAgICAgICAgPHZpZGVvXG4gICAgICAgICAgYXV0b1BsYXk9e3BsYXlpbmd9XG4gICAgICAgICAgbG9vcD17bG9vcH1cbiAgICAgICAgICBtdXRlZD17dm9sdW1lID09PSAwfVxuICAgICAgICAgIHBsYXlzSW5saW5lPXtwbGF5c0lubGluZX1cbiAgICAgICAgICBwb3N0ZXI9e3Bvc3Rlcn1cbiAgICAgICAgICBwcmVsb2FkPXtwcmVsb2FkfVxuICAgICAgICAgIHNyYz17dHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgPyBzcmMgOiB1bmRlZmluZWR9XG4gICAgICAgICAgcmVmPXt0aGlzLnNldFZpZGVvUmVmfVxuICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnZpZGVvfVxuICAgICAgICAgIG9uQ2FuUGxheT17dGhpcy5oYW5kbGVDYW5QbGF5fVxuICAgICAgICAgIG9uRHVyYXRpb25DaGFuZ2U9e3RoaXMuaGFuZGxlRHVyYXRpb25DaGFuZ2V9XG4gICAgICAgICAgb25FbmRlZD17dGhpcy5oYW5kbGVFbmRlZH1cbiAgICAgICAgICBvblNlZWtlZD17dGhpcy5oYW5kbGVTZWVrfVxuICAgICAgICAgIG9uVGltZVVwZGF0ZT17dGhpcy5oYW5kbGVUaW1lVXBkYXRlfVxuICAgICAgICAgIG9uUHJvZ3Jlc3M9e3RoaXMuaGFuZGxlUHJvZ3Jlc3N9XG4gICAgICAgID5cbiAgICAgICAgICB7QXJyYXkuaXNBcnJheShzcmMpICYmXG4gICAgICAgICAgICBzcmMubWFwKHNvdXJjZSA9PiAoXG4gICAgICAgICAgICAgIDxzb3VyY2Uga2V5PXtzb3VyY2Uuc3JjfSBzcmM9e3NvdXJjZS5zcmN9IHR5cGU9e3NvdXJjZS50eXBlfSAvPlxuICAgICAgICAgICAgKSl9XG4gICAgICAgICAgPHRyYWNrIGtpbmQ9XCJjYXB0aW9uc1wiIHNyYz17Y2FwdGlvbnN9IC8+XG4gICAgICAgIDwvdmlkZW8+XG4gICAgICAgIHsvKiBOZWVkIHRvIHVzZSBmdWxsIHBhdGggZm9yIHRoZXNlIHByb3BzIHNvIEZsb3cgY2FuIGluZmVyIGNvcnJlY3Qgc3VidHlwZSAqL31cbiAgICAgICAge3RoaXMucHJvcHMuY29udHJvbHMgJiYgKFxuICAgICAgICAgIDxWaWRlb0NvbnRyb2xzXG4gICAgICAgICAgICBhY2Nlc3NpYmlsaXR5TWF4aW1pemVMYWJlbD17dGhpcy5wcm9wcy5hY2Nlc3NpYmlsaXR5TWF4aW1pemVMYWJlbH1cbiAgICAgICAgICAgIGFjY2Vzc2liaWxpdHlNaW5pbWl6ZUxhYmVsPXt0aGlzLnByb3BzLmFjY2Vzc2liaWxpdHlNaW5pbWl6ZUxhYmVsfVxuICAgICAgICAgICAgYWNjZXNzaWJpbGl0eU11dGVMYWJlbD17dGhpcy5wcm9wcy5hY2Nlc3NpYmlsaXR5TXV0ZUxhYmVsfVxuICAgICAgICAgICAgYWNjZXNzaWJpbGl0eVBhdXNlTGFiZWw9e3RoaXMucHJvcHMuYWNjZXNzaWJpbGl0eVBhdXNlTGFiZWx9XG4gICAgICAgICAgICBhY2Nlc3NpYmlsaXR5UGxheUxhYmVsPXt0aGlzLnByb3BzLmFjY2Vzc2liaWxpdHlQbGF5TGFiZWx9XG4gICAgICAgICAgICBhY2Nlc3NpYmlsaXR5VW5tdXRlTGFiZWw9e3RoaXMucHJvcHMuYWNjZXNzaWJpbGl0eVVubXV0ZUxhYmVsfVxuICAgICAgICAgICAgY3VycmVudFRpbWU9e2N1cnJlbnRUaW1lfVxuICAgICAgICAgICAgZHVyYXRpb249e2R1cmF0aW9ufVxuICAgICAgICAgICAgZnVsbHNjcmVlbj17ZnVsbHNjcmVlbn1cbiAgICAgICAgICAgIG9uUGxheT17dGhpcy5oYW5kbGVQbGF5fVxuICAgICAgICAgICAgb25QYXVzZT17dGhpcy5oYW5kbGVQYXVzZX1cbiAgICAgICAgICAgIG9uRnVsbHNjcmVlbkNoYW5nZT17dGhpcy50b2dnbGVGdWxsc2NyZWVufVxuICAgICAgICAgICAgb25Wb2x1bWVDaGFuZ2U9e3RoaXMuaGFuZGxlVm9sdW1lQ2hhbmdlfVxuICAgICAgICAgICAgcGxheWluZz17cGxheWluZ31cbiAgICAgICAgICAgIHNlZWs9e3RoaXMuc2Vla31cbiAgICAgICAgICAgIHZvbHVtZT17dm9sdW1lfVxuICAgICAgICAgIC8+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG4iXSwibmFtZXMiOlsiaWRlbnRpdHkiLCJjbGFzc05hbWUiLCJTZXQiLCJpbmxpbmVTdHlsZSIsImZyb21DbGFzc05hbWUiLCJjbGFzc05hbWVzIiwiZnJvbUlubGluZVN0eWxlIiwiY29uY2F0Iiwic3R5bGVzIiwicmVkdWNlIiwiY2xhc3NOYW1lQSIsImlubGluZVN0eWxlQSIsImNsYXNzTmFtZUIiLCJpbmxpbmVTdHlsZUIiLCJtYXBDbGFzc05hbWUiLCJmbiIsIkFycmF5IiwiZnJvbSIsIm1hcCIsInRvUHJvcHMiLCJwcm9wcyIsInNpemUiLCJzb3J0Iiwiam9pbiIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJzdHlsZSIsInRvZ2dsZSIsInZhbCIsIm1hcHBpbmciLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJyYW5nZSIsInNjYWxlIiwibiIsIk1hdGgiLCJhYnMiLCJyYW5nZVdpdGhvdXRaZXJvIiwiYmluZCIsInNjb3BlIiwibmFtZSIsInVuaW9uIiwiZm5zIiwibWFyZ2luU3RhcnQiLCJ3aGl0ZXNwYWNlIiwibWFyZ2luRW5kIiwibWFyZ2luVG9wIiwibWFyZ2luUmlnaHQiLCJtYXJnaW5Cb3R0b20iLCJtYXJnaW5MZWZ0IiwibWFyZ2luIiwic21NYXJnaW5Ub3AiLCJzbU1hcmdpblJpZ2h0Iiwic21NYXJnaW5Cb3R0b20iLCJzbU1hcmdpbkxlZnQiLCJzbU1hcmdpbiIsIm1kTWFyZ2luVG9wIiwibWRNYXJnaW5SaWdodCIsIm1kTWFyZ2luQm90dG9tIiwibWRNYXJnaW5MZWZ0IiwibWRNYXJnaW4iLCJsZ01hcmdpblRvcCIsImxnTWFyZ2luUmlnaHQiLCJsZ01hcmdpbkJvdHRvbSIsImxnTWFyZ2luTGVmdCIsImxnTWFyZ2luIiwicGFkZGluZ1giLCJwYWRkaW5nWSIsInBhZGRpbmciLCJzbVBhZGRpbmdYIiwic21QYWRkaW5nWSIsInNtUGFkZGluZyIsIm1kUGFkZGluZ1giLCJtZFBhZGRpbmdZIiwibWRQYWRkaW5nIiwibGdQYWRkaW5nWCIsImxnUGFkZGluZ1kiLCJsZ1BhZGRpbmciLCJwcmVmaXgiLCJwcmUiLCJkaXNwbGF5IiwidmFsdWUiLCJjb2x1bW4iLCJmb3JtYXRJbnRCb2ludCIsIngiLCJ0b1N0cmluZyIsInByb3BUb0ZuIiwieHMiLCJjIiwic20iLCJtZCIsImxnIiwibm9uZSIsInhzRGlzcGxheU5vbmUiLCJmbGV4IiwieHNEaXNwbGF5RmxleCIsImJsb2NrIiwieHNEaXNwbGF5QmxvY2siLCJpbmxpbmVCbG9jayIsInhzRGlzcGxheUlubGluZUJsb2NrIiwidmlzdWFsbHlIaWRkZW4iLCJ4c0Rpc3BsYXlWaXN1YWxseUhpZGRlbiIsImRpcmVjdGlvbiIsInJvdyIsInhzRGlyZWN0aW9uUm93IiwieHNEaXJlY3Rpb25Db2x1bW4iLCJzbURpc3BsYXkiLCJzbURpc3BsYXlOb25lIiwic21EaXNwbGF5RmxleCIsInNtRGlzcGxheUJsb2NrIiwic21EaXNwbGF5SW5saW5lQmxvY2siLCJzbURpc3BsYXlWaXN1YWxseUhpZGRlbiIsInNtQ29sdW1uIiwic21EaXJlY3Rpb24iLCJzbURpcmVjdGlvblJvdyIsInNtRGlyZWN0aW9uQ29sdW1uIiwibWREaXNwbGF5IiwibWREaXNwbGF5Tm9uZSIsIm1kRGlzcGxheUZsZXgiLCJtZERpc3BsYXlCbG9jayIsIm1kRGlzcGxheUlubGluZUJsb2NrIiwibWREaXNwbGF5VmlzdWFsbHlIaWRkZW4iLCJtZENvbHVtbiIsIm1kRGlyZWN0aW9uIiwibWREaXJlY3Rpb25Sb3ciLCJtZERpcmVjdGlvbkNvbHVtbiIsImxnRGlzcGxheSIsImxnRGlzcGxheU5vbmUiLCJsZ0Rpc3BsYXlGbGV4IiwibGdEaXNwbGF5QmxvY2siLCJsZ0Rpc3BsYXlJbmxpbmVCbG9jayIsImxnRGlzcGxheVZpc3VhbGx5SGlkZGVuIiwibGdDb2x1bW4iLCJsZ0RpcmVjdGlvbiIsImxnRGlyZWN0aW9uUm93IiwibGdEaXJlY3Rpb25Db2x1bW4iLCJhbGlnbkNvbnRlbnQiLCJzdGFydCIsImxheW91dCIsImNvbnRlbnRTdGFydCIsImVuZCIsImNvbnRlbnRFbmQiLCJjZW50ZXIiLCJjb250ZW50Q2VudGVyIiwiYmV0d2VlbiIsImNvbnRlbnRCZXR3ZWVuIiwiYXJvdW5kIiwiY29udGVudEFyb3VuZCIsImFsaWduSXRlbXMiLCJpdGVtc1N0YXJ0IiwiaXRlbXNFbmQiLCJpdGVtc0NlbnRlciIsImJhc2VsaW5lIiwiaXRlbXNCYXNlbGluZSIsImFsaWduU2VsZiIsInNlbGZTdGFydCIsInNlbGZFbmQiLCJzZWxmQ2VudGVyIiwic2VsZkJhc2VsaW5lIiwic3RyZXRjaCIsInNlbGZTdHJldGNoIiwiYm90dG9tIiwiYm90dG9tMCIsImNvbG9yIiwiYmx1ZSIsImNvbG9ycyIsImJsdWVCZyIsImRhcmtHcmF5IiwiZGFya0dyYXlCZyIsInBpbmUiLCJwaW5lQmciLCJncmF5IiwiZ3JheUJnIiwicmVkIiwicmVkQmciLCJvbGl2ZSIsIm9saXZlQmciLCJsaWdodEdyYXkiLCJsaWdodEdyYXlCZyIsIndoaXRlIiwid2hpdGVCZyIsIm9yYW5nZSIsIm9yYW5nZUJnIiwiZ3JlZW4iLCJncmVlbkJnIiwibmF2eSIsIm5hdnlCZyIsIm1pZG5pZ2h0IiwibWlkbmlnaHRCZyIsInB1cnBsZSIsInB1cnBsZUJnIiwib3JjaGlkIiwib3JjaGlkQmciLCJlZ2dwbGFudCIsImVnZ3BsYW50QmciLCJtYXJvb24iLCJtYXJvb25CZyIsIndhdGVybWVsb24iLCJ3YXRlcm1lbG9uQmciLCJsaWdodFdhc2giLCJsaWdodFdhc2hCZyIsImRhcmtXYXNoIiwiZGFya1dhc2hCZyIsImZpdCIsImdyb3ciLCJmbGV4R3JvdyIsImZsZXhOb25lIiwiaGVpZ2h0IiwianVzdGlmeUNvbnRlbnQiLCJqdXN0aWZ5RW5kIiwianVzdGlmeUNlbnRlciIsImp1c3RpZnlCZXR3ZWVuIiwianVzdGlmeUFyb3VuZCIsImxlZnQiLCJsZWZ0MCIsImRlcHJlY2F0ZWRNYXJnaW4iLCJtdCIsIm1iIiwibWwiLCJtciIsIndoaXRlc3BhY2VMZWdhY3kiLCJ0b3AiLCJtbEF1dG8iLCJyaWdodCIsIm1yQXV0byIsIm1heEhlaWdodCIsIm1heFdpZHRoIiwibWluSGVpZ2h0IiwibWluV2lkdGgiLCJvdmVyZmxvdyIsImhpZGRlbiIsIm92ZXJmbG93SGlkZGVuIiwic2Nyb2xsIiwib3ZlcmZsb3dTY3JvbGwiLCJhdXRvIiwib3ZlcmZsb3dBdXRvIiwic2Nyb2xsWCIsIm92ZXJmbG93U2Nyb2xsWCIsInNjcm9sbFkiLCJvdmVyZmxvd1Njcm9sbFkiLCJkZXByZWNhdGVkUGFkZGluZyIsInkiLCJwb3NpdGlvbiIsImFic29sdXRlIiwicmVsYXRpdmUiLCJmaXhlZCIsInJpZ2h0MCIsInNoYXBlIiwiY2lyY2xlIiwiYm9yZGVycyIsInBpbGwiLCJyb3VuZGVkIiwicm91bmRlZEJvdHRvbSIsInJvdW5kZWRMZWZ0Iiwicm91bmRlZFJpZ2h0Iiwicm91bmRlZFRvcCIsInRvcDAiLCJ3aWR0aCIsIndyYXAiLCJmbGV4V3JhcCIsImRhbmdlcm91c2x5U2V0SW5saW5lU3R5bGUiLCJfX3N0eWxlIiwiY29udGFpbnMiLCJrZXkiLCJhcnIiLCJpbmRleE9mIiwib21pdCIsIm9iaiIsImFjYyIsImsiLCJCb3giLCJjaGlsZHJlbiIsImJsYWNrbGlzdCIsInMiLCJib3giLCJwcm9wIiwiUmVhY3QuY3JlYXRlRWxlbWVudCIsIkNvbHVtblByb3BUeXBlIiwiUHJvcFR5cGVzIiwib25lT2YiLCJNYXJnaW5Qcm9wVHlwZSIsIlBhZGRpbmdQcm9wVHlwZSIsInByb3BUeXBlcyIsIm5vZGUiLCJleGFjdCIsIm9iamVjdCIsIm9uZU9mVHlwZSIsImJvb2wiLCJudW1iZXIiLCJzdHJpbmciLCJhZGQiLCJhZGRDaXJjbGUiLCJhZGRQaW4iLCJhbmdsZWRQaW4iLCJhcnJvd0JhY2siLCJhcnJvd0NpcmNsZURvd24iLCJhcnJvd0NpcmNsZUZvcndhcmQiLCJhcnJvd0Rvd24iLCJhcnJvd0ZvcndhcmQiLCJhcnJvd1VwIiwiYXJyb3dVcFJpZ2h0IiwiYmVsbCIsImNhbWVyYSIsImNhbWVyYVJvbGwiLCJjYW5jZWwiLCJjaGVjayIsImNoZWNrQ2lyY2xlIiwiY2lyY2xlT3V0bGluZSIsImNsZWFyIiwiY2xvY2siLCJjb2ciLCJjb21wYXNzIiwiZGFzaCIsImVkaXQiLCJlbGxpcHNpcyIsImVsbGlwc2lzQ2lyY2xlT3V0bGluZSIsImVudmVsb3BlIiwiZXllIiwiZmFjZWJvb2siLCJmYWNlSGFwcHkiLCJmYWNlU2FkIiwiZmFjZVNtaWxleSIsImZpbHRlciIsImZsYWciLCJmbGFzaGxpZ2h0IiwiZ2lmIiwiZ2xvYmUiLCJnbG9iZUNoZWNrZWQiLCJnbWFpbCIsImdvb2dsZVBsdXMiLCJncmFwaEJhciIsImhhbmRsZSIsImhhbmRQb2ludGluZyIsImhlYXJ0IiwiaGVhcnRCcm9rZW4iLCJrbm9vcCIsImxpZ2h0YnVsYiIsImxpbmsiLCJsb2NhdGlvbiIsImxvY2siLCJtYXhpbWl6ZSIsIm1lZ2FwaG9uZSIsIm1lbnUiLCJtaW5pbWl6ZSIsIm1vdmUiLCJtdXRlIiwicGF1c2UiLCJwZW9wbGUiLCJwZXJzb24iLCJwZXJzb25BZGQiLCJwaW4iLCJwaW5IaWRlIiwicGludGVyZXN0IiwicGxheSIsInF1ZXN0aW9uTWFyayIsInJlbW92ZSIsInJlcG9ydCIsInNlYXJjaCIsInNob3BwaW5nQmFnIiwic21pbGV5Iiwic21pbGV5T3V0bGluZSIsInNlbmQiLCJzaGFyZSIsInNvdW5kIiwic3BlZWNoIiwic3BlZWNoRWxsaXBzaXMiLCJ0YWciLCJ0d2l0dGVyIiwidmlld1R5cGVEZWZhdWx0Iiwidmlld1R5cGVEZW5zZSIsInZpZXdUeXBlTGlzdCIsIkljb25OYW1lcyIsImljb25zIiwiSWNvbiIsImFjY2Vzc2liaWxpdHlMYWJlbCIsImljb24iLCJpbmxpbmUiLCJkYW5nZXJvdXNseVNldFN2Z1BhdGgiLCJjcyIsImNsYXNzbmFtZXMiLCJpY29uQmxvY2siLCJwYXRoIiwiX19wYXRoIiwidW5kZWZpbmVkIiwiYXJpYUhpZGRlbiIsImlzUmVxdWlyZWQiLCJzaG91bGRTY2FsZUltYWdlIiwiSW1hZ2UiLCJoYW5kbGVMb2FkIiwib25Mb2FkIiwiaGFuZGxlRXJyb3IiLCJvbkVycm9yIiwibG9hZEltYWdlIiwicHJldlByb3BzIiwic3JjIiwid2luZG93IiwiaW1hZ2UiLCJvbmxvYWQiLCJvbmVycm9yIiwiYWx0IiwibmF0dXJhbEhlaWdodCIsIm5hdHVyYWxXaWR0aCIsInNpemVzIiwic3JjU2V0IiwiaXNTY2FsZWRJbWFnZSIsImNoaWxkQ29udGVudCIsImJhY2tncm91bmRDb2xvciIsImJhY2tncm91bmRJbWFnZSIsInBhZGRpbmdCb3R0b20iLCJpbWciLCJSZWFjdCIsImZ1bmMiLCJkZWZhdWx0UHJvcHMiLCJNYXNrIiwid2FzaCIsImN4IiwiU3F1YXJlIiwiRGVmYXVsdEF2YXRhciIsImZpcnN0SW5pdGlhbCIsInRvVXBwZXJDYXNlIiwidHlwb2dyYXBoeSIsImFudGlhbGlhc2VkIiwic2Fuc1NlcmlmIiwibGVhZGluZ1NtYWxsIiwiZm9udFdlaWdodEJvbGQiLCJBdmF0YXIiLCJzdGF0ZSIsImlzSW1hZ2VMb2FkZWQiLCJoYW5kbGVJbWFnZUVycm9yIiwic2V0U3RhdGUiLCJvdXRsaW5lIiwidmVyaWZpZWQiLCJib3hTaGFkb3ciLCJTSVpFX1NDQUxFIiwieGwiLCJUZXh0IiwiYWxpZ24iLCJib2xkIiwiaXRhbGljIiwic21TaXplIiwibWRTaXplIiwibGdTaXplIiwibGVhZGluZyIsInRydW5jYXRlIiwiX19kYW5nZXJvdXNseUluY3JlYXNlTGluZUhlaWdodCIsInNtU2NhbGUiLCJtZFNjYWxlIiwibGdTY2FsZSIsImxlYWRpbmdTaG9ydCIsImxlYWRpbmdUYWxsIiwiYWxpZ25DZW50ZXIiLCJhbGlnbkp1c3RpZnkiLCJhbGlnbkxlZnQiLCJhbGlnblJpZ2h0IiwiYnJlYWtXb3JkIiwiZm9udFN0eWxlSXRhbGljIiwiZm9udFN0eWxlTm9ybWFsIiwiZm9udFdlaWdodE5vcm1hbCIsIlRhZyIsInRpdGxlIiwiQnV0dG9uIiwiYWNjZXNzaWJpbGl0eUV4cGFuZGVkIiwiYWNjZXNzaWJpbGl0eUhhc3BvcHVwIiwiZGlzYWJsZWQiLCJvbkNsaWNrIiwidGV4dCIsInR5cGUiLCJ0ZXh0Q29sb3IiLCJ0cmFuc3BhcmVudCIsImNsYXNzZXMiLCJidXR0b24iLCJzb2xpZCIsImVuYWJsZWQiLCJldmVudCIsIkNhcmQiLCJob3ZlcmVkIiwiaGFuZGxlTW91c2VFbnRlciIsIm9uTW91c2VFbnRlciIsImhhbmRsZU1vdXNlTGVhdmUiLCJvbk1vdXNlTGVhdmUiLCJhY3RpdmUiLCJjYXJkIiwiaG92ZXIiLCJDaGVja2JveCIsImZvY3VzZWQiLCJoYW5kbGVDaGFuZ2UiLCJjaGVja2VkIiwidGFyZ2V0Iiwib25DaGFuZ2UiLCJoYW5kbGVCbHVyIiwiaGFuZGxlRm9jdXMiLCJpbmRldGVybWluYXRlIiwic2V0SW5kZXRlcm1pbmF0ZSIsInByZXZpb3VzUHJvcHMiLCJpbnB1dCIsImhhc0Vycm9yIiwiaWQiLCJib3JkZXJTdHlsZSIsImJvcmRlciIsImJvcmRlckRhcmsiLCJib3JkZXJFcnJvciIsImlucHV0RW5hYmxlZCIsImlucHV0U20iLCJpbnB1dE1kIiwiZWwiLCJjaGVja0VuYWJsZWQiLCJjaGVja0ZvY3VzZWQiLCJjaGVja01kIiwiY2hlY2tTbSIsIkNvbGxlY3Rpb24iLCJJdGVtIiwidmlld3BvcnRUb3AiLCJ2aWV3cG9ydExlZnQiLCJtYXgiLCJpdGVtIiwidmlld3BvcnRXaWR0aCIsInZpZXdwb3J0SGVpZ2h0IiwiaXRlbXMiLCJpZHgiLCJwdXNoIiwibGF5b3V0U3R5bGVzIiwiYW55IiwiYXJyYXlPZiIsIlVQIiwiRE9XTiIsIk1JRCIsImNvbHVtbkxheW91dCIsIm51bU9mQ29sdW1ucyIsInBhZGRpbmdBbGwiLCJndXR0ZXIiLCJwb3NpdGlvbnMiLCJtaW5kZXgiLCJtaW5JbmRleCIsImkiLCJjb2x1bW5zRm9yQ29sbGFnZVdpdGhDb3ZlciIsImdldENvbGxhZ2VMYXlvdXQiLCJjb3ZlciIsIm51bUNvbHMiLCJjb2x1bW5zIiwiaCIsInciLCJsYXlvdXRLZXkiLCJncmlkQ29scyIsImxheW91dElkeCIsImNvbEhlaWdodHMiLCJmaWxsIiwiY29sQ291bnRzIiwiY29sIiwiY29sSWR4IiwiaXRlbUhlaWdodCIsImNvdmVySW1hZ2VXaWR0aCIsImNlaWwiLCJ1bnNoaWZ0IiwiQ29sbGFnZSIsInJlbmRlckltYWdlIiwiaW5kZXgiLCJDb2x1bW4iLCJkZXByZWNhdGVkQ29sdW1uIiwic3BhbiIsInNtU3BhbiIsIm1kU3BhbiIsImxnU3BhbiIsIkNvbnRhaW5lciIsIkRpdmlkZXIiLCJkaXZpZGVyIiwiQ2FyZXQiLCJTUEFDRVNfSU5ERVhfTUFQIiwiRElSX0lOREVYX01BUCIsInVwIiwiZG93biIsIk1BUkdJTiIsIkNBUkVUX0hFSUdIVCIsIkNBUkVUX09GRlNFVF9GUk9NX1NJREUiLCJCT1JERVJfUkFESVVTIiwiZ2V0TWFpbkRpciIsImZseW91dFNpemUiLCJpZGVhbERpcmVjdGlvbiIsInRyaWdnZXJSZWN0Iiwid2luZG93U2l6ZSIsInNwYWNlcyIsIm1haW5EaXIiLCJnZXRTdWJEaXIiLCJvZmZzZXQiLCJ0cmlnZ2VyTWlkIiwid2luZG93U3BhY2VBdmFpbGFibGUiLCJhYm92ZU9yTGVmdCIsImJlbG93T3JSaWdodCIsInN1YkRpciIsImNhbGNFZGdlU2hpZnRzIiwiZmx5b3V0VmVydGljYWxTaGlmdCIsImZseW91dEhvcml6b250YWxTaGlmdCIsImNhcmV0VmVydGljYWxTaGlmdCIsImNhcmV0SG9yaXpvbnRhbFNoaWZ0IiwiaXNDbG9zZVZlcnRpY2FsbHkiLCJpc0Nsb3NlSG9yaXpvbnRhbGx5IiwiZmx5b3V0IiwiY2FyZXQiLCJhZGp1c3RPZmZzZXRzIiwiYmFzZSIsImVkZ2VTaGlmdCIsImZseW91dExlZnQiLCJmbHlvdXRUb3AiLCJjYXJldFRvcCIsImNhcmV0UmlnaHQiLCJjYXJldEJvdHRvbSIsImNhcmV0TGVmdCIsImZseW91dE9mZnNldCIsImNhcmV0T2Zmc2V0IiwiYmFzZU9mZnNldHMiLCJyZWxhdGl2ZU9mZnNldCIsIkhBTEZfQ0FSRVQiLCJDb250ZW50cyIsInNldEZseW91dFBvc2l0aW9uIiwicG9zaXRpb25SZWxhdGl2ZVRvQW5jaG9yIiwicGFnZVhPZmZzZXQiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsInNjcm9sbExlZnQiLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsImlubmVySGVpZ2h0IiwiaW5uZXJXaWR0aCIsImNsaWVudEhlaWdodCIsImVkZ2VTaGlmdHMiLCJzZXRUaW1lb3V0Iiwic2hvdWxkRm9jdXMiLCJmb2N1cyIsImFkZEV2ZW50TGlzdGVuZXIiLCJvblJlc2l6ZSIsIm9uS2V5RG93biIsIm5leHRQcm9wcyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJiZ0NvbG9yIiwidmlzaWJpbGl0eSIsImJhY2tncm91bmQiLCJzdHJva2UiLCJib3JkZXJDb2xvciIsImNvbnRhaW5lciIsImRpbWVuc2lvbnMiLCJjb250ZW50cyIsImlubmVyQ29udGVudHMiLCJPdXRzaWRlRXZlbnRCZWhhdmlvciIsImhhbmRsZUNsaWNrRXZlbnQiLCJmaW5kRE9NTm9kZSIsIk5vZGUiLCJjYXB0dXJlIiwiU0laRV9XSURUSF9NQVAiLCJFU0NBUEVfS0VZX0NPREUiLCJDb250cm9sbGVyIiwidHJpZ2dlckJvdW5kaW5nUmVjdCIsImhhbmRsZUtleURvd24iLCJrZXlDb2RlIiwib25EaXNtaXNzIiwiaGFuZGxlUGFnZUNsaWNrIiwiYW5jaG9yIiwiaGFuZGxlUmVzaXplIiwidXBkYXRlVHJpZ2dlclJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwiRmx5b3V0IiwiemlwIiwiYSIsImIiLCJCT1JERVJfV0lEVEgiLCJBVkFUQVJfU0laRVMiLCJhdmF0YXJMYXlvdXQiLCJ0ZXh0TGF5b3V0IiwiZGVnVG9SYWQiLCJkZWciLCJQSSIsInF1YXJ0ZXJQYWRkaW5nIiwic2luIiwiaW5pdGlhbCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdUb3AiLCJHcm91cEF2YXRhciIsImNvbGxhYm9yYXRvcnMiLCJhdmF0YXJXaWR0aCIsImF2YXRhckhlaWdodCIsIndpbGxDaGFuZ2UiLCJjb2xsYWJvcmF0b3IiLCJkZWZhdWx0SGVhZGluZ0xldmVscyIsIkhlYWRpbmciLCJhY2Nlc3NpYmlsaXR5TGV2ZWwiLCJoZWFkaW5nTGV2ZWwiLCJTSVpFX05BTUVfVE9fUElYRUwiLCJkZWZhdWx0SWNvbkJ1dHRvbkljb25Db2xvcnMiLCJQb2ciLCJpY29uQ29sb3IiLCJpY29uU2l6ZSIsInBvZyIsIkljb25CdXR0b24iLCJoYW5kbGVNb3VzZURvd24iLCJoYW5kbGVNb3VzZVVwIiwiTGFiZWwiLCJodG1sRm9yIiwibGFiZWwiLCJMYXllciIsImNyZWF0ZUVsZW1lbnQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsImNyZWF0ZVBvcnRhbCIsImFzcGVjdFJhdGlvIiwiTGV0dGVyYm94IiwiY29udGVudEFzcGVjdFJhdGlvIiwidmlld3BvcnRBc3BlY3RSYXRpbyIsImNvbnRlbnRIZWlnaHQiLCJjb250ZW50V2lkdGgiLCJUQUJfS0VZX0NPREUiLCJMaW5rIiwiZW5hYmxlRm9jdXNTdHlsZXMiLCJoYW5kbGVDbGljayIsImhyZWYiLCJoYW5kbGVLZXlVcCIsInJlbCIsImxpbmtUYXJnZXQiLCJhY2Nlc3NpYmxlRm9jdXNTdHlsZSIsImRlYm91bmNlIiwidGhyZXNoaG9sZCIsImRlZmVyVGltZXIiLCJkZWJvdW5jZWQiLCJhcmdzIiwiY2xlYXJUaW1lb3V0IiwiRmV0Y2hJdGVtcyIsImNvbnRhaW5lckhlaWdodCIsImlzQXRFbmQiLCJpc0ZldGNoaW5nIiwiZmV0Y2hNb3JlIiwic2Nyb2xsSGVpZ2h0Iiwic2Nyb2xsQnVmZmVyIiwiZ2V0U2Nyb2xsQ29udGFpbmVyIiwic2Nyb2xsQ29udGFpbmVyIiwiU2Nyb2xsQ29udGFpbmVyIiwiZ2V0U2Nyb2xsQ29udGFpbmVyUmVmIiwiaGFuZGxlU2Nyb2xsIiwib25TY3JvbGwiLCJ1cGRhdGVTY3JvbGxDb250YWluZXIiLCJuZXh0U2Nyb2xsQ29udGFpbmVyIiwib25seSIsInRocm90dGxlIiwibGFzdCIsInRocm90dGxlZCIsIm5vdyIsIkRhdGUiLCJNZWFzdXJlbWVudFN0b3JlIiwiV2Vha01hcCIsImdldCIsImhhcyIsInNldCIsImdldEVsZW1lbnRIZWlnaHQiLCJlbGVtZW50IiwiZ2V0V2luZG93U2Nyb2xsUG9zIiwiZ2V0UmVsYXRpdmVTY3JvbGxUb3AiLCJnZXRTY3JvbGxIZWlnaHQiLCJnZXRTY3JvbGxQb3MiLCJEZWZhdWx0TGF5b3V0U3ltYm9sIiwiU3ltYm9sIiwiVW5pZm9ybVJvd0xheW91dFN5bWJvbCIsIm9mZnNjcmVlbiIsIkluZmluaXR5IiwiY2FjaGUiLCJjb2x1bW5XaWR0aCIsIm1pbkNvbHMiLCJjb2x1bW5XaWR0aEFuZEd1dHRlciIsImNvbHVtbkNvdW50IiwiZmxvb3IiLCJoZWlnaHRzIiwiY2VudGVyT2Zmc2V0IiwiaGVpZ2h0QW5kR3V0dGVyIiwic2xpY2UiLCJzdW0iLCJpZGVhbENvbHVtbldpZHRoIiwiY29sZ3Vlc3MiLCJNYXNvbnJ5TGF5b3V0IiwiVW5pZm9ybVJvd0xheW91dCIsIlJFU0laRV9ERUJPVU5DRSIsIlZJUlRVQUxfQlVGRkVSX0ZBQ1RPUiIsImxheW91dE51bWJlclRvQ3NzRGltZW5zaW9uIiwiTWFzb25yeSIsImdyaWRXcmFwcGVyIiwiY2xpZW50V2lkdGgiLCJ1cGRhdGVTY3JvbGxQb3NpdGlvbiIsIm1lYXN1cmVDb250YWluZXJBc3luYyIsIm1lYXN1cmVDb250YWluZXIiLCJzZXRHcmlkV3JhcHBlclJlZiIsInJlZiIsInNldFNjcm9sbENvbnRhaW5lclJlZiIsImxvYWRJdGVtcyIsInJlbmRlck1hc29ucnlDb21wb25lbnQiLCJpdGVtRGF0YSIsIkNvbXBvbmVudCIsImNvbXAiLCJ2aXJ0dWFsaXplIiwidmlydHVhbEJvdW5kc1RvcCIsInZpcnR1YWxCb3VuZHNCb3R0b20iLCJpc1Zpc2libGUiLCJ2aXJ0dWFsQnVmZmVyIiwib2Zmc2V0U2Nyb2xsUG9zIiwiY29udGFpbmVyT2Zmc2V0Iiwidmlld3BvcnRCb3R0b20iLCJpdGVtQ29tcG9uZW50IiwiTWFzb25yeV9fSXRlbSIsIk1hc29ucnlfX0l0ZW1fX01vdW50ZWQiLCJ0cmFuc2Zvcm0iLCJXZWJraXRUcmFuc2Zvcm0iLCJoYXNQZW5kaW5nTWVhc3VyZW1lbnRzIiwic29tZSIsIm1lYXN1cmVtZW50U3RvcmUiLCJwcmV2U3RhdGUiLCJyZXNldCIsImluc2VydEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJzY3JvbGxDb250YWluZXJSZWYiLCJIVE1MRWxlbWVudCIsInJlbGF0aXZlU2Nyb2xsVG9wIiwiZm9yY2VVcGRhdGUiLCJmbGV4aWJsZSIsImd1dHRlcldpZHRoIiwiZnVsbFdpZHRoTGF5b3V0IiwiTGVnYWN5VW5pZm9ybVJvd0xheW91dCIsInVuaWZvcm1Sb3dMYXlvdXQiLCJkZWZhdWx0TGF5b3V0IiwiZ3JpZEJvZHkiLCJpdGVtc1RvUmVuZGVyIiwiaXRlbXNUb01lYXN1cmUiLCJtZWFzdXJpbmdQb3NpdGlvbnMiLCJwb3MiLCJkYXRhIiwibWVhc3VyZW1lbnRJbmRleCIsImluc3RhbmNlT2YiLCJMZWdhY3lNYXNvbnJ5TGF5b3V0Iiwic3ltYm9sIiwiTm9TY3JvbGxCZWhhdmlvciIsInByZXZPdmVyZmxvdyIsInF1ZXJ5Rm9jdXNhYmxlQWxsIiwic2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9jdXNFbGVtZW50IiwiVHJhcEZvY3VzQmVoYXZpb3IiLCJzZXRFbFJlZiIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0IiwiZm9jdXNGaXJzdENoaWxkIiwicHJldmlvdXNseUZvY3VzZWRFbCIsImFjdGl2ZUVsZW1lbnQiLCJCYWNrZHJvcCIsIk1vZGFsIiwiaGFuZGxlT3V0c2lkZUNsaWNrIiwiaGFuZGxlQ2xvc2VDbGljayIsImFjY2Vzc2liaWxpdHlDbG9zZUxhYmVsIiwiYWNjZXNzaWJpbGl0eU1vZGFsTGFiZWwiLCJmb290ZXIiLCJoZWFkaW5nIiwicm9sZSIsIndyYXBwZXIiLCJwYWRkaW5nTGVmdCIsIlB1bHNhciIsInBhdXNlZCIsImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IiwiaW5uZXJDaXJjbGUiLCJvdXRlckNpcmNsZSIsIlJhZGlvQnV0dG9uIiwiUmFkaW9CdXR0b25Jc0ZvY3VzZWQiLCJSYWRpb0J1dHRvblNtIiwiUmFkaW9CdXR0b25NZCIsIlJhZGlvQnV0dG9uV2hpdGVCZyIsIlJhZGlvQnV0dG9uTGlnaHRHcmF5QmciLCJJbnB1dCIsIklucHV0RW5hYmxlZCIsIklucHV0U20iLCJJbnB1dE1kIiwiQ2hlY2siLCJDaGVja1NtIiwiQ2hlY2tNZCIsIkNoZWNrRW5hYmxlZCIsIkNoZWNrRGlzYWJsZWQiLCJTY3JvbGxGZXRjaCIsInVwZGF0ZVBvc2l0aW9uIiwiZ2V0U2Nyb2xsU3RhdGUiLCJyZW5kZXJIZWlnaHQiLCJTZWFyY2hGaWVsZCIsImN1cnJlbnRUYXJnZXQiLCJzeW50aGV0aWNFdmVudCIsImhhbmRsZUNsZWFyIiwib25Gb2N1cyIsIm9uQmx1ciIsInBsYWNlaG9sZGVyIiwic2hvd0NsZWFyIiwicG9pbnRlckV2ZW50cyIsIlNlZ21lbnRlZENvbnRyb2wiLCJzZWxlY3RlZEl0ZW1JbmRleCIsImlzU2VsZWN0ZWQiLCJpdGVtSXNOb3RTZWxlY3RlZCIsIml0ZW1Jc1NlbGVjdGVkIiwiZSIsImFjdGl2ZUluZGV4IiwiU2VsZWN0TGlzdCIsImVycm9ySXNPcGVuIiwiaGFuZGxlT25DaGFuZ2UiLCJIVE1MU2VsZWN0RWxlbWVudCIsImVycm9yTWVzc2FnZSIsImlkZWFsRXJyb3JEaXJlY3Rpb24iLCJvcHRpb25zIiwic2VsZWN0IiwiZXJyb3JlZCIsIm5vcm1hbCIsImJvcmRlclJhZGl1cyIsIm9wdGlvbiIsIlNJWkUiLCJTcGlubmVyIiwic2hvdyIsIlN0aWNreSIsImRhbmdlcm91c2x5U2V0WkluZGV4IiwiX196SW5kZXgiLCJ6SW5kZXgiLCJzdGlja3kiLCJTd2l0Y2giLCJzd2l0Y2hlZCIsInN3aXRjaFN0eWxlcyIsInN3aXRjaCIsInN3aXRjaEdyYXkiLCJzd2l0Y2hMaWdodEdyYXkiLCJzd2l0Y2hEYXJrR3JheSIsInN3aXRjaFdoaXRlIiwic2xpZGVyU3R5bGVzIiwic2xpZGVyIiwic2xpZGVyUmlnaHQiLCJzbGlkZXJMZWZ0Iiwic2xpZGVyRGFyayIsInNsaWRlckxpZ2h0IiwiaW5wdXRTdHlsZXMiLCJjaGVja2JveCIsImNoZWNrYm94RW5hYmxlZCIsIlRhYnMiLCJmb2N1c2VkVGFiSW5kZXgiLCJob3ZlcmVkVGFiSW5kZXgiLCJoYW5kbGVUYWJDbGljayIsImFjdGl2ZVRhYkluZGV4IiwiaGFuZGxlVGFiRm9jdXMiLCJoYW5kbGVUYWJCbHVyIiwiaGFuZGxlVGFiTW91c2VFbnRlciIsImhhbmRsZVRhYk1vdXNlTGVhdmUiLCJ0YWJzIiwiaXNBY3RpdmUiLCJpc0hvdmVyZWQiLCJpc0ZvY3VzZWQiLCJ0YWIiLCJ0YWJJc05vdEFjdGl2ZSIsInRhYklzQWN0aXZlIiwiVGV4dEFyZWEiLCJyb3dzIiwidGV4dEFyZWEiLCJ0ZXh0YXJlYSIsIlRleHRGaWVsZCIsImF1dG9Db21wbGV0ZSIsInRleHRGaWVsZCIsInBhdHRlcm4iLCJ0ZXh0ZmllbGQiLCJUb2FzdCIsInRodW1ibmFpbCIsImZvbnRXZWlnaHQiLCJUb29sdGlwIiwiU1BBQ0VfQ0hBUl9DT0RFIiwiRU5URVJfQ0hBUl9DT0RFIiwiVG91Y2hhYmxlIiwiaGFuZGxlS2V5UHJlc3MiLCJvblRvdWNoIiwiY2hhckNvZGUiLCJmdWxsV2lkdGgiLCJmdWxsSGVpZ2h0IiwibW91c2VDdXJzb3IiLCJ0b3VjaGFibGUiLCJWaWRlb1BsYXloZWFkIiwic2Vla2luZyIsInNldFBsYXloZWFkUmVmIiwicGxheWhlYWQiLCJzZWVrIiwiY2xpZW50WCIsImR1cmF0aW9uIiwicGVyY2VudCIsIm1pbiIsIm5ld1RpbWUiLCJzdG9wQ2xpY2siLCJoYW5kbGVNb3VzZU1vdmUiLCJjdXJyZW50VGltZSIsImZ1bGxzY3JlZW5FbmFibGVkIiwid2Via2l0RnVsbHNjcmVlbkVuYWJsZWQiLCJtb3pGdWxsU2NyZWVuRW5hYmxlZCIsIm1zRnVsbHNjcmVlbkVuYWJsZWQiLCJ0aW1lVG9TdHJpbmciLCJ0aW1lIiwibWludXRlcyIsInNlY29uZHMiLCJtaW51dGVzU3RyIiwic2Vjb25kc1N0ciIsIlZpZGVvQ29udHJvbHMiLCJoYW5kbGVGdWxsc2NyZWVuQ2hhbmdlIiwib25GdWxsc2NyZWVuQ2hhbmdlIiwiaGFuZGxlUGxheWluZ0NoYW5nZSIsInBsYXlpbmciLCJvblBhdXNlIiwib25QbGF5IiwiaGFuZGxlVm9sdW1lQ2hhbmdlIiwib25Wb2x1bWVDaGFuZ2UiLCJhY2Nlc3NpYmlsaXR5TWF4aW1pemVMYWJlbCIsImFjY2Vzc2liaWxpdHlNaW5pbWl6ZUxhYmVsIiwiYWNjZXNzaWJpbGl0eU11dGVMYWJlbCIsImFjY2Vzc2liaWxpdHlQYXVzZUxhYmVsIiwiYWNjZXNzaWJpbGl0eVBsYXlMYWJlbCIsImFjY2Vzc2liaWxpdHlVbm11dGVMYWJlbCIsImZ1bGxzY3JlZW4iLCJ2b2x1bWUiLCJtdXRlZCIsInNob3dGdWxsc2NyZWVuQnV0dG9uIiwiY29udHJvbHMiLCJyZXF1ZXN0RnVsbHNjcmVlbiIsIndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuIiwibW96UmVxdWVzdEZ1bGxTY3JlZW4iLCJtc1JlcXVlc3RGdWxsc2NyZWVuIiwiZXhpdEZ1bGxzY3JlZW4iLCJ3ZWJraXRFeGl0RnVsbHNjcmVlbiIsIm1vekNhbmNlbEZ1bGxTY3JlZW4iLCJtc0V4aXRGdWxsc2NyZWVuIiwiaXNGdWxsc2NyZWVuIiwiZnVsbHNjcmVlbkVsZW1lbnQiLCJ3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCIsIm1vekZ1bGxTY3JlZW5FbGVtZW50IiwibXNGdWxsc2NyZWVuRWxlbWVudCIsImFkZEZ1bGxzY3JlZW5FdmVudExpc3RlbmVyIiwibGlzdGVuZXIiLCJyZW1vdmVGdWxsc2NyZWVuRXZlbnRMaXN0ZW5lciIsImlzTmV3U291cmNlIiwib2xkU291cmNlIiwibmV3U291cmNlIiwiaXNBcnJheSIsInNvdXJjZSIsIlZpZGVvIiwic2V0UGxheWVyUmVmIiwicGxheWVyIiwic2V0VmlkZW9SZWYiLCJ2aWRlbyIsInNldFBsYXliYWNrUmF0ZSIsInBsYXliYWNrUmF0ZSIsInNldFZvbHVtZSIsImxvYWQiLCJ0b2dnbGVGdWxsc2NyZWVuIiwiaGFuZGxlQ2FuUGxheSIsIm9uUmVhZHkiLCJoYW5kbGVEdXJhdGlvbkNoYW5nZSIsIm9uRHVyYXRpb25DaGFuZ2UiLCJoYW5kbGVFbmRlZCIsIm9uRW5kZWQiLCJoYW5kbGVQbGF5IiwiaGFuZGxlUGF1c2UiLCJoYW5kbGVQcm9ncmVzcyIsIm9uTG9hZGVkQ2hhbmdlIiwiYnVmZmVyZWQiLCJsb2FkZWQiLCJoYW5kbGVTZWVrIiwib25TZWVrIiwiaGFuZGxlVGltZVVwZGF0ZSIsIm9uVGltZUNoYW5nZSIsImNhcHRpb25zIiwibG9vcCIsInBsYXlzSW5saW5lIiwicG9zdGVyIiwicHJlbG9hZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQXlCQSxFQUFPLElBQU1BLFdBQVcsU0FBWEEsUUFBVztFQUFBLFNBQWM7RUFDcENDLGVBQVcsSUFBSUMsR0FBSixFQUR5QjtFQUVwQ0MsaUJBQWE7RUFGdUIsR0FBZDtFQUFBLENBQWpCOztFQVBQO0VBQ0E7OztBQVdBLEVBQU8sSUFBTUMsZ0JBQWdCLFNBQWhCQSxhQUFnQjtFQUFBLG9DQUFJQyxVQUFKO0VBQUlBLGNBQUo7RUFBQTs7RUFBQSxTQUEwQztFQUNyRUosZUFBVyxJQUFJQyxHQUFKLENBQVFHLFVBQVIsQ0FEMEQ7RUFFckVGLGlCQUFhO0VBRndELEdBQTFDO0VBQUEsQ0FBdEI7O0FBS1AsRUFBTyxJQUFNRyxrQkFBa0IsU0FBbEJBLGVBQWtCLENBQUNILFdBQUQ7RUFBQSxTQUFzQztFQUNuRUYsZUFBVyxJQUFJQyxH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
